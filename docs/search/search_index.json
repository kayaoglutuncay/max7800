{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>For ordering information, mechanical and electrical characteristics for the MAX78000 family of devices refer to the device data sheet. For information on the Arm\u00ae Cortex\u00ae-M4 with FPU core, please refer to the Arm Cortex-M4 Processor Technical Reference Manual.</p>"},{"location":"#related-documentation","title":"Related Documentation","text":"<p>The MAX78000 data sheet and errata are available from the Analog Devices website, MAX78000.</p>"},{"location":"#document-conventions","title":"Document Conventions","text":""},{"location":"#number-notations","title":"Number Notations","text":"Notation Description 0xNN Hexadecimal (Base 16) numbers are preceded by the prefix 0x. 0bNN Binary (Base 2) numbers are preceded by the prefix 0b. NN Decimal (Base 10) numbers are represented using no additional prefix or suffix. V[X:Y] Bit field representation of a register, field, or value (V) covering Bit X to Bit Y. Bit N Bits are numbered in little-endian format; that is, the least significant bit of a number is referred to as bit 0. [0xNNNN] An address offset from a base address is shown in bracket form."},{"location":"#register-and-field-access-definitions","title":"Register and Field Access Definitions","text":"<p>All the fields that are accessible by user software have distinct access capabilities. Each register table contained in this user guide has an access type defined for each field. The definition of each field access type is presented in Table 1-1.</p> <p>Table 1-1: Field Access Definitions </p> Access Type Description RO ReservedThis access type is reserved for static fields. Reads of this field return the reset value. Writes are ignored. DNM Reserved. Do Not ModifySoftware must first read this field and write the same value whenever writing to this register. R Read OnlyReads of this field return a value. Writes to the field do not affect device operation. W Write OnlyReads of this field return indeterminate values. Writes to the field change the field's state to the value written and can affect device operation.          R/W Unrestricted Read/WriteReads of this field return a value. Writes to the field change the field's state to the value written and can affect device operation.          RC Read to ClearReading this field clears the field to 0. Writes to the field do not affect device operation. RS Read to SetReading this field sets the field to 1. Writes to the field do not affect device operation. R/W0 Read/Write 0 OnlyWriting 0 to this field sets the field to 0. Writing 1 to the field does not affect device operation. R/W1 Read/Write 1 OnlyWriting 1 to this field sets the field to 1. Writing 0 to the field does not affect device operation. R/W1C Read/Write 1 to ClearWriting 1 to this field clears this field to 0. Writing 0 to the field does not affect device operation. R/W0S Read/Write 0 to SetWriting 0 to this field sets this field to 1. Writing 1 to the field does not affect device operation."},{"location":"#register-lists","title":"Register Lists","text":"<p>Each peripheral includes a table listing all of the peripheral's registers. The register table includes the offset, register name, and description of each register. The offset shown in the table must be added to the peripheral's base address in Table 3-3 to get the register's absolute address.</p> <p>Table 1-2: Example Registers </p> Offset Register Name Description [0x0000] REG_NAME0 Name 0 Register"},{"location":"#register-detail-tables","title":"Register Detail Tables","text":"<p>Each register in a peripheral includes a detailed register table, as shown in Table 1-3. The first row of the register detail table includes the register's description, the register's name, and the register's offset from the base peripheral address. The second row of the table is the header for the bit fields represented in the register. The third and subsequent rows of the table include the bit or bit range, the field name, the bit's or field's access, the reset value, and a description of the field. All registers are 32-bits unless specified otherwise. Reserved bits and fields are shown as Reserved in the description column. See Table 1-1 for a list of all access types for each bit and field.</p> <p>Table 1-3: Example Name 0 Register </p> Name 0 REG_NAME0 [0x0000] Bits Name Access Reset Description 31:16 - RO - Reserved 15:0 field_name R/W 0 Field name description     Description of field_name."},{"location":"adc-and-comparators/","title":"Analog to Digital Converter (ADC) and Comparators (LPCMP)","text":"<p>The ADC is a 10-bit sigma-delta ADC with a single-ended input multiplexer and an integrated reference generator. The multiplexer selects an input channel from either the 8 external analog input signals or the internal power supply inputs. The external analog input signals are defined as alternate functions on GPIO, as shown in Table 11-1.</p> <p>The 10 - bit ADC conversions are stored as a 16-bit value selectable as MSB or LSB aligned. The 8 external analog inputs can be configured by software as 4 two-input comparators with interrupt capabilities. Comparator 0, CMP0, is configurable to wake the device from SLEEP, LPM, UPM, STANDBY, and BACKUP. The remaining three comparators, CMP1, CMP2, and CMP3, are configurable as wake-up sources from SLEEP, LPM, and UPM.</p>"},{"location":"adc-and-comparators/#features","title":"Features","text":"<ul> <li>Maximum 8MHz ADC clock rate</li> <li>Two reference source options<ul> <li>An internal 1.22V bandgap</li> <li>V<sub>DDA</sub>/2 supply</li> </ul> </li> <li>8 external analog inputs configurable as 4 two-input comparators</li> <li>8 internal power supply monitor inputs</li> <li>Fixed 10-bit word conversion time of 1024 ADC clock cycles</li> <li>Programmable out-of-range (limit) detection</li> <li>Interrupt generation for limit detection, conversion start, conversion complete, and internal reference powered on</li> <li>Serial ADC data measurements</li> <li>ADC conversion 10-bit output either MSB or LSB aligned</li> </ul>"},{"location":"adc-and-comparators/#instances","title":"Instances","text":"<p>Table 11-1: MAX78000 ADC Input Pins for the 81-CTBGA Package </p> Function 81 CTBGA Pin 81 CTBGA Alternate Function AIN0 / AIN0N P2.0 AF1 AIN1 / AIN0P P2.1 AF1 AIN2 / AIN1N P2.2 AF1 AIN3 / AIN1P P2.3 AF1 AIN4 / AIN2N P2.4 AF1 AIN5 / AIN2P P2.5 AF1 AIN6 / AIN3N P2.6 AF1 AIN7 / AIN3P P2.7 AF1"},{"location":"adc-and-comparators/#architecture","title":"Architecture","text":"<p>The ADC is a first-order sigma-delta converter with 10-bit output. The ADC operates at a maximum frequency of 8MHz with a fixed-sample rate as shown in Equation 11-1. Details of selecting the ADC clock frequency, \\({f_{\\text{adcclk}}}\\), are covered in the Clock Configuration section.</p> <p>Equation 11-1: ADC 10-bit Word Sample Rate </p> \\[  t_{\\text{adc_sample}} = 1024 \\times \\left( \\frac{1}{f_{\\text{adcclk}}} \\right) \\] <p>The ADC offset is factory trimmed and automatically loaded into the ADC controller during system power-up.</p> <p>The ADC uses a switched capacitor network to perform the conversion; this results in dynamic switching current and requires settling time for the external analog input signals (AIN0 \u2013 AIN7). This dynamic switching current sets the upper limit of the source impedance of the external analog input signals to approximately 10k\u03a9.</p> <p>The ADC supports a gain of 2 \u00d7 to provide additional conversion resolution if the input signals are less than half the reference voltage.</p> <p>Figure 11-1: Analog to Digital Converter Block Diagram </p> <p></p>"},{"location":"adc-and-comparators/#clock-configuration","title":"Clock Configuration","text":"<p>The ADC clock, adcclk, is controlled by the GCR_PCLKDIV.adcfrq register field. Configure this field to achieve the target ADC sample frequency. The maximum clock frequency supported by the ADC is 8MHz. The divisor selection, GCR_PCLKDIV.adcfrq, for the ADC depends on the peripheral clock. Equation 11-2 shows the calculation for the ADC clock.</p> <p>Equation 11-2: ADC Clock Frequency </p> \\[ f_{\\text{adcclk}} = \\frac{f_{\\text{PCLK}}}{\\text{GCR_PCKDIV.adcfrq}} \\] <p>The GCR_PCLKDIV.adcfrq field setting must result in a value for \\(f_{\\text{adcclk}} \\le 8\\,\\text{MHz}\\) as shown in Table 11-2 with IPO set as the system clock.   </p> <p>Table 11-2: MAX78000 ADC Clock Frequency and ADC Conversion Time with the System Clock set to the IPO </p> GCR_PCLKDIV.adcfrq ADC Clock Frequency (Hz)<p> f<sub>adcclk</sub> 10-Bit Word Conversion Time (\ud835\udf07s) t<sub>adc_sample</sub> 0 \u2013 7 Invalid Invalid 8 6,250,000 164 9 5,555,555 184 10 5,000,000 205 11 4,545,454 225 12 4,166,666 246 13 3,846,153 266 14 3,571,428 287 15 3,333,333 307"},{"location":"adc-and-comparators/#power-up-sequence","title":"Power-Up Sequence","text":"<p>Complete the following steps to configure the ADC:</p> <ol> <li>Disable the ADC clock by setting the ADC_CTRL.clk_en field to 0.</li> <li>Set the ADC clock (\\({f_{\\text{adcclk}}}\\)) using the GCR_PCLKDIV.adcfrq field. See Clock Configuration for details.</li> <li>Enable the ADC clock by setting the ADC_CTRL.clk_en field to 1</li> <li>Clear the ADC reference ready interrupt flag by writing a 1 to ADC_INTR.ref_ready_if.</li> <li>Optionally enable the ADC reference ready interrupt by setting the ADC_INTR.ref_ready_ie field to 1 and enable the ADC interrupt handler (ADC_IRQn).</li> <li> <p>Select one of the following ADC reference sources:</p> <p>a. Internal 1.22V bandgap reference (ADC_CTRL.ref_sel = 0).</p> <p>b. V<sub>DDA</sub>/2 reference (ADC_CTRL.ref_sel = 1).</p> </li> <li> <p>Complete the following steps to enable power to the ADC and optionally the internal ADC reference:</p> <p>a. Set ADC_CTRL.pwr to 1 to turn on the ADC.</p> <p>b. Set ADC_CTRL.refbuf_pwr to 1 to turn on the internal reference buffer If using the internal reference.</p> <p>c. Wait until hardware sets the ADC_INTR.ref_ready_if field to 1, indicating the internal reference is fully powered on and ready.</p> <p>d. Clear the ADC reference ready interrupt flag by writing 1 to ADC_INTR.ref_ready_if.</p> <p>e. Optionally disable the ADC reference ready interrupt by clearing the ADC_INTR.ref_ready_ie field to 0.</p> </li> </ol>"},{"location":"adc-and-comparators/#conversion","title":"Conversion","text":"<p>After the power-up sequence is complete, the ADC is ready for data conversion. Complete the following steps to perform a data conversion.</p> <ol> <li>Select the ADC input channel for the conversion by setting the ADC_CTRL.ch_sel field. See ADC Channel Select for details.</li> <li>Optionally set input and reference scaling. See Scale Limitations for All Other Input Channels for details on each input channel\u2019s scale requirements.</li> <li> <p>Set the data alignment for the conversion output data using the ADC_CTRL.data_align field.</p> <p>a. 0 for LSB alignment or 1 for MSB alignment. See Table 11-3 for alignment details of the ADC_DATA register.</p> </li> <li> <p>Clear the ADC done interrupt flag by writing 1 to the ADC_INTR.done_if field.</p> </li> <li>Optionally enable the ADC done interrupt (ADC_INTR.done_ie = 1) and enable the ADC interrupt vector (ADC_IRQn).</li> <li>Start the ADC conversion by setting the ADC_CTRL.start field to 1.</li> <li>Poll the ADC_INTR.done_if flag until it reads 1 or wait for the ADC interrupt to occur if enabled.</li> <li>Read the data from the ADC_DATA register and clear the ADC done interrupt flag by writing 1 to the ADC_INTR.done_if field.</li> </ol>"},{"location":"adc-and-comparators/#data-conversion-output-alignment","title":"Data Conversion Output Alignment","text":"<p>The ADC outputs 10-bits per conversion and stores the data in the ADC_DATA register LSB justified by default. Table 11-3 shows the ADC data alignment based on the value of the ADC_CTRL.data_align bit. </p> <p>Table 11-3: ADC Data Register Alignment Options </p> ADC_CTRL.data_align\u00a0=\u00a00 MSB LSB 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 ADC_DATA 0 0 0 0 0 0 data ADC_CTRL.data_align\u00a0=\u00a01 MSB LSB 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 ADC_DATA data 0 0 0 0 0 0"},{"location":"adc-and-comparators/#data-conversion-value-equations","title":"Data Conversion Value Equations","text":"<p>Use the following equations to calculate the ADC data value for a conversion for the selected channel. If using the internal reference, V<sub>REF</sub> = 1.22V; otherwise, V<sub>REF</sub> = V<sub>DDA</sub>.</p> <p>Equation 11-3: ADC Data Calculation for Input Signal ADC_CTRL.ch_sel = 0 through 7 (AIN0 - AIN7) </p> \\[ \\text{ADC_DATA} = \\text{round}\\left( \\left( \\frac{\\frac{\\text{Input Signal}}{2^{\\text{scale}} \\cdot (\\text{adc_divsel} + 1)}}{\\frac{V_{\\text{REF}}}{2^{\\text{ref_scale}}}} \\right) \\cdot \\left( 2^{10} - 1 \\right) \\right) \\] <p>Note: Must satisfy Equation 11-6.</p> <p>Equation 11-4: ADC Data Equation for Input Signal ADC_CTRL.ch_sel = 8 through 12 (V<sub>COREA</sub>, V<sub>COREB</sub>, V<sub>RXOUT</sub>, V<sub>TXOUT</sub>, V<sub>DDA</sub>)</p> \\[ \\text{ADC_DATA} = \\text{round} \\{ \\left( \\frac{\\frac{\\text{Input Signal}}{2^{\\text{scale}}}}{\\frac{V_{\\text{REF}}}{2^{\\text{ref_scale}}}} \\right) \\cdot \\left( 2^{10} - 1 \\right) \\} \\] <p>Note: See Table 11-4 for limitations.</p> <p>Equation 11-5: ADC Data Calculation Input Signal ADC_CTRL.ch_sel = 14 through 16 (V<sub>DDIO</sub>, V<sub>DDIOH</sub>, V<sub>REGI</sub>)</p> \\[ \\text{ADC_DATA} = \\text{round}\\left\\{ \\frac{\\left( \\frac{\\frac{\\text{Input Signal}}{4}}{2^{\\text{scale}}} \\right)}{\\left( \\frac{V_{\\text{REF}}}{2^{\\text{ref_scale}}} \\right)} \\cdot \\left( 2^{10} - 1 \\right) \\right\\} \\] <p>Note: See Table 11-4 for limitations.</p>"},{"location":"adc-and-comparators/#reference-scaling-and-input-scaling","title":"Reference Scaling and Input Scaling","text":"<p>For small signals, the ADC input, ADC reference, or both can be scaled by 50%. This enables flexibility to achieve better resolution on the ADC conversion. Each input channel supports the default of no scaling of the input (ADC_CTRL.scale = 0) and no reference scaling (ADC_CTRL.ref_scale = 0). The following sections describe the scale options for each of the ADC input channels.</p>"},{"location":"adc-and-comparators/#ain0-ain7-scale-limitations","title":"AIN0 \u2013 AIN7 Scale Limitations","text":"<p>The external inputs, AIN0 through AIN7, support scaling of the input by 50%, the reference by 50%, or both by 50%. Also, the scaling can further be modified by additional factors of 2, 3, or 4 as defined by ADC_CTRL.adc_divsel. The scale settings for the given input signal and reference must satisfy Equation 11-6 to be valid:</p> <p>Equation 11-6: Input and Reference Scale Requirements Equation </p> \\[ \\frac{AINn}{2^{\\text{scale}}} &lt; \\frac{V_{\\text{REF}}}{2^{\\text{ref_scale}}} \\]"},{"location":"adc-and-comparators/#scale-limitations-for-all-other-input-channels","title":"Scale Limitations for All Other Input Channels","text":"<p>The scale settings must either be disabled or enabled for the remaining internal input channels, as shown in Table 11-4.</p> <p>Table 11-4: Input and Reference Scale Support by ADC Input Channel </p> ADC Channel ADC Input Signal ADC_CTRL.scale ADC_CTRL.ref_scale 8 V<sub>COREA</sub> 0 0 1 1 9 V<sub>COREB</sub> 0 0 1 1 10 V<sub>RXOUT</sub> 0 0 1 1 11 V<sub>TXOUT</sub> 0 0 1 1 12 V<sub>DDA</sub> 0 0 1 1 14 V<sub>DDIO</sub> / 4 0 0 1 1 15 V<sub>DDIOH</sub> / 4 0 0 1 1 16 V<sub>REGI</sub> / 4 0 0 1 1"},{"location":"adc-and-comparators/#data-limits-and-out-of-range-interrupts","title":"Data Limits and Out of Range Interrupts","text":"<p>Channel limits are implemented to minimize power consumption for power supply monitoring. The ADC includes four limit registers, ADC_LIMIT0 to ADC_LIMIT3, that can be used to set a high limit, low limit, and the ADC channel number to apply the limits against. A block diagram of the limit engine for each of the four limit registers is shown in Figure 11-2.</p> <p>Figure 11-2: ADC Limit Engine </p> <p></p> <p>When a measurement is taken on the ADC, the limit engine determines if the channel measured matches one of the channels selected by the limit registers. If it does and the data converted is above or below the high or low limit, an interrupt flag is set, resulting in an ADC interrupt if the interrupt is enabled.</p> <p>Complete the following steps to enable a high and low limit for an ADC input channel using the ADC_LIMIT0 register. Perform these steps after the ADC is configured for measurement, and the configuration is identical for all four limit registers except for the limit register name:</p> <ol> <li>Verify that the ADC is not actively taking a measurement by checking ADC_STATUS.active until it reads 0.</li> <li>Set the ADC_LIMIT0.ch_sel field to the selected channel for the high and low limits.</li> <li>Set the high limit, ADC_LIMIT0.ch_hi_limit, to the selected 10-bit trip point. An ADC measurement greater than this field on the channel selected (ADC_LIMIT0.ch_sel) generates an ADC interrupt when enabled.</li> <li>Set the low limit, ADC_LIMIT0.ch_lo_limit, to the selected 10-bit low trip point. An ADC measurement lower than this field on the channel selected (ADC_LIMIT0.ch_sel) generates an ADC interrupt when enabled.</li> <li>Enable the high limit, the low limit, or both interrupt signals by writing a 1 to ADC_LIMIT0.ch_high_limit_en, ADC_LIMIT0.ch_low_limit_en, or both. Note: Each limit register is independently enabled for high- and low-limit interrupts.</li> <li>Clear the ADC interrupt high and low interrupt flags by writing 1 to ADC_INTR.hi_limit_if and ADC_LIMIT0.lo_limit_if.</li> <li>Enable the high, low, or both interrupts for the ADC by setting ADC_INTR.hi_limit_if to 1, ADC_INTR.lo_limit_ie to 1, or both to 1.</li> <li>If an ADC conversion occurs that is above or below the enabled limits, an ADC_IRQn is generated with the ADC_LIMIT0.adc_high_limit_if, ADC_LIMIT0.adc_low_limit_if, or both set to 1. The ADC_CTRL.ch_sel value indicates the channel that caused the interrupt, and the value of the ADC conversion that is out of bounds is in the ADC_DATA register.</li> </ol>"},{"location":"adc-and-comparators/#power-down-sequence","title":"Power-Down Sequence","text":"<p>Complete the following steps to power down the ADC:</p> <ol> <li>Set ADC_CTRL.pwr to 0, disabling the ADC converter power.</li> <li>ADC_CTRL.refbuf_pwr to 0, disabling the internal reference buffer power.</li> <li>Set ADC_CTRL.clk_en to 0, disabling the ADC internal clock.</li> </ol>"},{"location":"adc-and-comparators/#comparator-operation","title":"Comparator Operation","text":""},{"location":"adc-and-comparators/#comparator-0-usage","title":"Comparator 0 Usage","text":"<p>Comparator 0 is controlled individually using the MCR_CMP_CTRL register. Enable comparator 0 by setting the MCR_CMP_CTRL.en field to 1. Comparator 0s output is readable using the MCR_CMP_CTRL.out. Enable interrupt events for comparator 0 by setting the MCR_CMP_CTRL.int_en field to 1. Interrupts for comparator 0 occur when the output changes to its active state. The active state is controlled using the MCR_CMP_CTRL.pol field. When the output state is active, hardware automatically sets the MCR_CMP_CTRL.if flag to 1. To clear the interrupt flag, write 1 to MCR_CMP_CTRL.if.</p>"},{"location":"adc-and-comparators/#low-power-comparators-1-2-and-3-usage","title":"Low-Power Comparators 1, 2, and 3 Usage","text":"<p>Comparators 1, 2, and 3 are controlled using the low-power comparator, LPCOMPn, registers.</p>"},{"location":"adc-and-comparators/#using-comparator-0-as-a-wake-up-source","title":"Using Comparator 0 as a Wake-Up Source","text":"<p>After configuring Comparator 0, configure it as a wake-up source from SLEEP, LPM, UPM, STANDBY, and BACKUP by performing the following steps:</p> <ol> <li>Enable comparator wake-up events by setting GCR_PM.aincomp_we to 1.</li> <li>Enable comparator 0 as a wake-up source by setting PWRSEQ_LPPWST.comp0 to 1.</li> <li>If desired, provide an interrupt handler for the comparators (LPCMP_IRQn).</li> </ol> <p>After the device exits a low-power mode, determine if the wake-up event resulted from comparator 0 by checking the PWRSEQ_LPPWST.comp0 and the MCR_CMP_CTRL.if. Wake-up events generated by comparator 0 from STANDBY and BACKUP mode result in the PWRSEQ_LPPWST.comp0 bit being set. Write 1 to clear the PWRSEQ_LPPWST.comp0 bit and the MCR_CMP_CTRL.if bit.</p>"},{"location":"adc-and-comparators/#using-low-power-comparators-1-2-and-3-as-a-wake-up-source","title":"Using Low-Power Comparators 1, 2, and 3 as a Wake-Up Source","text":"<p>Wake up from the low-power comparators, LPCMPn, by setting MCR_CMP_CTRL.aincomp0 bit to 1. If any of the three low-power comparators (LPCMPn) cause the device to wake up, the specific comparator\u2019s interrupt flag is set to 1. Inspection of each comparator\u2019s interrupt flag identifies which comparator resulted in the wake-up event. See LPCMPn.if for details.</p> <p>Enable wake-up events from the low-power comparators by setting the GCR_PM.aincomp_we field to 1. If a comparator event occurs and wakes the device from a low-power operating mode, the MCR_CMP_CTRL.aincomp0 field is set to 1. Clear the comparator wake-up status flag by writing 1 to MCR_CMP_CTRL.aincomp0.</p> <p>Note: Comparator 0, if enabled, wakes the device from SLEEP, LPM, UPM, STANDBY, and BACKUP. If enabled, comparators 1, 2, and 3 wake the device from SLEEP, LPM, and UPM.</p>"},{"location":"adc-and-comparators/#adc-registers","title":"ADC Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 11-5: ADC Registers Summary </p> Offset Name Description [0x0000] ADC_CTRL ADC Control Register [0x0004] ADC_STATUS ADC Status Register [0x0008] ADC_DATA ADC Output Data Register [0x000C] ADC_INTR ADC Interrupt Control Register [0x0010] ADC_LIMIT0 ADC Limit 0 Register [0x0014] ADC_LIMIT1 ADC Limit 1 Register [0x0018] ADC_LIMIT2 ADC Limit 2 Register [0x001C] ADC_LIMIT3 ADC Limit 3 Register"},{"location":"adc-and-comparators/#adc-register-details","title":"ADC Register Details","text":"<p>Table 11-6: ADC Control Register </p> ADC Control ADC_CTRL [0x0000] Bits Name Access Reset Description 31:21 - RO 0x050 Reserved 20 data_align R/W 0 ADC Data Alignment        This field selects the alignment of the 16-bit data conversion stored in the ADC_DATA register.                      0: Data is LSB justified in the 16-bit [ADC_DATA](#adc-output-data-register) register. ADC_DATA[15:10] = 0.             1: Data is MSB justified in the 16-bit [ADC_DATA](#adc-output-data-register) register. ADC_DATA[5:0] = 0.          19 - RO 0 Reserved 18:17 adc_divsel R/W 0 External Input Scale        Scales the external inputs AIN0-AIN7. All eight of the external inputs are scaled by the same value.                      0: No scaling.             1: Divide by 2             2: Divide by 3             3: Divide by 4          16:12 ch_sel R/W 0 ADC Channel Select        Selects the active channel for the next ADC conversion.          ch_sel ADC Input Channel Input 0x00 0 AIN0 0x01 1 AIN1 0x02 2 AIN2 0x03 3 AIN3 0x04 4 AIN4 0x05 5 AIN5 0x06 6 AIN6 0x07 7 AIN7 0x08 8 V<sub>COREA</sub> 0x09 9 V<sub>COREB</sub> 0x0A 10 V<sub>RXOUT</sub> 0x0B 11 V<sub>TXOUT</sub> 0x0C 12 V<sub>DDA</sub> 0x0D 13 Reserved 0x0E 14 V<sub>DDIO</sub> /4 0x0F 15 V<sub>DDIOH</sub> /4 0x10 16 V<sub>REGI</sub> /4 0x11 \u2013 0x1F Reserved Reserved 11 clk_en R/W 0 ADC Clock Enable              0: Disabled             1: Enabled          10 - RO 0 Reserved 9 scale R/W 0 ADC Input Scale        This field scales the ADC input by 50 percent.                      0: ADC input is not scaled             1: ADC input is scaled by \u00bd.          Note: See Data Conversion Output Alignment for valid settings for each ADC input. 8 ref_scale R/W 0 Reference Scale         This field scales the internal bandgap reference by 50 percent.                      0: Internal bandgap reference is not scaled.             1: Internal bandgap reference is scaled by \u00bd.          Note: See Data Conversion Output Alignment for valid settings for each ADC input. 7:5 - RO 0 Reserved 4 ref_sel R/W 0 ADC Reference Select              0: Internal bandgap reference is used for the ADC reference             1: VDDA \u00f7 2 is used for the ADC reference          3 refbuf_pwr R/W 0 Reference Buffer Power Enable              0: Disabled             1: Enabled          2 - RO 0 Reserved 1 pwr R/W 0 ADC Power Enable        Set this field to 1 to enable power to the ADC peripheral.                      0: Disabled             1: Enabled          0 start R/W 0 Start ADC Conversion       Write this bit to 1 to start an ADC conversion. When the conversion is complete, the hardware automatically sets this bit to 0, indicating the conversion is complete.                      0: ADC inactive or data conversion complete.             1: Start ADC conversion. The field remains set until the conversion completes.          <p>Table 11-7: ADC Status Register </p> ADC Status ADC_STATUS [0x0004] Bits Name Access Reset Description 31:4 - RO 0x050 Reserved 3 overflow RO 0 ADC Overflow Flag              0: No overflow on the last conversion             1: Overflow on the last conversion          2 afe_pwr_up_active RO 0 ADC Power-Up State        This field is set to 1 when the ADC charge pump is powering up.                      0: AFE is not in power-up delay.             1: AFE is currently in the power-up delay state.          1 - RO 0 Reserved 0 active RO 0 ADC Conversion in Progress              0: ADC is idle             1: ADC conversion is in progress          <p>Table 11-8: ADC Data Register </p> ADC Data ADC_DATA [0x0008] Bits Name Access Reset Description 15:0 data RO 0 ADC Data        This field holds the ADC conversion output data. See Table 11-3 for details.         <p>Table 11-9: ADC Interrupt Control Register </p> ADC Interrupt Control ADC_INTR [0x000C] Bits Name Access Reset Description 31:23 - RO 0 Reserved 22 pending RO 0 ADC Interrupt Pending          0: No ADC interrupt pending.         1: At least one ADC interrupt is pending, and the corresponding interrupt enable bit is set. 21 - RO 0 Reserved 20 overflow_if R/W1C 0 ADC Overflow Interrupt Flag          1: The last conversion resulted in an overflow          19 lo_limit_if R/W1C 0 ADC Low Limit Interrupt Flag      1: The last conversion resulted in a low-limit condition for one of the limit registers.      18 hi_limit_if R/W1C 0 ADC High Limit Interrupt Flag              1: The last conversion resulted in a high-limit condition for one of the limit registers.          17 ref_ready_if R/W1C 0 ADC Reference Ready Interrupt Flag          0: Not Ready         1: Ready.          16 done_if R/W1C 0 ADC Conversion Complete Interrupt Flag          Set by the ADC hardware when an ADC conversion is complete.                  1: ADC conversion complete          15:5 - RO 0 Reserved 4 overflow_ie R/W 0 ADC Overflow Interrupt Enable          0: Disabled.         1: Enables interrupt assertion when the hardware sets ADC_INTR.overflow_if.          3 lo_limit_ie R/W 0 ADC Low Limit Interrupt Enable          0: Disabled.         1: Enables interrupt assertion when the hardware sets the ADC_INTR.lo_limit_if.          2 hi_limit_ie R/W 0 ADC High Limit Interrupt Enable          0: Disabled.         1: Enables interrupt assertion when the hardware sets ADC_INTR.lo_limit_if. 1 ref_ready_ie R/W 0 ADC Reference Ready Interrupt Enable          0: Disabled.         1: Enables interrupt assertion when the hardware sets ADC_INTR.ref_ready_if.          0 done_ie R/W 0 ADC Conversion Complete          0: Disabled.         1: Enables interrupt assertion when the hardware sets ADC_INTR.done_if.          <p>Table 11-10: ADC Limit 0 to 3 Registers </p> ADC Limit 0 ADC_LIMIT0 [0x0010] ADC Limit 1 ADC_LIMIT1 [0x0014] ADC Limit 2 ADC_LIMIT2 [0x0018] ADC Limit 3 ADC_LIMIT3 [0x001C] Bits Name Access Reset Description 31 - RO 0 Reserved 30 ch_hi_limit_en R/W 0 High Limit Monitoring Enable         If set, then an ADC conversion that results in a value greater than the ch_hi_limit field generates an ADC interrupt if the ADC high-limit interrupt is enabled (ADC_INTR.hi_limit_ie = 1).                  1: The high-limit comparison for the ch_sel channel is active.         0: The high-limit comparison is not enabled.          29 ch_lo_limit_en R/W 0 Low Limit Monitoring Enable         If set, then an ADC conversion that results in a value less than the ch_hi_limit field generates an ADC interrupt if the ADC low-limit interrupt is enabled (ADC_INTR.lo_limit_ie = 1).                  1: The low-limit comparison for the ch_sel channel is active.         0: The low-limit comparison is not enabled.          28:24 ch_sel R/W 0 ADC Channel for Limit Monitoring         This field sets the ADC input channel for high- and low-limit thresholds. See ADC_CTRL.ch_sel for valid values for this field. 23:22 - RO 0 Reserved 21:12 ch_hi_limit R/W 0x3FF High Limit Threshold         This field sets the threshold for high-limit comparisons. This field is a 10-bit value compared against any ADC conversion on the channel set in the ch_sel field. ADC conversions greater than this field are over threshold and can result in interrupt assertion if the ch_hi_limit_en field is set.         Valid values for this field are 0x000 to 0x3FF.          11:10 - RO 0 Reserved 9:0 ch_lo_limit R/W 0x3FF Low Limit Threshold         This field sets the threshold for low-limit comparisons. This field is a 10-bit value compared against any ADC conversion on the channel set in the ch_sel field. ADC conversions less than this field are under threshold and can result in interrupt assertion if the ch_lo_limit_en field is set.         Valid values for this field are 0x000 to 0x3FF."},{"location":"adc-and-comparators/#low-power-comparator-registers","title":"Low-Power Comparator Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 11-11: Low-Power Comparator Registers Summary </p> Offset Name Description [0x0000] LPCMP1 Low-Power Comparator 1 Register [0x0004] LPCMP2 Low-Power Comparator 2 Register [0x0004] LPCMP3 Low-Power Comparator 3 Register"},{"location":"adc-and-comparators/#low-power-comparator-register-details","title":"Low-Power Comparator Register Details","text":"<p>Table 11-10: ADC Limit 0 to 3 Registers </p> Low-Power Comparator 1 LPCMP1 [0x0010] Low-Power Comparator 2 LPCMP2 [0x0014] Low-Power Comparator 3 LPCMP3 [0x0018] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 if R/W1C 0 Low-Power Comparator n Interrupt Flag         This field is set to 1 by hardware when the comparator output changes to the active state, as set using the pol field. Write 1 to clear this flag.                      0: No interrupt             1: Interrupt occurred          14 out RO * Low-Power Comparator n Output         This field is the comparator\u2019s output state.                      0: Output low.             1: Output high.          13:7 - 0 * Reserved 6 int_en R/W 0 Low-Power Comparator n Interrupt Enable         Set this field to 1 to enable the interrupt for the low-power comparator.                      0: Disabled             1: Enabled          5 pol R/W 0 Comparator n Interrupt Polarity Select         Set this field to select the polarity of the output change that generates a low-power comparator interrupt.                      0: Interrupt occurs from a transition from low to high.             1: Interrupt occurs from a transition from high to low.          4:1 - RO 0 Reserved 0 en R/W 0 Low-Power Comparator n Enable         Set this field to 1 to enable the comparator.                      0: Disabled             1: Enable"},{"location":"debug-access-port/","title":"Debug Access Port","text":"<p>The device provides an Arm DAP that supports debugging during application development. The DAP enables an external debugger to access the device. The DAP is a standard Arm CoreSight\u2122 serial wire debug port and uses a two-pin serial interface (SWDCLK and SWDIO) to communicate.</p>"},{"location":"debug-access-port/#instances","title":"Instances","text":"<p>The DAP interface communicates through the serial wire debug (SWD), shown in Table 8-1.</p> <p>Table 8-1: MAX78000 DAP Instances </p> Instance Pin Alternate Function SWD Signal DAP P0.28 AF1 SWDIO P0.29 AF1 SWDCLK"},{"location":"debug-access-port/#access-control","title":"Access Control","text":""},{"location":"debug-access-port/#factory-disabled-dap","title":"Factory Disabled DAP","text":"<p>Device versions that do not provide a DAP interface have GCR_SYSST.icelock = 1 set at the factory, permanently disabling the DAP interface. No software action is needed to disable the DAP on these devices.</p>"},{"location":"debug-access-port/#software-accessible-dap","title":"Software Accessible DAP","text":"<p>Device versions that provide a DAP (GCR_SYSST.icelock = 0) always have their interface(s) enabled and running unless the software explicitly sets the GCR_SYSST.swd_dis field to 1. The read-only field GCR_SYSST.icelock is cleared to 0, and the software has read and write access to the GCR_SYSST.swd_dis field. The GCR_SYSST.swd_dis field resets to 0 after every POR to allow access to the DAP during development.</p> <p>The software can disable the DAP by setting the GCR_SYSST.swd_dis field to 1. The only practical application for disabling the DAP is to release the interface pins to operate as standard GPIO or in one of the supported alternate function modes in a development environment. Customers can use device versions with the DAP enabled for development but should only use device versions with the factory disabled DAP in a final product.</p>"},{"location":"debug-access-port/#pin-configuration","title":"Pin Configuration","text":"<p>SWD signals in GPIO and alternate function matrices determine which GPIO pins are associated with a signal. It is unnecessary to configure a pin for an alternate function to use the DAP following a POR.</p> <p>By default, the pin associated with the bidirectional SWDIO signal is configured as a GPIO high-impedance input after any POR. While the DAP is in use, a pullup resistor should be connected to the SWDIO pin, as shown in Table 8-1. The pullup ensures the signal is in a known state when control of the SWDIO pin is transferred between the host and target. The pullup resistor should be removed if the associated pin is used as a GPIO to avoid unnecessary current consumption.</p>"},{"location":"flash-controller/","title":"Flash Controller (FLC)","text":"<p>The MAX78000 flash controller manages read, write, and erase accesses to the internal flash and provides the following features:</p> <ul> <li>Up to 512KB total internal flash memory</li> <li>64 pages</li> <li>8,192 bytes per page</li> <li>2,048 words by 128 bits per page</li> <li>128-bit data reads and writes</li> <li>Page erase and mass erase support</li> <li>Write protection</li> </ul>"},{"location":"flash-controller/#instances","title":"Instances","text":"<p>The device includes one instance of the FLC. The 512KB of internal flash memory is programmable through the serial wire debug interface (in-system) or directly with software (in-application).</p> <p>The flash is organized as an array of 2,048 words by 128 bits, or 8,192 bytes per page. Table 7-1 shows the page start address and page end address of the internal flash memory.</p> <p>Table 7-1: MAX78000 Internal Flash Memory Organization </p> Instance Page Number Size (per page) Start Address End Address FLC0 1 8,192 Bytes 0x1000 0000 0x1000 1FFF 2 8,192 Bytes 0x1000 2000 0x1000 3FFF 3 8,192 Bytes 0x1000 4000 0x1000 5FFF 4 8,192 Bytes 0x1000 6000 0x1000 7FFF ... ... ... ... 63 8,192 Bytes 0x1007 C000 0x1007 DFFF 64 8,192 Bytes 0x1007 E000 0x1007 FFFF"},{"location":"flash-controller/#usage","title":"Usage","text":"<p>The flash controller manages write and erase operations for internal flash memory and provides a lock mechanism to prevent unintentional writes to the internal flash. In-application and in-system programming, page erase, and mass erase operations are supported.</p>"},{"location":"flash-controller/#clock-configuration","title":"Clock Configuration","text":"<p>The FLC requires a 1MHz internal clock. See Oscillator Sources for details. Use the FLC clock divisor to generate \\(f_{\\text{FLCn_CLK}} = 1MHz\\), as shown in Equation 7-1. If using the IPO as the system clock, the FLC_CLKDIV.clkdiv should be set to 100 (0x64).</p> <p>Equation 7-1: FLC Clock Frequency </p> \\[ f_{\\text{FLCn_CLK}} = \\frac{f_{\\text{SYS_CLK}}}{\\text{FLCn_CLKDIV} \\cdot \\text{clkdiv}} = 1 \\, \\text{MHz} \\]"},{"location":"flash-controller/#lock-protection","title":"Lock Protection","text":"<p>A locking mechanism prevents accidental memory writes and erases. All write and erase operations require the FLC_CTRL.unlock field to be set to 2 before starting the operation. Writing any other value to the FLC_CTRL.unlock field results in:</p> <ol> <li>The flash instance remaining locked, or</li> <li>The flash instance is locked from the unlocked state.</li> </ol> <p>Note: If a write, page erase, or mass erase operation is started, and the unlock code was not set to 2, the flash controller hardware sets the access fail flag, FLC_INTR.af, to indicate an access violation occurred.</p>"},{"location":"flash-controller/#flash-write-width","title":"Flash Write Width","text":"<p>The FLC supports write widths of 128-bits only. The target address bits FLC_ADDR[3:0] are ignored, resulting in 128-bit address alignment.</p> <p>Table 7-2: Valid Addresses Flash Writes </p> FLC_ADDR[31:0] Bit Number 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 128-bit Write 1 0 0 0 0 0 0 0 0 0 0 0 x x x x x x x x x x x x x x x x 0 0 0 0"},{"location":"flash-controller/#flash-write","title":"Flash Write","text":"<p>Writes to a flash address are only successful if the target address is already in its erased state. Perform the following steps to write to a flash memory address:</p> <ol> <li>If desired, enable the flash controller interrupts by setting the FLC_INTR.afie and FLC_INTR.doneie bits.</li> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure the FLC_CLKDIV.clkdiv field to achieve a 1MHz frequency based on the selected SYS_CLK frequency.</li> <li>Set the FLC_ADDR register to a valid target address. See Table 7-2 for details.</li> <li> <p>Set FLC_DATA3, FLC_DATA2, FLC_DATA1, and FLC_DATA0 to the data to write.</p> <p>a. FLC_DATA3 is the most significant word, and FLC_DATA0 is the least significant word.</p> <p>i. Each word of the data to write follows the little-endian format where the least significant byte of the word is stored at the lowest-numbered byte, and the most significant byte is stored at the highest-numbered byte.</p> </li> <li> <p>Set the FLC_CTRL.unlock field to 2 to unlock the flash.</p> </li> <li> <p>Set the FLC_CTRL.wr field to 1.</p> <p>a. The hardware automatically clears this field when the write operation is complete.</p> </li> <li> <p>The FLC_INTR.done field is set to 1 by hardware when the write completes.</p> <p>a. An interrupt is generated if the FLC_INTR.doneie field is set to 1.</p> </li> <li> <p>If an error occurred, the FLC_INTR.af field is set to 1 by hardware. An interrupt is generated if the FLC_INTR.afie field is set to 1.</p> </li> <li>Set the FLC_CTRL.unlock field to any value other than 2 to re-lock the flash.</li> </ol> <p>Note: Code execution can occur within the same flash instance as targeted programming.</p>"},{"location":"flash-controller/#page-erase","title":"Page Erase","text":"<p>CAUTION: Care must be taken not to erase the page from which the application software is currently executing.</p> <p>Perform the following to erase a page of a flash memory instance:</p> <ol> <li>If desired, enable flash controller interrupts by setting the FLC_INTR.afie and FLC_INTR.doneie bits.</li> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure FLC_CLKDIV.clkdiv to match the SYS_CLK frequency.</li> <li>Set the FLC_ADDR register to an address within the target page to be erased. FLC_ADDR[12:0] is ignored by the FLC to ensure the address is page-aligned.</li> <li>Set FLC_CTRL.unlock to 2 to unlock the flash instance.</li> <li>Set FLC_CTRL.erase_code to 0x55 for page erase.</li> <li>Set FLC_CTRL.pge to 1 to start the page erase operation.</li> <li>The FLC_CTRL.pend bit is set by the flash controller while the page erase is in progress, and the FLC_CTRL.pge and FLC_CTRL.pend are cleared by the flash controller when the page erase is complete.</li> <li>FLC_INTR.done is set by hardware when the page erase completes, and if an error occurred, the FLC_INTR.af flag is set. These bits generate a flash interrupt if the interrupt enable bits are set.</li> <li>Set FLC_CTRL.unlock to any value other than 2 to re-lock the flash instance.</li> </ol>"},{"location":"flash-controller/#mass-erase","title":"Mass Erase","text":"<p>CAUTION: Care must be taken not to erase the flash from which application software is currently executing.</p> <p>Mass erase clears the internal flash memory on an instance basis. Perform the following steps to mass erase a single flash memory instance:</p> <ol> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure FLC_CLKDIV.clkdiv to match the SYS_CLK frequency.</li> <li>Set FLC_CTRL.unlock to 2 to unlock the internal flash.</li> <li>Set FLC_CTRL.erase_code to 0xAA for mass erase.</li> <li>Set FLC_CTRL.me to 1 to start the mass erase operation.</li> <li>The FLC_CTRL.pend bit is set by the flash controller while the mass erase is in progress, and the FLC_CTRL.me and FLC_CTRL.pend are cleared by the flash controller when the mass erase is complete.</li> <li>FLC_INTR.done is set by the flash controller when the mass erase completes, and if an error occurred, the FLC_INTR.af flag is set. These bits generate a flash interrupt if the interrupt enable bits are set.</li> <li>Set FLC_CTRL.unlock to any value other than 2 to re-lock the flash instance.</li> </ol>"},{"location":"flash-controller/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Note: The FLC registers are reset only on a POR. System reset, soft reset, and peripheral reset do not affect the FLC register values.</p> <p>Table 7-3: Flash Controller Register Summary </p> Offset Register Name Access Description [0x0000] FLC_ADDR R/W Flash Controller Address Pointer Register [0x0004] FLC_CLKDIV R/W Flash Controller Clock Divisor Register [0x0008] FLC_CTRL R/W Flash Controller Control Register [0x0024] FLC_INTR R/W Flash Controller Interrupt Register [0x0030] FLC_DATA0 R/W Flash Controller Data Register 0 [0x0034] FLC_DATA1 R/W Flash Controller Data Register 1 [0x0038] FLC_DATA2 R/W Flash Controller Data Register 2 [0x003C] FLC_DATA3 R/W Flash Controller Data Register 3 [0x0040] FLC_ACTRL R/W Flash Controller Access Control Register [0x0080] FLC_WELR0 R/W Flash Write/Erase Lock 0 Register [0x0088] FLC_WELR1 R/W Flash Write/Erase Lock 1 Register [0x0090] FLC_RLR0 R/W Flash Read Lock 0 Register [0x0098] FLC_RLR1 R/W Flash Read Lock 1 Register"},{"location":"flash-controller/#register-details","title":"Register Details","text":"<p>Table 7-4: Flash Controller Address Pointer Register </p> Flash Controller Address Pointer FLC_ADDR [0x0000] Bits Name Access Reset Description 31:0 addr R/W 0x1000 0000 Flash AddressThis field contains the target address for a write operation. A valid internal flash memory address is required for all write operations. <p>Table 7-5: Flash Controller Clock Divisor Register </p> Flash Controller Clock Divisor FLC_CLKDIV [0x0004] Bits Name Access Reset Description 31:8 - RO - Reserved 7:0 clkdiv R/W 0x64 Flash Controller Clock DivisorThe APB clock is divided by the value in this field to generate the FLCn peripheral clock, f<sub>FLC_CLK</sub>. The FLC peripheral clock must equal 1MHz. The default on POR, system reset, and watchdog reset is 100, resulting in f<sub>FLC_CLK</sub> = 1MHz when IPO is the system oscillator. The FLC peripheral clock is only used during erase and program functions and not during read functions. See Clock Configuration for additional details. <p>Table 7-6: Flash Controller Control Register </p> Flash Controller Control FLC_CTRL [0x0008] Bits Name Access Reset Description 31:28 unlock R/W 0 Flash UnlockWrite the unlock code, 2, before any flash write or erase operation to unlock the flash. Writing any other value to this field locks the internal flash.          2: Flash unlock code         27:26 - RO - Reserved 25 lve R/W 0 Low Voltage EnableSet this field to 1 to enable low voltage operation for the flash memory.                      0: Low voltage operation disabled (Default).             1: Low voltage operation enabled.          24 pend RO 0 Flash Busy FlagWhen this field is set, writes to all flash registers, except the FLC_INTR register, are ignored by the flash controller. This bit is cleared by hardware once the flash becomes accessible.         <p>Note:If the flash controller is busy (FLC_CTRL.pend = 1), reads, writes, and erase operations are not allowed and result in an access failure (FLC_INTR.af = 1).</p>              0: Low voltage operation disabled (Default).             1: Low voltage operation enabled.          23:16 - RO 0 Reserved 15:8 erase_code R/W 0 Erase CodeBefore an erase operation, this field must be set to 0x55 for a page erase or 0xAA for a mass erase. The flash must be unlocked before setting the erase code. This field is automatically cleared after the erase operation is complete.                      0x00: Erase disabled.             0x55: Page erase code.             0xAA: Mass erase code.          7:3 - RO 0 Reserved 2 pge R/W1 0 Page EraseWrite a 1 to this field to initiate a page erase at the address in FLC_ADDR.addr. The flash must be unlocked before attempting a page erase. See FLC_CTRL.unlock for details.         <p>The flash controller hardware clears this bit when a page erase operation is complete.</p>          0: Normal operation.         1: Write a 1 to initiate a page erase. If this field reads 1, a page erase operation is in progress.          1 me R/W1 0 Mass EraseWrite a 1 to this field to initiate a mass erase of the internal flash memory. The flash must be unlocked before attempting a mass erase. See FLC_CTRL.unlock for details. The flash controller hardware clears this bit when the mass erase operation completes.                      0: Normal operation.             1: Initiate mass erase.          0 wr R/W1O 0 WriteIf this field reads 0, no write operation is pending for the flash. To initiate a write operation, set this bit to 1, and the flash controller writes to the address set in the FLC_ADDR register.                      0: Normal operation.             1: Write 1 to initiate a write operation. If this field reads 1, a write operation is in progress.          <p>Note: This field is protected and cannot be set to 0 by application software.</p> <p>Table 7-7: Flash Controller Interrupt Register </p> Flash Controller Interrupt FLC_INTR [0x0024] Bits Name Access Reset Description 31:10 - RO 0 Reserved 9 afie R/W 0 Flash Access Fail Interrupt EnableSet this bit to 1 to enable interrupts on flash access failures.                  0: Disabled         1: Enabled          8 doneie R/W 0 Flash Operation Complete Interrupt EnableSet this bit to 1 to enable interrupts on flash operations complete.                  0: Disabled         1: Enabled          7:2 - RO 0 Reserved 1 af R/W0C 0 Flash Access Fail Interrupt FlagThis bit is set when an attempt is made to write or erase the flash while the flash is busy or locked. Only hardware can set this bit to 1. Writing a 1 to this bit has no effect. This bit is cleared by writing a 0.           0: No access failure has occurred.         1: Access failure occurred.          0 done R/W0C 0 Flash Operation Complete Interrupt Flag        This flag is automatically set by hardware after a flash write or erase operation completes.           0: Operation not complete or not in process.         1: Flash operation complete.          <p>Table7-8: Flash Controller Data 0 Register </p> Flash Controller Data 0 FLC_DATA0 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 0        Flash data for bits 31:0.         <p>Table 7-9: Flash Controller Data Register 1 </p> Flash Controller Data 1 FLC_DATA1 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 1        Flash data for bits 63:32.         <p>Table 7-10: Flash Controller Data Register 2 </p> Flash Controller Data 2 FLC_DATA2 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 2        Flash data for bits 95:64.         <p>Table 7-11: Flash Controller Data Register 3 </p> Flash Controller Data 3 FLC_DATA3 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 3        Flash data for bits 127:96.         <p>Table 7-12: Flash Controller Access Control Register </p> Flash Controller Access Control FLC_ACTRL [0x0040] Bits Name Access Reset Description 31:0 actrl R/W 0 Access Control        When this register is written with the access control sequence, the information block can be accessed. See Information Block Flash Memory for details.         <p>Table 7-13: Flash Write/Lock 0 Register </p> Flash Write/Lock 0 FLC_WELR0 [0x0080] Bits Name Access Reset Description 31:0 welr0 R/W1C 0xFFFF FFFF Flash Write/Lock Bit        Each bit in this register maps to a page of the internal flash. FLC_WELR0[0] maps to page 0 of the flash, and FLC_WELR0[31] maps to page 31. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately locked. The page protection can only be unlocked by an external reset or a POR.           0: The corresponding page of flash is write protected.         1: The corresponding page of flash is not write protected.          <p>Table 7-14: Flash Write/Lock 1 Register </p> Flash Write/Lock 1 FLC_WELR1 [0x0088] Bits Name Access Reset Description 31:0 welr1 R/W1C 0xFFFF FFFF Flash Write/Lock Bit        Each bit in this register maps to a page of the internal flash. FLC_WELR1[0] maps to page 32 of the flash, and FLC_WELR1[31] maps to page 63 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately locked. The page protection can only be unlocked by an external reset or a POR.           0: The corresponding flash page is write protected.         1: The corresponding flash page is not write protected.          <p>Table 7-15: Flash Read Lock 0 Register </p> Flash Read Lock 0 FLC_RLR0 [0x0090] Bits Name Access Reset Description 31:0 rlr0 R/W1C 0xFFFF FFFF Read Lock Bit        Each bit in this register maps to a page of the internal flash. FLC_RLR0[0] maps to page 0 of the flash, and FLC_RLR0[31] maps to page 31 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately read protected. The page\u2019s read protection can only be unlocked by an external reset or a POR.           0: The corresponding flash page is read protected.         1: The corresponding flash page is not read protected.          <p>Table 7-16: Flash Read Lock 1 Register </p> Flash Read Lock 1 FLC_RLR1 [0x0098] Bits Name Access Reset Description 31:0 rlr1 R/W1C 0xFFFF FFFF Read Lock Bit        Each bit in this register maps to a page of the internal flash. FLC_RLR1[0] maps to page 32 of the flash, and FLC_RLR1[31] maps to page 63 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately read protected. The page\u2019s read protection can only be unlocked by an external reset or a POR.           0: The corresponding flash page is read protected.          1: The corresponding flash page is not read protected."},{"location":"gpio/","title":"General-Purpose I/O and Alternate Function Pins (GPIO)","text":"<p>General-purpose I/O (GPIO) pins can be individually configured to operate in a digital I/O mode or in an alternate function (AF) mode, which maps a signal associated with an enabled peripheral to that GPIO. Each GPIO supports dynamic switching between I/O mode and alternate function mode. Configuring a pin for an alternate function supersedes its use as a digital I/O; however, the state of the GPIO is still readable through the GPIOn_IN register.</p> <p>The electrical characteristics of a GPIO pin are identical whether the pin is configured as an I/O or as an alternate function, except where explicitly noted in the data sheet electrical characteristics tables.</p> <p>The GPIO are divided logically into ports of 32 pins. Package variants may not implement all pins of a specific 32-bit GPIO port.</p> <p>Each port pin has an interrupt function that can be independently enabled and configured as a level-sensitive or edge-sensitive interrupt. All GPIOs of a given port share the same interrupt vector as detailed in GPIO Interrupt Handling.</p> <p>Note: The register set used to control the GPIO are identical across multiple Analog Devices microcontrollers; however, the behavior of several registers varies depending on the specific device. The behavior of the registers should not be assumed to be the same from one device to a different device. Specifically the registers GPIOn_PADCTRL0, GPIOn_PADCTRL1, GPIOn_HYSEN, GPIOn_SRSEL, GPIOn_DS0, GPIOn_DS1, and GPIOn_VSSEL are device-dependent in their usage. GPIO3 is controlled differently and has different features than the other GPIO ports in the MAX78000. See MCR_GPIO3_CTRL for details on using GPIO3.</p> <p>The features for each GPIO pin include:</p> <ul> <li>Full CMOS outputs with configurable drive strength settings</li> <li>Input modes/options:<ul> <li>High impedance</li> <li>Weak pullup/pulldown</li> <li>Strong pullup/pulldown</li> </ul> </li> <li>Output data can be from the GPIOn_OUT register or an enabled peripheral.</li> <li>Input data can be read from the GPIOn_IN input register or the enabled peripheral.</li> <li>Bit set and clear registers for efficient bit-wise write access to the pins and configuration registers.</li> <li>Wake from low-power modes using edge-triggered inputs.</li> <li>Selectable GPIO voltage supply for GPIO0, GPIO1, and GPIO2:<ul> <li>V<sub>DDIO</sub></li> <li><p>V<sub>DDIOH</sub> <li>Selectable interrupt events:<ul> <li>Level triggered low</li> <li>Level triggered high</li> <li>Edge triggered rising edge.</li> <li>Edge triggered falling edge.</li> <li>Edge triggered rising and falling edge.</li> </ul> </li> <li>All GPIO pins default to input mode with weak-pullup during power-on-reset events.</li>"},{"location":"gpio/#instances","title":"Instances","text":"<p>Table 6\u20111 shows the number of GPIO available on each IC package. Some packages and part numbers do not implement all bits of a 32-bit GPIO port. Register fields corresponding to unimplemented GPIO contain indeterminate values and should not be modified.</p> <p>Table6-1: MAX78000 GPIO Pin Count </p> Package GPIO PINS 81-CTBGA GPIO0[30:0] 31 GPIO1[9:0] 10 GPIO2[7:0] 8 GPIO3[1:0]<sup>+</sup> 2 <p>Note: See Power Sequencer Registers (PWRSEQ) for details on using GPIO3.</p> <p>Note: Refer to the device data sheet for descriptions of each GPIO port pin's alternate functions.</p>"},{"location":"gpio/#configuration","title":"Configuration","text":"<p>Each device pin is individually configurable as a GPIO or an alternate function. The correct alternate function setting must be selected for each pin of a given multi-pin peripheral for proper operation.</p>"},{"location":"gpio/#power-on-reset-configuration","title":"Power-On-Reset Configuration","text":"<p>All I/O default to GPIO mode during a POR event as high impedance inputs except the SWDIO and SWDCLK pins. After a POR, the SWD is enabled by default with AF1 selected by hardware. See the Bootloader chapter for exceptions.</p> <p>Following a POR event, all GPIO, except device pins that have the SWDIO and SWDCLK function, are configured with the following default settings:</p> <ul> <li>GPIO mode enabled<ul> <li>GPIOn_EN0.en[pin]\u00a0=\u00a01</li> <li>GPIOn_EN1.en[pin] =\u00a00</li> <li>GPIOn_EN2.en[pin]\u00a0=\u00a00</li> </ul> </li> <li>Pullup/pulldown disabled, I/O in Hi-Z mode<ul> <li>GPIOn_PADCTRL0.mode[pin] =\u00a00</li> <li>GPIOn_PADCTRL1.mode[pin]</li> </ul> </li> <li>Output mode disabled<ul> <li>GPIOn_OUTEN.en[pin]\u00a0=\u00a00</li> </ul> </li> <li>Interrupt disabled<ul> <li>GPIOn_INTEN.en[pin]\u00a0=\u00a00</li> </ul> </li> </ul>"},{"location":"gpio/#serial-wire-debug-configuration","title":"Serial Wire Debug Configuration","text":"<p>Perform the following steps to configure the SWDIO and SWDCLK device pins for SWD mode:</p> <ol> <li> <p>Set the device pin P0.28 for AF1 mode:</p> <p>a. GPIOn_EN0.config[28] = 0</p> <p>b. GPIOn_EN1.config[28] = 0</p> <p>c. GPIOn_EN2.config[28] = 0</p> </li> <li> <p>Set device pin P0.29 for AF1 mode:</p> <p>a. GPIOn_EN0.config[29] = 0</p> <p>b. GPIOn_EN1.config[29] = 0</p> <p>c. GPIOn_EN2.config[29] = 0</p> </li> </ol> <p>Note: To use the SWD pins in GPIO mode, set the desired GPIO pins for SWD AF and disable the SWD (GCR_SYSCTRL.swd_dis\u00a0=\u00a01).</p>"},{"location":"gpio/#pin-function-configuration","title":"Pin Function Configuration","text":"<p>Table 6\u20112 depicts the bit settings for the GPIOn_EN0, GPIOn_EN1, and GPIOn_EN2 registers to configure a GPIO port pin's function. Each of the bits within these registers represents the configuration of a single pin on the GPIO port. For example, GPIOn_EN0.config[25], GPIOn_EN1.config[25], and GPIOn_EN2.config[25] all represent configuration for device pin P0.25. See Table 6\u20115 for a detailed example of how each of these bits applies to each GPIO device pin.</p> <p>Table 6-2: MAX78000 GPIO Pin Function Configuration </p> MODE GPIOn_EN0.config[pin] GPIOn_EN1.config[pin] GPIOn_EN2.config[pin] AF1 0 0 0 AF2 0 1 0 I/O (transition to AF1) 1 0 0 I/O (transition to AF2) 1 1 0"},{"location":"gpio/#input-mode-configuration","title":"Input Mode Configuration","text":"<p>Table 6\u20113 depicts the bit settings for the digital I/O input mode. Each of the bits within these registers represents the configuration of a single pin on the GPIO port. For example, GPIOn_PADCTRL1.config[25], GPIOn_PADCTRL0.config[25], GPIO0_PS.pull_sel[25], and GPIO0_VSSEL.v_sel[25] all represent configuration for device pin P0.25. See Table 6\u20118 for a detailed example of how each of these bits applies to each GPIO device pin. Refer to the device data sheet for details of specific electrical characteristics.</p> <p>Table 6-3: MAX78000 Input Mode Configuration </p> Input Mode Mode Select Pullup/Pulldown Strength Power Supply GPIOn_PADCTRL1.config[pin] GPIOn_PADCTRL0.config[pin] GPIOn_PS.pull_sel[pin] GPIOn_VSSEL.v_sel[pin] High-impedance 0 0 N/A N/A Weak Pullup to V<sub>DDIO</sub> (1M\u03a9) 0 1 0 0 Strong Pullup to V<sub>DDIO</sub> (25K\u03a9) 0 1 1 0 Weak Pulldown to V<sub>DDIOH</sub> (1M\u03a9) 1 0 0 1 Strong Pulldown to V<sub>DDIOH</sub> (25K\u03a9) 1 0 1 1 Reserved 1 1 N/A N/A"},{"location":"gpio/#output-mode-configuration","title":"Output Mode Configuration","text":"<p>Table 6\u20114 shows the configuration options for digital I/O in output mode. Each of the bits within these registers represents the configuration of a single pin on the GPIO port. For example, GPIO2_DS0.config[25], GPIO2_DS1.config[25], and GPIO2_VSSEL.v_sel[25] all represent configuration for GPIO port 2 pin 25 (device pin P0.25). See Table 6\u20118 for a detailed example of how each of these bits applies to each GPIO device pin. Refer to the device data sheet for details of specific electrical characteristics.</p> <p>Table 6-4: MAX78000 Output Mode Configuration </p> Input Mode Drive Strength Power Supply GPIOn_DS1.config[pin] GPIOn_DS0.config[pin] GPIOn_VSSEL.v_sel[pin] Output Drive Strength 0, V<sub>DDIO</sub> Supply 0 0 0 Output Drive Strength 1, V<sub>DDIO</sub> Supply 0 1 0 Output Drive Strength 2, V<sub>DDIO</sub> Supply 1 0 0 Output Drive Strength 3, V<sub>DDIO</sub> Supply 1 1 0 Output Drive Strength 0, V<sub>DDIOH</sub> Supply 0 0 1 Output Drive Strength 1, V<sub>DDIOH</sub> Supply 0 1 1 Output Drive Strength 2, V<sub>DDIOH</sub> Supply 1 0 1 Output Drive Strength 3, V<sub>DDIOH</sub> Supply 1 1 1 <p>Each GPIO port is assigned a dedicated interrupt vector, as shown in Table 6\u20119.</p>"},{"location":"gpio/#reference-tables","title":"Reference Tables","text":"<p>The tables in this section provide example references for register bit assignment to configure a device's GPIO port 0 pins. Other GPIO port pins are configured similarly using the respective GPIO1 or GPIO2 registers.</p> <p>Table 6-5: MAX78000 GPIO0 Alternate Function Configuration Reference </p> Device Pin Alternate Function Configuration Bits P0.0 GPIO0_EN0.config[0] GPIO0_EN1.config[0] GPIO0_EN2.config[0] P0.1 GPIO0_EN0.config[1] GPIO0_EN1.config[1] GPIO0_EN2.config[1] \u2026 \u2026 \u2026 \u2026 P0.30 GPIO0_EN0.config[30] GPIO0_EN1.config[30] GPIO0_EN2.config[30] P0.31 GPIO0_EN0.config[31] GPIO0_EN1.config[31] GPIO0_EN2.config[31] <p>Table 6-6: MAX78000 GPIO0 Output/Input Configuration Reference </p> Device Pin GPIO Output Enable GPIO Output Write GPIO Input Enable GPIO Input Read P0.0 GPIO0_OUTEN.en[0] GPIO0_OUT.level[0] GPIO0_INEN.en[0] GPIO0_IN.level[0] P0.1 GPIO0_OUTEN.en[1] GPIO0_OUT.level[1] GPIO0_INEN.en[1] GPIO0_IN.level[1] \u2026 \u2026 \u2026 \u2026 \u2026 P0.30 GPIO0_OUTEN.en[30] GPIO0_OUT.level[30] GPIO0_INEN.en[30] GPIO0_IN.level[30] P0.31 GPIO0_OUTEN.en[31] GPIO0_OUT.level[31] GPIO0_INEN.en[31] GPIO0_IN.level[31] <p>Table 6-7: MAX78000 GPIO0 Interrupt Configuration Reference </p> Device Pin Enable Status Dual Edge Polarity Trigger Wakeup P0.0 GPIO0_INTEN.en[0] GPIO0_INTFL.config[0] GPIO0_DUALEDGE.dualedge[0] GPIO0_INTPOL.pol[0] GPIO0_INTMODE.gpio_intmode[0] GPIO0_WKEN.en[0] P0.1 GPIO0_INTEN.en[1] GPIO0_INTFL.config[1] GPIO0_DUALEDGE.config[1] GPIO0_INTPOL.pol[1] GPIO0_INTMODE.gpio_intmode[1] GPIO0_WKEN.en[1] \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 P0.30 GPIO0_INTEN.en[30] GPIO0_INTFL.int[30] GPIO0_DUALEDGE.gpio_dualedge[30] GPIO0_INTPOL.pol[30] GPIO0_INTMODE.gpio_intmode[30] GPIO0_WKEN.en[30] P0.31 GPIO0_INTEN.en[31] GPIO0_INTFL.int[31] GPIO0_DUALEDGE.gpio_dualedge[31] GPIO0_INTPOL.pol[31] GPIO0_INTMODE.gpio_intmode[31] GPIO0_WKEN.en[31] <p>Table 6-8: MAX78000 GPIO0 Pullup/Pulldown/Drive Strength/Voltage Configuration Reference </p> Device Pin Pullup/Pulldown/Strength Select Drive Strength Voltage P0.0 GPIO0_PADCTRL0.config[0] GPIO0_PADCTRL1.config[0] GPIO0_PS.pull_sel[0] GPIO0_DS0.config[0] GPIO0_DS1.config[0] GPIOn_VSSEL.v_sel[0] P0.1 GPIO0_PADCTRL0.config[1] GPIO0_PADCTRL1.config[1] GPIO0_PS.pull_sel[1] GPIO0_DS0.config[1] GPIO0_DS1.config[1] GPIOn_VSSEL.v_sel[1] \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 P0.30 GPIO0_PADCTRL0.config[30] GPIO0_PADCTRL1.config[30] GPIO0_PS.pull_sel[30] GPIO0_DS0.config[30] GPIO0_DS1.config[30] GPIOn_VSSEL.v_sel[30] P0.31 GPIO0_PADCTRL0.config[31] GPIO0_PADCTRL1.config[31] GPIO0_PS.pull_sel[31] GPIO0_DS0.config[31] GPIO0_DS1.config[31] GPIOn_VSSEL.v_sel[31]"},{"location":"gpio/#usage","title":"Usage","text":""},{"location":"gpio/#reset-state","title":"Reset State","text":"<p>During a power-on-reset event, each GPIO is reset to the default input mode with the weak pullup resistor enabled as follows:</p> <ol> <li>The GPIO configuration enable bits shown in Table 6\u20112 are set to I/O (transition to AF1) mode.</li> <li>Input mode is enabled (GPIOn_INTEN.en[pin] = 1).</li> <li>High impedance mode enabled (GPIOn_PADCTRL1.config[pin] = 0, GPIOn_PADCTRL0.config[pin] = 0), pullup and pulldown disabled.</li> <li>Output mode disabled (GPIOn_OUTEN.en[pin] = 0).</li> <li>Interrupt disabled (GPIOn_INTEN.en[pin] = 0).</li> </ol>"},{"location":"gpio/#input-mode-configuration_1","title":"Input Mode Configuration","text":"<p>Perform the following steps to configure one or more pins for input mode:</p> <ol> <li>Set the GPIO Configuration Enable bits shown in Table 6\u20112 to any one of the I/O mode settings.</li> <li>Configure the electrical characteristics of the pin as desired, as shown in Table 6\u20113.</li> <li>Enable the input buffer connected to the GPIO pin by setting GPIOn_INTEN.en[pin] to 1.</li> <li>Read the input state of the pin using the GPIOn_IN.level[pin] field.</li> </ol>"},{"location":"gpio/#output-mode-configuration_1","title":"Output Mode Configuration","text":"<p>Perform the following steps to configure a pin for output mode:</p> <ol> <li>Set the GPIO Configuration Enable bits shown in Table 6\u20112 to any one of the I/O mode settings.</li> <li>Configure the electrical characteristics of the pin as desired, as shown in Table 6\u20114.</li> <li>Set the output logic high or logic low using the GPIOn_OUT.level[pin] bit.</li> <li>Enable the output buffer for the pin by setting GPIOn_OUTEN.en[pin] to 1.</li> </ol>"},{"location":"gpio/#alternate-function-configuration","title":"Alternate Function Configuration","text":"<p>Most GPIO support one or more alternate functions selected with the GPIO configuration enable bits shown in Table 6\u20112. The bits that select the AF must only be changed while the pin is in one of the I/O modes (GPIOn_EN0 = 1). The specific I/O mode must match the desired AF. For example, if a transition to AF1 is desired, first select the setting corresponding to I/O (transition to AF1). Then enable the desired mode by selecting the AF1 mode.</p> <ol> <li>Set the GPIO configuration enable bits shown in Table 6\u20112 to the I/O mode corresponding to the desired new AF setting. For example, select \"I/O (transition to AF1)\" if switching to AF1. Switching between different I/O mode settings does not affect the state or electrical characteristics of the pin.</li> <li>Configure the electrical characteristics of the pin. See Table 6\u20113 if the assigned alternate function uses the pin as an input. See Table 6\u20114 if the assigned alternate function uses the pin as an output.</li> <li>Set the GPIO Configuration Enable bits shown in Table 6\u20112 to the desired alternate function.</li> </ol>"},{"location":"gpio/#configuring-gpio-external-interrupts","title":"Configuring GPIO (External) Interrupts","text":"<p>Each GPIO pin supports external interrupt events when the GPIO is configured for I/O mode and the input mode is enabled. If the GPIO is configured for an alternate peripheral function, the interrupts are peripheral-controlled.</p> <p>GPIO interrupts can be individually enabled and configured as an edge or level triggered independently on a pin-by-pin basis. The edge trigger can be a rising, falling, or both transitions.</p> <p>Each GPIO pin has a dedicated status bit in its corresponding GPIOn_INTFL register. A GPIO interrupt occurs when the status bit transitions from 0 to 1 if the corresponding bit is set in the corresponding GPIOn_INTEN register. Note that the interrupt status bit is always set when the current interrupt configuration event occurs, but an interrupt is only generated if explicitly enabled.</p> <p>The following procedure details the steps for enabling ACTIVE mode interrupt events for a GPIO pin:</p> <ol> <li>Disable interrupts by setting the GPIOn_INTEN.en[pin] field to 0. Disabling interrupts prevents any new interrupts on the pin from triggering but does not clear previously triggered (pending) interrupts. The application can disable all interrupts for a GPIO port by writing 0 to the GPIOn_INEN register. To maintain previously enabled interrupts, read the GPIOn_INEN register and save the state before setting the register to 0.</li> <li>Clear pending interrupts by writing 1 to the GPIOn_INTFL_CLR.clr[pin] bit.</li> <li>Configure the pin for the desired interrupt event.</li> <li>Set GPIOn_INTMODE.mode[pin] to select the desired interrupt.</li> <li>For level triggered interrupts, the interrupt triggers on an input high (GPIOn_INTPOL.pol[pin] = 0) or input low level.</li> <li>For edge triggered interrupts, the interrupt triggers on a transition from low to high(GPIOn_INTPOL.pol[pin] = 0) or high to low (GPIOn_INTPOL.pol[pin] = 1).</li> <li> <p>Optionally set GPIOn_DUALEDGE.de_en[pin] to 1 to trigger on both the rising and falling edges of the input signal.</p> <p>a. Set GPIOn_INTEN.en[pin] to 1 to enable the interrupt for the pin.</p> </li> </ol>"},{"location":"gpio/#gpio-interrupt-handling","title":"GPIO Interrupt Handling","text":"<p>Each GPIO port is assigned a dedicated interrupt vector, as shown in Table 6\u20119.</p> <p>Table 6-9: MAX78000 GPIO Port Interrupt Vector Mapping </p> GPIO Interrupt Source GPIO Interrupt Status Register CM4 Interrupt Vector Number RV32 Interrupt Vector Number GPIO Interrupt Vector GPIO0[31:0] GPIOn_INTFL 40 25 GPIO0_IRQn GPIO1[9:0] GPIOn_INTFL 41 26 GPIO1_IRQn GPIO2[7:0] GPIOn_INTFL 42 27 GPIO2_IRQn <p>To handle GPIO interrupts in your interrupt vector handler, complete the following steps:</p> <ol> <li>Read the GPIOn_INTFL register to determine the GPIO pin that triggered the interrupt.</li> <li>Complete interrupt tasks associated with the interrupt source pin (application-defined).</li> <li>Clear the interrupt flag in the GPIOn_INTFL register by writing a 1 to the GPIOn_INTFL_CLR bit position that triggered the interrupt; this also clears and rearms the edge detectors for edge-triggered interrupts.</li> <li>Return from the interrupt vector handler.</li> </ol>"},{"location":"gpio/#using-gpio-for-wake-up-from-low-power-modes","title":"Using GPIO for Wake Up from Low-Power Modes","text":"<p>Low-power modes support an asynchronous wake up from edge-triggered interrupts on the GPIO ports. Level triggered interrupts are not supported for wake up because the system clock must be active to detect levels.</p> <p>A single wake-up interrupt vector, GPIOWAKE_IRQn, is assigned for all pins of all GPIO ports. When the GPIO wake-up event occurs, the application software must interrogate each GPIOn_INTFL register to determine which external port pin caused the wake-up event.</p> <p>Table 6-10: MAX78000 GPIO Wakeup Interrupt Vector </p> GPIO Wake Interrupt Source GPIO Wake Interrupt Status Register CM4 Interrupt Vector Number RV32 Interrupt Vector Number GPIO Wake Interrupt Vector GPIO0 GPIO0_INTFL 70 6 GPIOWAKE_IRQn GPIO1 GPIO1_INTFL 70 6 GPIOWAKE_IRQn GPIO2 GPIO2_INTFL 70 6 GPIOWAKE_IRQn <p>To enable a low-power mode to wake up from SLEEP, DEEPSLEEP, LPM, UPM, and BACKUP using an external GPIO interrupt, complete the following steps:</p> <ol> <li>Clear pending interrupt flags by writing a logic 1 to GPIOn_INTFL_CLR.clr[pin].</li> <li>Activate the GPIO wake-up function by writing a logic 1 to GPIOn_WKEN.we[pin].</li> <li>Configure the power manager to use the GPIO as a wake-up source by GCR_PM.gpio_we field to 1.</li> </ol>"},{"location":"gpio/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. If multiple instances of the peripheral are provided, each instance has its own independent set of the registers shown in Table 6\u201111. Register names for a specific instance are defined by replacing \"n\" with the instance number. For example, a register PERIPHERALn_CTRL resolves to PERIPHERAL0_CTRL and PERIPHERAL1_CTRL for instances 0 and 1, respectively.</p> <p>See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 6-11: GPIO Register Summary </p> Offset Register Description [0x0000] GPIOn_EN0 GPIO Port n Configuration Enable Bit 0 Register [0x0004] GPIOn_EN0_SET GPIO Port n Configuration Enable Atomic Set Bit 0 Register [0x0008] GPIOn_EN0_CLR GPIO Port n Configuration Enable Atomic Clear Bit 0 Register [0x000C] GPIOn_OUTEN GPIO Port n Output Enable Register [0x0010] GPIOn_OUTEN_SET GPIO Port n Output Enable Atomic Set Register [0x0014] GPIOn_OUTEN_CLR GPIO Port n Output Enable Atomic Clear Register [0x0018] GPIOn_OUT GPIO Port n Output Register [0x001C] GPIOn_OUT_SET GPIO Port n Output Atomic Set Register [0x0020] GPIOn_OUT_CLR GPIO Port n Output Atomic Clear Register [0x0024] GPIOn_IN GPIO Port n Input Register [0x0028] GPIOn_INTMODE GPIO Port n Interrupt Mode Register [0x002C] GPIOn_INTPOL GPIO Port n Interrupt Polarity Register [0x0030] GPIOn_INEN GPIO Port n Input Enable Register [0x0034] GPIOn_INTEN GPIO Port n Interrupt Enable Register [0x0038] GPIOn_INTEN_SET GPIO Port n Interrupt Enable Atomic Set Register [0x003C] GPIOn_INTEN_CLR GPIO Port n Interrupt Enable Atomic Clear Register [0x0040] GPIOn_INTFL GPIO Port n Interrupt Status Register [0x0048] GPIOn_INTFL_CLR GPIO Port n Interrupt Clear Register [0x004C] GPIOn_WKEN GPIO Port n Wakeup Enable Register [0x0050] GPIOn_WKEN_SET GPIO Port n Wakeup Enable Atomic Set Register [0x0054] GPIOn_WKEN_CLR GPIO Port n Wakeup Enable Atomic Clear Register [0x005C] GPIOn_DUALEDGE GPIO Port n Interrupt Dual Edge Mode Register [0x0060] GPIOn_PADCTRL0 GPIO Port n Pad Configuration 1 Register [0x0064] GPIOn_PADCTRL1 GPIO Port n Pad Configuration 2 Register [0x0068] GPIOn_EN1 GPIO Port n Configuration Enable Bit 1 Register [0x006C] GPIOn_EN1_SET GPIO Port n Configuration Enable Atomic Set Bit 1 Register [0x0070] GPIOn_EN1_CLR GPIO Port n Configuration Enable Atomic Clear Bit 1 Register [0x0074] GPIOn_EN2 GPIO Port n Configuration Enable Bit 2 Register [0x0078] GPIOn_EN2_SET GPIO Port n Configuration Enable Atomic Set Bit 2 Register [0x007C] GPIOn_EN2_CLR GPIO Port n Configuration Enable Atomic Clear Bit 2 Register [0x00A8] GPIOn_HYSEN GPIO Port n Hysteresis Enable Register [0x00AC] GPIOn_SRSEL GPIO Port n Slew Rate Select Register [0x00B0] GPIOn_DS0 GPIO Port n Output Drive Strength Bit 0 Register [0x00B4] GPIOn_DS11 GPIO Port n Output Drive Strength Bit 1 Register [0x00B8] GPIOn_PS GPIO Port n Pulldown/Pullup Strength Select Register [0x00C0] GPIOn_VSSEL GPIO Port n Voltage Select Register"},{"location":"gpio/#register-details","title":"Register Details","text":"<p>Table 6-12: GPIO Port n Configuration Enable Bit 0 Register </p> GPIO Port n Configuration Enable Bit 0 GPIOn_EN0 [0x0000] Bits Name Access Reset Description 31:0 config R/W 1 GPIO Configuration Enable Bit 0         In conjunction with the bits in Table 6\u20112, this field configures the corresponding device pin for digital I/O or an alternate function mode. This field can be modified directly by writing to this register or indirectly through GPIOn_EN0_SET or GPIOn_EN0_CLR.          <p>Table 6\u20115 depicts a detailed example of how each of these bits applies to each of the GPIO device pins</p> <p>Note: Some GPIO are not implemented in all devices. Bits associated with unimplemented GPIO should not be changed from their default value.</p> <p>Note: This register setting does not affect the input and interrupt functionality of the associated pin.</p> <p>Table 6-13: GPIO Port n Configuration Enable Atomic Set Bit 0 Register </p> GPIO Port n Configuration Enable Atomic Set Bit 0 Register GPIOn_EN0_SET [0x0004] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Configuration Enable Atomic Set Bit 0              Writing 1 to one or more bits sets the corresponding bits in the GPIOn_EN0 register.              0: No effect.             1: Corresponding bits in GPIOn_EN0 register set to 1.              <p>Table 6-14: GPIO Port n Configuration Enable Atomic Clear Bit 0 Register </p> GPIO Port n Configuration Enable Atomic Clear Bit 0 GPIOn_EN0_CLR [0x0008] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Configuration Enable Atomic Clear Bit 0              Writing 1 to one or more bits sets the corresponding bits in the GPIOn_EN0 register.              0: No effect.             1: Corresponding bits in GPIOn_EN0 register cleared to 0.              <p>Table 6-15: GPIO Port n Output Enable Register </p> GPIO Port n Output Enable GPIOn_OUTEN [0x000C] Bits Name Access Reset Description 31:0 en R/W 0 GPIO Output Enable         Set bit to 1 to enable the output driver for the corresponding GPIO pin. A bit can be enabled directly by writing to this register or indirectly through GPIOn_OUTEN_SET or GPIOn_OUTEN_CLR.          0: Pin is set to input mode; output driver disabled.         1: Pin is set to output mode.          <p>Table 6-16: GPIO Port n Output Enable Atomic Set Register </p> GPIO Port n Output Enable Atomic Set GPIOn_OUTEN_SET [0x0010] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Output Enable Atomic Set         Writing 1 to one or more bits sets the corresponding bits in the GPIOn_OUTEN register.          0: No effect.         1: Corresponding bits in GPIOn_OUTEN set to 1. <p>Table 6-17: GPIO Port n Output Enable Atomic Clear Register </p> GPIO Port n Output Enable Atomic Clear GPIOn_OUTEN_CLR [0x0014] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Output Enable Atomic Clear Writing 1 to one or more bits sets the corresponding bits in the GPIOn_OUTEN register.          0: No effect.         1: Corresponding bits in GPIOn_OUTEN cleared to 0. <p>Table 6-18: GPIO Port n Output Register </p> GPIO Port n Output GPIOn_OUT [0x0018] Bits Name Access Reset Description 31:0 level R/W 0 GPIO OutputSet the corresponding output pin high or low.                  0: Drive the corresponding output pin low (logic 0).         1: Drive the corresponding output pin high (logic 1).          <p>Table 6-19: GPIO Port n Output Atomic Set Register </p> GPIO Port n Output Atomic Set GPIOn_OUT_SET [0x001C] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Output Atomic SetWriting 1 to one or more bits sets the corresponding bits in the GPIOn_OUT register.          0: No effect.         1: Corresponding bits in GPIOn_OUTEN set to 1.          <p>Table 6-20: GPIO Port n Output Atomic Clear Register </p> GPIO Port n Output Atomic Clear GPIOn_OUT_CLR [0x0020] Bits Name Access Reset Description 31:0 clr WO 0 GPIO Output Atomic Clear         Writing 1 to one or more bits clears the corresponding bits in the GPIOn_OUT register.          0: No effect.         1: Corresponding bits in GPIOn_OUTEN cleared to 0.          <p>Table 6-21: GPIO Port n Input Register </p> GPIO Port n Input GPIOn_IN [0x0024] Bits Name Access Reset Description 31:0 level RO - GPIO Input Returns the state of the input pin only if the corresponding bit in the GPIOn_INEN register is set. The state is not affected by the pin's configuration as an output or alternate function.          0: Input pin low         1: Input pin high. <p>Table 6-22: GPIO Port n Interrupt Mode Register </p> GPIO Port n Interrupt Mode GPIOn_INTMODE [0x0028] Bits Name Access Reset Description 31:0 mode R/W 0 GPIO Interrupt Mode         Selects interrupt mode for the corresponding GPIO pin.          0: Level triggered interrupt.         1: Edge triggered interrupt.          <p>Note: This bit has no effect unless the corresponding bit in the         GPIOn_INTEN register is set.</p> <p>Table 6-23: GPIO Port n Interrupt Polarity Register </p> GPIO Port n Interrupt Polarity GPIOn_INTPOL [0x002C] Bits Name Access Reset Description 31:0 pol R/W 0 GPIO Interrupt Polarity         Interrupt polarity selection bit for the corresponding GPIO pin.         Level triggered mode (GPIOn_INTMODE.mode[pin] =\u00a00):              0: Input low (logic 0) triggers interrupt.             1: Input high (logic 1) triggers interrupt.                       Edge triggered mode         (GPIOn_INTMODE.mode[pin] =\u00a01):                  0: Falling edge triggers interrupt         1: Rising edge triggers interrupt.          <p>Note: This bit has no effect unless the corresponding bit in the         GPIOn_INTEN register is set.</p> <p>Table 6-24: GPIO Port n Input Enable Register </p> GPIO Port n Input Enable GPIOn_INEN [0x0030] Bits Name Access Reset Description 31:0 en R/W 1 GPIO Input Enable This field connects the corresponding input pad to the specified input pin for reading the pin state using the GPIOn_IN register.              0: Input not connected.             1: Input pin connected to the pad for reading through GPIOn_IN register.              <p>Table 6-25: GPIO Port n Interrupt Enable Register </p> GPIO Port n Interrupt Enable GPIOn_INTEN [0x0034] Bits Name Access Reset Description 31:0 en R/W 0 GPIO Interrupt Enable         Enable or disable the interrupt for the corresponding GPIO pin.          0: Disabled.         1: Enabled.          <p>Note: Disabling a GPIO interrupt does not clear pending interrupts         for the associated pin. Use the GPIOn_INTFL_CLR register to clear         pending interrupts.</p> <p>Table 6-26: GPIO Port n Interrupt Enable Atomic Set Register </p> GPIO Port Interrupt Enable Atomic Set GPIOn_INTEN_SET [0x0038] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Interrupt Enable Atomic Set         Writing 1 to one or more bits sets the corresponding bits in the GPIOn_INTEN register.          0: No effect.         1: Corresponding bits in GPIOn_INTEN register set to 1.          <p>Table 6-27: GPIO Port n Interrupt Enable Atomic Clear Register </p> GPIO Port Interrupt Enable Atomic Clear GPIOn_INTEN_CLR [0x003C] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Interrupt Enable Atomic Clear         Writing 1 to one or more bits clears the corresponding bits in the GPIOn_INTEN register.          0: No effect.         1: Corresponding bits in GPIOn_INTEN register cleared to 0.          <p>Table 6-28: GPIO Port n Interrupt Status Register </p> GPIO Port Interrupt Status GPIOn_INTFL [0x0040] Bits Name Access Reset Description 31:0 if RO 0 GPIO Interrupt Status         An interrupt is pending for the associated GPIO pin when this bit reads 1.          0: No GPIO interrupt is pending for the associated GPIO pin.         1: A GPIO interrupt is pending for the associated GPIO pin.          <p>Note: Write a 1 to the corresponding bit in the GPIOn_INTFL_CLR         register to clear the interrupt pending status flag.</p> <p>Table 6-29: GPIO Port n Interrupt Clear Register </p> GPIO Port Interrupt Clear GPIOn_INTFL_CLR [0x0048] Bits Name Access Reset Description 31:0 clr R/W1C 0 GPIO Interrupt Clear         Write 1 to clear the associated interrupt status (GPIOn_INTFL).          0: No effect on the associated GPIOn_INTFL flag.         1: Clear the associated interrupt pending flag in the GPIOn_INTFL register.          <p>Table 6-30: GPIO Port n Wakeup Enable Register </p> GPIO Port n Wakeup Enable GPIOn_WKEN [0x004C] Bits Name Access Reset Description 31:0 we R/W 0 GPIO Wakeup Enable         Enable the I/O as a wake-up source from SLEEP, DEEPSLEEP, and BACKUP.          0: The GPIO pin is not enabled as a wake-up source from low-power modes.         1: The GPIO pin is enabled as a wake-up source from low-power modes.          <p>Table 6-31: GPIO Port n Wakeup Enable Atomic Set Register </p> GPIO Port Wakeup Enable Atomic Set GPIOn_WKEN_SET [0x0050] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Wakeup Enable Atomic Set         Writing 1 to one or more bits sets the corresponding bits in the GPIOn_WKEN register.          0: No effect.         1: Corresponding bits in GPIOn_WKEN register set to 1.          <p>Table 6-32: GPIO Port n Wakeup Enable Atomic Clear Register </p> GPIO Port Wakeup Enable Atomic Clear GPIOn_WKEN_CLR [0x0054] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Wakeup Enable Atomic Clear         Writing 1 to one or more bits clears the corresponding bits in the GPIOn_WKEN register.          0: No effect.         1: Corresponding bits in GPIOn_WKEN register cleared to 0.          <p>Table 6-33: GPIO Port n Interrupt Dual Edge Mode Register </p> GPIO Port n Interrupt Dual Edge Mode GPIOn_DUALEDGE [0x005C] Bits Name Access Reset Description 31:0 de_en R/W 0 GPIO Interrupt Dual-Edge Mode Select         Setting this bit triggers interrupts on both the rising and falling edges of the corresponding GPIO if the associated GPIOn_INTMODE bit is set to edge-triggered. The associated polarity (GPIOn_INTPOL) setting has no effect when this bit is set.          0: Disable         1: Enable          <p>Table 6-34: GPIO Port n Pad Configuration 1 Register </p> GPIO Port n Pad Configuration 1 GPIOn_PADCTRL0 [0x0060] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Pad Configuration 1         Input mode configuration for the associated GPIO pin. Input mode selection and the choice of a weak or strong pullup, or weak or strong pulldown resistor, are described in Table 6\u20113.          <p>Table 6-35: GPIO Port n Pad Configuration 2 Register </p> GPIO Port n Pad Configuration 2 GPIOn_PADCTRL1 [0x0064] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Pad Configuration 2         Input mode configuration for the associated GPIO pin. Input mode selection and the choice of a weak or strong pullup, or weak or strong pulldown resistor, are described in Table 6\u20113.          <p>Table 6-36: GPIO Port n Configuration Enable Bit 1 Register </p> GPIO Port n Configuration Enable Bit 1 GPIOn_EN1 [0x0068] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Configuration Enable Bit 1         In conjunction with the bits in Table 6-2, this field configures the corresponding device pin for digital I/O or an alternate function mode. This field can be modified directly by writing to this register or indirectly through the GPIOn_EN1_SET or GPIOn_EN1_CLR registers.         <p>Table 6\u20115 depicts a detailed example of how each of these bits applies to each of the GPIO device pins</p> <p>Note: Some GPIO are not implemented in all devices. The bits associated with unimplemented GPIO should not be changed from their default value.</p> <p>Note: This register setting does not affect input and interrupt functionality of the associated pin.</p> <p>Table 6-37: GPIO Port n Configuration Enable Atomic Set Bit 1 Register </p> GPIO Port n Configuration Enable Atomic Set Bit 1 GPIOn_EN1_SET [0x006C] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Configuration Enable Atomic Set Bit 1         Writing 1 to one or more bits sets the corresponding bits in the GPIOn_EN1 register.          0: No effect.         1: Corresponding bits in GPIOn_EN1 register set to 1.          <p>Table 6-38: GPIO Port n Configuration Enable Atomic Clear Bit 1 Register </p> GPIO Port n Configuration Enable Atomic Clear Bit 1 GPIOn_EN1_CLR [0x0070] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Configuration Enable Atomic Clear Bit 1         Writing 1 to one or more bits clears the corresponding bits in the GPIOn_EN1 register.              0: No effect.             1: Corresponding bits in GPIOn_EN1 register cleared to 0.          <p>Table 6-39: GPIO Port n Configuration Enable Bit 2 Register </p> GPIO Port n Configuration Enable Bit 2 GPIOn_EN2 [0x0074] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Configuration Enable Bit 2         In conjunction with the bits in Table 6\u20112, this field configures the corresponding device pin for digital I/O or an alternate function mode. This field can be modified directly by writing to this register or indirectly through GPIOn_EN2_SET or GPIOn_EN2_CLR.         <p>Table 6\u20115 depicts a detailed example of how each of these bits applies to each of the GPIO device pins.</p> <p>Note: Some GPIO are not implemented in all devices. The bits associated with unimplemented GPIO should not be changed from their default value. Note:This register setting does not affect input and interrupt functionality of the associated pin. <p>Table 6-40: GPIO Port n Configuration Enable Atomic Set Bit 2 Register </p> GPIO Port n Configuration Enable Atomic Set Bit 2 GPIOn_EN2_SET [0x0078] Bits Name Access Reset Description 31:0 set R/W1 0 GPIO Alternate Function Select Atomic Set Bit 2         Writing 1 to one or more bits sets the corresponding bits in the GPIOn_EN2 register.              0: No effect.             1: Corresponding bits in GPIOn_EN2 register set to 1.          <p>Table 6-41: GPIO Port n Configuration Enable Atomic Clear Bit 2 Register </p> GPIO Port n Configuration Enable Atomic Clear Bit 2 GPIOn_EN2_CLR [0x007C] Bits Name Access Reset Description 31:0 clr R/W1 0 GPIO Alternate Function Select Atomic Clear Bit 2         Writing 1 to one or more bits clears the corresponding bits in the GPIOn_EN2 register.              0: No effect.             1: Corresponding bits in GPIOn_EN2 register cleared to 0.          <p>Table 6-42: GPIO Port n Hysteresis Enable Register </p> GPIO Port n Hysteresis Enable GPIOn_HYSEN [0x00A8] Bits Name Access Reset Description 31:0 en RO 0 Reserved <p>Table 6-43: GPIO Port n Slew Rate Select Register </p> GPIO Port n Slew Rate Select Register GPIOn_SRSEL [0x00AC] Bits Name Access Reset Description 31:0 sr_sel RO 0 Reserved <p>Table 6-44: GPIO Port n Output Drive Strength Bit 0 Register </p> GPIO Port n Output Drive Strength Bit 0 GPIOn_DS0 [0x00B0] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Output Drive Strength Selection 0         See Table 6-4 for details on setting the GPIO output drive strength and other electrical characteristics.          <p>Table 6-45: GPIO Port n Output Drive Strength Bit 1 Register </p> GPIO Port n Output Drive Strength Bit 1 GPIOn_DS11 [0x00B4] Bits Name Access Reset Description 31:0 config R/W 0 GPIO Output Drive Strength Selection 1         See Table 6-4 for details on setting the GPIO output drive strength and other electrical characteristics.          <p>Table 6-46: GPIO Port n Pulldown/Pullup Strength Select Register </p> GPIO Port n Pulldown/Pullup Strength Select Register GPIOn_PS [0x00B8] Bits Name Access Reset Description 31:0 pull_sel R/W 0 GPIO Pulldown/Pullup Strength Select             This field selects the strength of the pullup or pulldown resistor for a pin configured for input mode.                  0: Weak pulldown/pullup resistor for input pin.                 1: Strong pulldown/pullup resistor for input pin.              <p>Note: Refer to the data sheet for specific electrical characteristics of the pulldown/pullup resistances.</p> <p>Table 6-47: GPIO Port n Voltage Select Register </p> GPIO Port n Voltage Select GPIOn_VSSEL [0x00C0] Bits Name Access Reset Description 31:0 v_sel R/W 0 GPIO Supply Voltage Select             This field selects the voltage rail used for the GPIO pin.                  0: V<sub>DDIO</sub>                 1: V<sub>DDIOH</sub>"},{"location":"i2c-master-slave-serial-communication-peripheral/","title":"I\u00b2C Master/Slave Serial Communications Peripheral","text":"<p>The I\u00b2C peripherals can be configured as either an I2C master or an I2C slave at standard data rates.</p> <p>For detailed information on I\u00b2C bus operation, refer to Analog Devices Note 4024 \"SPI/I\u00b2C Bus Lines Control Multiple Peripherals\" at https://www.analog.com/en/resources/app-notes/spii2c-bus-lines-control-multiple-peripherals.html.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-masterslave-features","title":"I\u00b2C Master/Slave Features","text":"<p>Each I\u00b2C master/slave is compliant with the I\u00b2C Bus Specification and includes the following features:</p> <ul> <li>Communicates through a serial data bus (SDA) and a serial clock line (SCL)</li> <li>Operates as either a master or slave device as a transmitter or receiver</li> <li>Supports I\u00b2C Standard Mode, Fast Mode, Fast Mode Plus, and High Speed (Hs) mode</li> <li> <p>Transfers data at rates up to:</p> <ul> <li>100kbps in Standard Mode</li> <li>400kbps in Fast Mode</li> <li>1Mbps in Fast Mode Plus</li> <li>3.4Mbps in Hs Mode</li> </ul> </li> <li> <p>Supports multi-master systems, including support for arbitration and clock synchronization for Standard, Fast, and Fast Plus modes</p> </li> <li>Supports 7- and 10-bit addressing</li> <li>Supports RESTART condition</li> <li>Supports clock stretching</li> <li>Provides transfer status interrupts and flags</li> <li>Provides DMA data transfer support</li> <li>Supports I\u00b2C timing parameters fully controllable through software</li> <li>Provides glitch filter and Schmitt trigger hysteresis on SDA and SCL</li> <li>Provides control, status, and interrupt events for maximum flexibility</li> <li>Provides independent 8-byte receive FIFO and 8-byte transmit FIFO</li> <li>Provides transmit FIFO preloading</li> <li>Provides programmable interrupt threshold levels for the transmit and receive FIFO</li> </ul>"},{"location":"i2c-master-slave-serial-communication-peripheral/#instances","title":"Instances","text":"<p>The three instances of the peripheral are shown in Table 14-1, which lists the locations of the SDA and SCL signals for each of the I2C peripherals per package.</p> <p>Table 14-1: MAX78000 I2C Peripheral Pins </p> I\u00b2C Instance Alternate Function Alternate Function # Package 81-CTBGA I2C0 I2C0_SCL AF1 P0.10 I2C0_SDA AF1 P0.11 I2C1 I2C1_SCL AF1 P0.16 I2C1_SDA AF1 P0.17 I2C2 I2C2_SCL AF1 P0.30 I2C2_SDA AF1 P0.31"},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-overview","title":"I\u00b2C Overview","text":""},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-bus-terminology","title":"I\u00b2C Bus Terminology","text":"<p>Table 14-2 contains terms and definitions used in this chapter for the I\u00b2C bus terminology.</p> <p>Table 14-2: I\u00b2C Bus Terminology </p> Term Definition Transmitter The device that sends data to the bus. Receiver The device that receives data from the bus. Master The device that initiates a transfer, generates clock signals, and terminates a transfer. Slave The device that a master addresses. Multi-master More than one master can attempt to control the bus at the same time without corrupting the message. Arbitration Procedure to ensure that, if more than one master simultaneously tries to control the bus, only one can do so, and the resulting message is not corrupted. Synchronization Procedure to synchronize the clock signals of two or more devices. Clock Stretching When a slave device holds SCL low to pause a transfer until it is ready. This is an optional feature according to the I\u00b2C specification; thus, a master does not have to support slave clock stretching if none of the slaves in the system are capable of clock stretching."},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-transfer-protocol-operation","title":"I\u00b2C Transfer Protocol Operation","text":"<p>The I\u00b2C protocol operates over a two-wire bus: a clock circuit (SCL) and a data circuit (SDA). I\u00b2C is a half-duplex protocol: only one device is allowed to transmit on the bus at a time.</p> <p>Each transfer is initiated when the bus master sends a START or repeated START condition. It is followed by the I\u00b2C slave address of the targeted slave device plus a read/write bit. The master can transmit data to the slave (a 'write' operation) or receive data from the slave (a 'read' operation). Information is sent most significant bit (MSB) first. </p> <p>Following the slave address, the master indicates a read or write operation and then exchanges data with the addressed slave. An acknowledge bit is sent by the receiving device after each byte is transferred. </p> <p>When all necessary data bytes have been transferred, a STOP or RESTART condition is sent by the bus master to indicate the end of the transaction. After the STOP condition has been sent, the bus is idle and ready for the next transaction. After a RESTART condition is sent, the same master begins a new transmission. The number of bytes that can be transmitted per transfer is unrestricted.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#start-and-stop-conditions","title":"START and STOP Conditions","text":"<p>A START condition occurs when a bus master pulls SDA from high to low while SCL is high, and a STOP condition occurs when a bus master allows SDA to be pulled from low to high while SCL is high. Because these are unique conditions that cannot occur during normal data transfer, they are used to denote the beginning and end of the data transfer.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#master-operation","title":"Master Operation","text":"<p>I\u00b2C transmit and receive data transfer operations occur through the I2Cn_FIFO register. Writes to the register load the transmit FIFO and reads from the register return data from the receive FIFO. If a slave sends a NACK in response to a write operation, the I\u00b2C master generates an interrupt. The I\u00b2C controller can be configured to issue a STOP condition to free the bus.</p> <p>The receive FIFO contains the received data. If the receive FIFO is full or the transmit FIFO is empty, the I\u00b2C master stops the clock to allow time to read bytes from the receive FIFO or load bytes into the transmit FIFO.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#acknowledge-and-not-acknowledge","title":"Acknowledge and Not Acknowledge","text":"<p>An acknowledge bit (ACK) is generated by the receiver, whether I\u00b2C master or slave, after every byte received by pulling SDA low. The ACK bit is how the receiver tells the transmitter that the byte was successfully received and another byte might be sent.</p> <p>A Not Acknowledge (NACK) occurs if the receiver does not generate an ACK when the transmitter releases SDA. A NACK is generated by allowing SDA to float high during the acknowledge time slot. The I\u00b2C master can then either generate a STOP condition to abort the transfer or generate a repeated START condition (send a START condition without an intervening STOP condition) to start a new transfer.</p> <p>A receiver can generate a NACK after a byte transfer if any of the following conditions occur:</p> <ul> <li>No receiver is present on the bus with the transmitted address. In that case, no device responds with an acknowledge signal.</li> <li>The receiver cannot receive or transmit because it is busy and is not ready to start communication with the master.</li> <li>During the transfer, the receiver receives data or commands it does not understand.</li> <li>During the transfer, the receiver is unable to receive any more data.</li> <li>If an I\u00b2C master has requested data from a slave, it signals the slave to stop transmitting by sending a NACK following the last byte it requires.</li> </ul>"},{"location":"i2c-master-slave-serial-communication-peripheral/#bit-transfer-process","title":"Bit Transfer Process","text":"<p>Both SDA and SCL circuits are open-drain, bidirectional circuits. Each requires an external pullup resistor that ensures each circuit is high when idle. The I\u00b2C specification states that during data transfer, the SDA line can change state only when SCL is low and that SDA is stable and can be read when SCL is high, as shown in Figure 14-1.</p> <p>Figure 14-1: I\u00b2C Write Data Transfer </p> <p></p> <p>An example of an I\u00b2C data transfer is as follows:</p> <ol> <li>A bus master indicates a data transfer to a slave with a START condition.</li> <li>The master then transmits one byte with a 7-bit slave address and a single read-write bit: a zero for a write or a one for a read.</li> <li>During the next SCL clock following the read-write bit, the master releases SDA. During this clock period, the addressed slave responds with an ACK by pulling SDA low.</li> <li>The master senses the ACK condition and begins transferring data. If reading from the slave, it floats SDA and allows the slave to drive SDA to send data. After each byte, the master drives SDA low to acknowledge the byte. If writing to the slave, the master drives data on the SDA circuit for each of the eight bits of the byte and then floats SDA during the ninth bit to allow the slave to reply with the ACK indication.</li> <li>After the last byte is transferred, the master indicates the transfer is complete by generating a STOP condition. A STOP condition is generated when the master pulls SDA from a low to high while SCL is high.</li> </ol>"},{"location":"i2c-master-slave-serial-communication-peripheral/#configuration-and-usage","title":"Configuration and Usage","text":""},{"location":"i2c-master-slave-serial-communication-peripheral/#scl-and-sda-bus-drivers","title":"SCL and SDA Bus Drivers","text":"<p>SCL and SDA are open-drain signals. In this device, once the I\u00b2C peripheral is enabled and the proper GPIO alternate function is selected, the corresponding pad circuits are automatically configured as open-drain outputs. However, SCL can also be optionally configured as a push-pull driver to conserve power and avoid the need for any pullup resistor. This should only be used in systems where no I\u00b2C slave device can hold SCL low, such as for clock stretching. Push-pull operation is enabled by setting I2Cn_CTRL.sclppm to 1. SDA, on the other hand, always operates in open-drain mode.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#scl-clock-configurations","title":"SCL Clock Configurations","text":"<p>The SCL frequency depends on the values of the I\u00b2C's peripheral clock and the values of the external pullup resistor and trace capacitance on the SCL clock line.</p> <p>Note: An external RC load on the SCL line affects the target SCL frequency calculation.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#scl-clock-generation-for-standard-fast-and-fast-plus-modes","title":"SCL Clock Generation for Standard, Fast, and Fast-Plus Modes","text":"<p>The master generates the I\u00b2C clock on the SCL line. When operating as a master, the software must configure the I2Cn_CLKHI and I2Cn_CLKLO registers for the desired I\u00b2C operating frequency.</p> <p>The SCL high time is configured in the I\u00b2C Clock High Time register field I2Cn_CLKHI.hi using Equation 14-2. The SCL low time is configured in the I\u00b2C Clock Low Time register field I2Cn_CLKLO.lo using Equation 14-3. Each of these fields is 8-bits. The I\u00b2C frequency value is shown in Equation 14-1.</p> <p>Equation 14-1: I\u00b2C Clock Frequency </p> \\[ f_{I2C\\text{_}CLK} = \\frac{1}{t_{I2C\\text{_}CLK}}\\ is\\ either\\ f_{PCLK}\\ or\\ f_{IBRO} \\] <p>Equation 14-2: I\u00b2C Clock High Time Calculation </p> \\[ t_{SCL\\text{_}HI} = t_{I2C\\text{_}CLK} \\times (I2Cn_CLKHI.hi + 1) \\] <p>Equation 14-3: I\u00b2C Clock Low Time Calculation </p> \\[ t_{SCL\\text{_}LO} = t_{I2C\\text{_}CLK} \\times (I2Cn_CLKLO.lo + 1) \\] <p>Figure 14-2 shows the association between the SCL clock low and high times for Standard, Fast, and Fast Plus I\u00b2C frequencies.</p> <p>Figure 14-2: I\u00b2C SCL Timing for Standard, Fast and Fast-Plus Modes </p> <p></p> <p>External masters or external slaves may be driving SCL simultaneously, affecting the SCL duty cycle during synchronization. By monitoring SCL, the controller can determine whether an external master or slave is holding SCL low. In either case, the controller waits until SCL is high before starting to count the number of SCL high cycles. Similarly, suppose an external master pulls SCL low before the controller has finished counting SCL high cycles. In that case, the controller starts counting SCL low cycles and releases SCL once the time period, I2Cn_CLKLO.lo, has expired.</p> <p>Because the controller does not start counting the high and low time until the input buffer detects the new value, the actual clock behavior is based on many factors, including bus loading, other devices on the bus holding SCL low, and the filter delay time of this device.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#scl-clock-generation-for-hs-mode","title":"SCL Clock Generation for Hs-Mode","text":"<p>Values to be programmed into the I2Cn_HSCLK.hsclk_lo register and I2Cn_HSCLK.hsclk_hi register must be determined to operate the I\u00b2C interface in Hs-Mode at its maximum speed (~3.4MHz). Since the Hs-Mode operation is entered by first using one of the lower speed modes for pre-amble, a relevant lower speed mode must also be configured. See SCL Clock Generation for Standard, Fast and Fast-Plus Modes for information regarding the configuration of lower speed modes.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#hs-mode-timing","title":"Hs-Mode Timing","text":"<p>With I\u00b2C bus capacitances less than 100pf, the following specifications are extracted from the I\u00b2C-bus Specification and User Manual Rev. 6 April 2014 https://www.nxp.com/docs/en/user-guide/UM10204.pdf.</p> <p>\\(t_{LOW\\text{_MIN}}\\) = 160ns, the minimum low time for the I\u00b2C bus clock.</p> <p>\\(t_{HIGH\\text{_MIN}}\\) = 60ns, the minimum high time for the I\u00b2C bus clock.</p> <p>\\(t_{rCL\\text{_MAX}}\\) = 40ns, the maximum rise time of the I2C bus clock.</p> <p>\\(t_{fCL\\text{_MAX}}\\) = 40ns, the maximum fall time of the I\u00b2C bus clock.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#hs-mode-clock-configuration","title":"Hs-Mode Clock Configuration","text":"<p>The maximum Hs-Mode bus clock frequency can now be determined. Calculate the required settings for Hs-Mode using the following equations.</p> <p>Equation 14-4: I\u00b2C Target SCL Frequency </p> <p>Desired Target Maximum I2C Frequency: \\(f_{\\text{SCL}} = \\frac{1}{t_{\\text{SCL}}}\\) </p> <p>In Hs-Mode, the analog glitch filter (AF_MIN) within the device adds a minimum delay of \\(t_{\\text{AF_MIN}}\\) = 10ns.</p> <p>Equation 14-5: Determining the I2Cn_HSCLK.hsclk_lo Register Value </p> \\[I2Cn\\text{_}HSCLK.hsclk\\_ lo = MAX\\left\\{ \\left\\lfloor \\left( \\ \\frac{t_{LOW\\_ MIN} + \\ t_{FCL\\_ MAX} + \\ t_{I2C\\_ CLK} - t_{AF\\_ MIN}}{t_{I2C\\_ CLK}} \\right) \\right\\rfloor - 1,\\ \\ \\frac{t_{SCL}}{t_{I2C\\_ CLK}} - 1 \\right\\}\\] <p>Equation 14-6: Determining the I2Cn_HSCLK.hsclk_hi Register Value </p> \\[I2Cn\\text{_}HSCLK.hsclk\\text{\\_}hi = \\left\\lfloor \\left( \\ \\frac{t_{HIGH\\text{\\_}MIN} + \\ t_{rCL\\text{\\_}MAX} + \\ t_{I2C\\text{\\_}CLK} - t_{AF\\text{\\_}MIN}}{t_{I2C\\text{\\_}CLK}} \\right) \\right\\rfloor - 1\\] <p>Equation 14-7: The Calculated Frequency of the I\u00b2C Bus Clock Using the Results of Equation 14-5 and Equation 14-6 </p> <p>Calculated Frequency = \\(((I2Cn\\text{_HS}\\text{_CLK}.hsclk\\text{_hi}+1)+(I2Cn\\text{_HS}\\text{_CLK}.hsclk\\text{_lo}+1) \\times t_{I2C\\text{_CLK}})\\)</p> <p>Table 14-3 shows the I\u00b2C bus clock calculated frequencies given different \\({f_{SYS\\_ CLK}}\\) frequencies.</p> <p>Table 14-3: Calculated I\u00b2C Bus Clock Frequencies </p> f<sub>SYS_CLK</sub> (MHz) I2Cn_HSCLK.hsclk_hi I2Cn_HSCLK.hsclk_lo Calculated Frequency (MHz) 100 4 9 3.3 50 2 4 3.125 25 1 2 2.5"},{"location":"i2c-master-slave-serial-communication-peripheral/#master-mode-addressing","title":"Master Mode Addressing","text":"<p>After a START condition, the I\u00b2C slave address byte is transmitted by the hardware. The I\u00b2C slave address is composed of a slave address followed by a read/write bit.</p> <p>Table 14-4: I\u00b2C Slave Address Format </p> Slave Address Bits R/W Bit Description 0000 000 0 General Call Address 0000 000 1 START Condition 0000 001 x CBUS Address 0000 010 x Reserved for different bus format 0000 011 x Reserved for future purposes 0000 1xx x HS-mode master code 1111 1xx x Reserved for future purposes 1111 0xx x 10-bit slave addressing <p>In 7-bit addressing mode, the master sends one address byte. Address a 7-bit address slave as follows. First, clear the I2Cn_MSTCTRL.ex_addr_en field to 0, then write the address to the transmit FIFO formatted as follows:</p> <p>Master writing to slave: 7-bit address : [A6 A5 A4 A3 A2 A1 A0 0]</p> <p>Master reading from slave: 7-bit address : [A6 A5 A4 A3 A2 A1 A0 1]</p> <p>In 10-bit addressing mode (I2Cn_MSTCTRL.ex_addr_en = 1), the first byte the master sends is the 10-bit slave address byte, which includes the first two bits of the 10-bit address, followed by a 0 for the R/W bit. That is followed by a second byte representing the remainder of the 10-bit address. If the operation is a write, this is followed by data bytes to be written to the slave. If the operation is a read, it is followed by a repeated START. The software then writes the 10-bit address again with a 1 for the R/W bit. This I\u00b2C then starts receiving data from the slave device.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#master-mode-operation","title":"Master Mode Operation","text":"<p>The peripheral operates in master mode when master mode Enable I2Cn_CTRL.mst_mode = 1. To initiate a transfer, the master generates a START condition by setting I2Cn_MSTCTRL.start = 1. If the bus is busy, it does not generate a START condition until the bus is available.</p> <p>A master can communicate with multiple slave devices without relinquishing the bus. Instead of generating a STOP condition after communicating with the first slave, the master generates a Repeated START condition, or RESTART, by setting I2Cn_MSTCTRL.restart = 1. If a transaction is in progress, the peripheral completes the transaction before generating a RESTART. The peripheral then transmits the slave address stored in the transmit FIFO. The I2Cn_MSTCTRL.restart bit is automatically cleared to 0 as soon as the master begins a RESTART condition.</p> <p>I2Cn_MSTCTRL.start is automatically cleared to 0 after the master has completed a transaction and sent a STOP condition.</p> <p>The master can also generate a STOP condition by setting I2Cn_MSTCTRL.stop = 1.</p> <p>If both START and RESTART conditions are enabled simultaneously, a START condition is generated first. Then, at the end of the first transaction, a RESTART condition is generated.</p> <p>If both RESTART and STOP conditions are enabled simultaneously, a STOP condition is not generated. Instead, a RESTART condition is generated. After the RESTART condition is generated, both bits are cleared.</p> <p>If START, RESTART, and STOP are all enabled simultaneously, a START condition is first generated. At the end of the first transaction, a RESTART condition is generated. The I2Cn_MSTCTRL.stop bit is cleared and ignored.</p> <p>A slave cannot generate START, RESTART, or STOP conditions. Therefore, when master mode is disabled, the I2Cn_MSTCTRL.start, I2Cn_MSTCTRL.restart, and I2Cn_MSTCTRL.stop bits are all cleared to 0.</p> <p>For master mode operation, the following registers should only be configured when either:</p> <ol> <li>The I\u00b2C peripheral is disabled, or</li> <li>The I\u00b2C bus is guaranteed to be idle/free.</li> </ol> <p>If this peripheral is the only master on the bus, then changing the registers outside of a transaction (I2Cn_MSTCTRL.start = 0) satisfies this requirement:</p> <ul> <li>I2Cn_CTRL.mst_mode</li> <li>I2Cn_CTRL.irxm_en</li> <li>I2Cn_CTRL.one_mst_mode</li> <li>I2Cn_CTRL.hs_en</li> <li>I2Cn_RXCTRL1.cnt</li> <li>I2Cn_MSTCTRL.ex_addr_en</li> <li>I2Cn_MSTCTRL.mcode</li> <li>I2Cn_CLKLO.lo</li> <li>I2Cn_CLKHI.hi</li> <li>I2Cn_HSCLK.hsclk_lo</li> <li>I2Cn_HSCLK.hsclk_hi</li> </ul>"},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-master-mode-receiver-operation","title":"I\u00b2C Master Mode Receiver Operation","text":"<p>In contrast to the above set of registers, these registers below can be safely (re)programmed at any time:</p> <ul> <li>All interrupt flags and interrupt enable bits</li> <li>I2Cn_TXCTRL0.thd_val</li> <li>I2Cn_RXCTRL0.thd_lvl</li> <li>I2Cn_TIMEOUT.scl_to_val</li> <li>I2Cn_DMA.rx_en</li> <li>I2Cn_DMA.tx_en</li> <li>I2Cn_FIFO.data</li> <li>I2Cn_MSTCTRL.start</li> <li>I2Cn_MSTCTRL.restart</li> <li>I2Cn_MSTCTRL.stop</li> </ul>"},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-master-mode-transmitter-operation","title":"I\u00b2C Master Mode Transmitter Operation","text":"<p>When in master mode, initiating a master receiver operation begins with the following sequence:</p> <ol> <li>Write the number of data bytes to receive to the I\u00b2C receive count field (I2Cn_RXCTRL1.cnt).</li> <li>Write the I\u00b2C slave address byte to the I2Cn_FIFO register with the R/W bit set to 1</li> <li>Send a START condition by setting I2Cn_MSTCTRL.start = 1</li> <li>The slave address is transmitted by the controller from the I2Cn_FIFO register.</li> <li>The I\u00b2C controller receives an ACK from the slave, and the controller sets the address ACK interrupt flag (I2Cn_INTFL0.addr_ack = 1).</li> <li>The I\u00b2C controller receives data from the slave and automatically ACKs each byte. The software must retrieve this data by reading the I2Cn_FIFO register.</li> <li>Once I2Cn_RXCTRL1.cnt data bytes have been received, the I\u00b2C controller sends a NACK to the slave and sets the Transfer Done Interrupt Status Flag (I2Cn_INTFL0.done = 1).</li> <li>If I2Cn_MSTCTRL.restart or I2Cn_M.stop is set, then the I\u00b2C controller sends a repeated START or STOP, respectively.</li> </ol>"},{"location":"i2c-master-slave-serial-communication-peripheral/#i2c-multi-master-operation","title":"I\u00b2C Multi-Master Operation","text":"<p>The I\u00b2C protocol supports multiple masters on the same bus. When the bus is free, two (or more) masters might try to initiate communication simultaneously. This is a valid bus condition. If this occurs, and the two masters want to transmit different data or address different slaves, only one master can remain in master mode and complete its transaction. The other master must stop transmission and wait until the bus is idle. This process by which the winning master is determined is called bus arbitration.</p> <p>For each address or data bit, the master compares the data being transmitted on SDA to the value observed on SDA to determine which master wins the arbitration. If a master attempts to transmit a 1 on SDA (that is, the master lets SDA float) but senses a 0 instead, then that master loses arbitration, and the other master that sent a zero continues with the transaction. The losing master cedes the bus by switching off its SDA and SCL drivers.</p> <p>Note: This arbitration scheme works with any number of bus masters: if more than two masters begin transmitting simultaneously, the arbitration continues as each master cedes the bus until only one master remains transmitting. Data is not corrupted because as soon as each master realizes it has lost the arbitration, it stops transmitting on SDA, leaving the following data bits sent on SDA intact.</p> <p>If the I\u00b2C master peripheral detects it has lost the arbitration, it stops generating SCL; sets I2Cn_INTFL0.areri; sets I2Cn_INTFL0.tx_lockout, flushing any remaining data in the transmit FIFO; and clears I2Cn_MSTCTRL.start, I2Cn_MSTCTRL.restart, and I2Cn_MSTCTRL.stop to 0. So long as the peripheral is not addressed by the winning master, the I\u00b2C peripheral stays in master mode (I2Cn_CTRL.mst_mode = 1). If, at any time, another master addresses this peripheral using the address programmed in I2Cn_SLAVE.addr, then the I\u00b2C peripheral clears I2Cn_CTRL.mst_mode to 0 and begins responding as a slave. This can even occur during the same address transmission during which the peripheral lost arbitration.</p> <p>Note: Arbitration loss is considered an error condition, and like the other error conditions, it sets I2Cn_INTFL0.tx_lockout to 1. Therefore, after an arbitration loss, the software needs to clear I2Cn_INTFL0.tx_lockout and reload the transmit FIFO.</p> <p>Also, in a multi-master environment, the software does not need to wait for the bus to become free before attempting to start a transaction (writing 1 to I2Cn_MSTCTRL.start). If the bus is free when I2Cn_MSTCTRL.start is set to 1, the transaction begins immediately. If, instead, the bus is busy, then the peripheral will:</p> <ol> <li>Wait for the other master to complete the transaction(s) by sending a STOP,</li> <li>Count out the bus free time using \\(t_{BUF} = t_{SCL\\text{_LO}}\\) (see Equation 14-3), and then</li> <li>Send a START condition and begin transmitting the slave address byte(s) in the transmit FIFO, followed by the rest of the transfer.</li> </ol> <p>The I\u00b2C master peripheral is compliant with all bus arbitration and clock synchronization requirements of the I\u00b2C specification; this operation is automatic, and no additional programming is required.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#slave-mode-operation","title":"Slave Mode Operation","text":"<p>When in slave mode, the I\u00b2C peripheral operates as a slave device on the I\u00b2C bus and responds to an external master's requests to transmit or receive data. To configure the I\u00b2C peripheral as a slave, write the I2Cn_CTRL.mst_mode bit to zero. The I\u00b2C clock, SCL, is driven by the external master on the bus, and I2Cn_STATUS.mst_busy remains a zero. The desired slave address must be set by writing to the I2Cn_SLAVE.addr register.</p> <p>For slave mode operation, the following register fields should be configured with the I\u00b2C peripheral disabled:</p> <ul> <li>I2Cn_CTRL.mst_mode = 0 for slave operation.</li> <li> <p>I2C slave address</p> <ul> <li>I2Cn_SLAVE.addr must be set to the desired address for the device on the bus</li> <li>I2Cn_SLAVE.ext_addr_en should be set to 1 for 10-bit addressing or 0 for 7-bit addressing</li> </ul> </li> <li> <p>I2Cn_CTRL.gc_addr_en</p> </li> <li> <p>I2Cn_CTRL.irxm_en</p> <ul> <li>The recommended value for this field is 0. Note that a setting of 1 is incompatible with slave mode operation with clock stretching disabled (I2Cn_CTRL.clkstr_dis = 1).</li> </ul> </li> <li> <p>I2Cn_CTRL.clkstr_dis</p> </li> <li>I2Cn_CTRL.hs_en</li> <li> <p>I2Cn_RXCTRL0.dnr</p> <ul> <li>SMBus/PMBus applications should set this to 0, while other applications should set this to 1.</li> </ul> </li> <li> <p>I2Cn_TXCTRL0.nack_flush_dis</p> </li> <li>I2Cn_TXCTRL0.rd_addr_flush_dis</li> <li>I2Cn_TXCTRL0.wr_addr_flush_dis</li> <li>I2Cn_TXCTRL0.gc_addr_flush_dis</li> <li> <p>I2Cn_TXCTRL0.preload_mode</p> <ul> <li>The recommended value is 0 for applications that can tolerate slave clock stretching (I2Cn_CTRL.clkstr_dis = 0).</li> <li>The recommended value is 1 for applications that do not allow slave clock stretching (I2Cn_CTRL.clkstr_dis = 1).</li> </ul> </li> <li> <p>I2Cn_CLKHI.hi</p> <ul> <li> <p>Applies to slave mode when clock stretching is enabled (I2Cn_CTRL.clkstr_dis = 0)</p> <ul> <li>This is used to satisfy \\(t_{SU\\text{_DAT}}\\) after clock stretching; program it so that the value defined by Equation 14-2 is &gt;= \\(t_{SU\\text{_DAT(min)}}\\)</li> </ul> </li> </ul> </li> <li> <p>I2Cn_HSCLK.hsclk_hi</p> <ul> <li> <p>Applies to slave mode in Hs Mode when clock stretching is enabled (I2Cn_CTRL.clkstr_dis = 0)</p> <ul> <li>This is used to satisfy \\(t_{SU\\text{_DAT}}\\) after clock stretching during Hs-Mode operation; program it so that the value defined by Equation 14-6 is &gt;= \\(t_{SU\\text{_DAT(min)}}\\)</li> </ul> </li> </ul> </li> </ul> <p>In contrast to the above register fields, the following register fields can be safely (re)programmed at any time:</p> <ul> <li>All interrupt flags and interrupt enables</li> <li> <p>I2Cn_TXCTRL0.thd_val and I2Cn_RXCTRL0.thd_lvl</p> <ul> <li>Transmit and receive FIFO threshold levels</li> </ul> </li> <li> <p>I2Cn_TXCTRL1.tx_rdy</p> <ul> <li>Transmit ready (Can only be cleared by the hardware)</li> </ul> </li> <li> <p>I2Cn_TIMEOUT.scl_to_val</p> <ul> <li>Time out control</li> </ul> </li> <li> <p>I2Cn_DMA.rx_en and I2Cn_DMA.tx_en</p> <ul> <li>Transmit and receive DMA Enables</li> </ul> </li> <li> <p>I2Cn_FIFO.data</p> <ul> <li>FIFO access register</li> </ul> </li> </ul>"},{"location":"i2c-master-slave-serial-communication-peripheral/#slave-transmitter","title":"Slave Transmitter","text":"<p>The device operates as a slave transmitter when the received address matches the device slave address with the R/W bit set to 1. The master is then reading from the device slave. There two main modes of slave transmitter operation: just-in-time mode and preload mode.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#just-in-time-mode","title":"Just-In-Time Mode","text":"<p>In just-in-time mode, the software waits to write the transmit data to the transmit FIFO until after the master addresses it for a READ transaction, just in time, to send the data to the master. This allows the software to defer the determination of what data should be sent until the time of the address match. For example, the transmit data could be based on an immediately preceding I2C WRITE transaction that requests a certain block of data to be sent. The data could represent the latest, most up-to-date value of a sensor reading. Clock stretching must be enabled (I2Cn_CTRL.clkstr_dis = 0) for just-in-time mode operation.</p> <p>Program flow for transmit operation in just-in-time mode is as follows:</p> <ol> <li> <p>With I2Cn_CTRL.en = 0, initialize all relevant registers, including:</p> <p>a. Set the I2Cn_SLAVE.addr field with the desired I2C slave address.</p> <p>b. Set the I2Cn_SLAVE.ext_addr_en for either 7-bit or 10-bit addressing.</p> <p>c. Just-in-time mode specific settings:</p> <pre><code>i) I2Cn_CTRL.clkstr_dis = 0\nii) I2Cn_TXCTRL0[5:2] = 0x8\niii) I2Cn_TXCTRL0.preload_mode = 0.\n</code></pre> <p>d. Program I2Cn_CLKHI.hi and I2Cn_HSCLK.hsclk_hi with appropriate values satisfying  \\(t_{SU\\text{_DAT}}\\) (and HS \\(t_{SU\\text{_DAT}}\\)).</p> </li> <li> <p>The software sets I2Cn_CTRL.en = 1.</p> <p>a. The controller is now listening for its address. The peripheral responds to its address with an ACK for either a transmit (R/W = 1) or receive (R/W = 0) operation.</p> <p>b. When the address match occurs, the hardware sets I2Cn_INTFL0.addr_match and I2Cn_INTFL0.tx_lockout.</p> </li> <li> <p>The software waits for I2Cn_INTFL0.addr_match = 1, either through polling the interrupt flag or setting I2Cn_INTEN0.addr_match to interrupt the CPU.</p> </li> <li> <p>After reading I2Cn_INTFL0.addr_match = 1, the software reads I2Cn_CTRL.read to determine whether the transaction is a transmit (read = 1) or receive (read = 0) operation. In this case, assume read = 1, indicating transmit.</p> <p>a. At this point, the hardware holds SCL low until the software clears I2Cn_INTFL0.tx_lockout and loads data into the FIFO.</p> </li> <li> <p>The software clears I2Cn_INTFL0.addr_match and I2Cn_INTFL0.tx_lockout. Now that I2Cn_INTFL0.tx_lockout is 0, the software can begin loading the transmit data into I2Cn_FIFO.</p> </li> <li>As soon as there is data in the FIFO, the hardware releases SCL (after counting out I2Cn_CLKHI.hi) and sends out the data on the bus.</li> <li> <p>While the master keeps requesting data and sending ACKs, I2Cn_INTFL0.done remains 0, and the software should continue to monitor the transmit FIFO and refill it as needed.</p> <p>a. The FIFO level can be monitored synchronously through the transmit FIFO status/interrupt flags or asynchronously by setting I2Cn_TXCTRL0.thd_val and setting the I2Cn_INTEN0.tx_thd interrupt. b. If the transmit FIFO ever empties during the transaction, the hardware starts clock stretching and wait for it to be refilled.</p> </li> <li> <p>The master ends the transaction by sending a NACK. Once this happens, the I2Cn_INTFL0.done interrupt flag is set, and the software can stop monitoring the transmit FIFO.</p> </li> <li>The transaction is complete. The software should clean up, including clearing I2Cn_INTFL0.done and clearing I2Cn_INTEN0.tx_thd interrupt. Return to step 3, waiting on an address match.</li> <li> <p>If the software needs to know how many data bytes were transmitted to the master, it should check the transmit FIFO level as soon as the software sees I2Cn_INTFL0.done = 1 and use that to determine how many data bytes were successfully sent.</p> <p>a. Note that any data remaining in the transmit FIFO is discarded before the next transmit operation; it is NOT necessary for the software to manually flush the transmit FIFO for this to occur.</p> </li> </ol>"},{"location":"i2c-master-slave-serial-communication-peripheral/#preload-mode","title":"Preload Mode","text":"<p>The other mode of operation for slave transmit is preload mode. In this mode, it is assumed that the software knows before the transmit operation what data it should send to the master. This data is then preloaded into the transmit FIFO. Once the address match occurs, this data can be sent out without any software intervention. Preload mode can be used with clock stretching either enabled or disabled, but it is the only option if clock stretching must be disabled.</p> <p>To use slave transmit preload mode:</p> <ol> <li> <p>With I2Cn_CTRL.en = 0, initialize all relevant registers, including:</p> <p>a. Set the I2Cn_SLAVE.addr field with the desired I2C slave address.</p> <p>b. Set the I2Cn_SLAVE.ext_addr_en for either 7-bit or 10-bit addressing.</p> <p>c. Preload mode specific settings:</p> <pre><code>i) I2Cn_CTRL.cl_clk_stretch_dis = 1\nii) I2Cn_TXCTRL0[5:2] = 0xF\niii) I2Cn_TXCTRL0.preload_mode = 1.\n</code></pre> </li> <li> <p>The software sets I2Cn_CTRL.en = 1.</p> <p>a. Even though the controller is enabled, at this point, it will not ACK an address match with R/W = 1 until the software sets I2Cn_TXCTRL1.preload_rdy = 1.</p> </li> <li> <p>The software prepares for the transmit operation by loading data into the transmit FIFO, enabling DMA, setting I2Cn_TXCTRL0.thd_val, and setting the I2Cn_INTEN0.tx_thd interrupt, as well as any other required settings.</p> <p>a. If clock stretching is disabled, an empty transmit FIFO during the transmit operation causes a transmit underrun error. Therefore, the software should take any necessary steps to avoid an underrun before setting I2Cn_TXCTRL1.preload_rdy = 1.</p> <p>b. If clock stretching is enabled, then an empty transmit FIFO does not cause a transmit underrun error. However, it is recommended to follow the same preparation steps to minimize the amount of time spent clock stretching, letting the transaction complete as quickly as possible.</p> </li> <li> <p>Once the software has prepared for the transmit operation, the software should set I2Cn_TXCTRL1.preload_rdy = 1.</p> <p>a. The controller is now fully enabled and responds with an ACK to an address match.</p> <p>b. The hardware sets I2Cn_INTFL0.addr_match once an address match has occurred. I2Cn_INTFL0.tx_lockout is NOT set and remains 0.</p> </li> <li> <p>The software waits for I2Cn_INTFL0.addr_match = 1, either through polling the interrupt flag or setting I2Cn_INTEN0.amie to interrupt the CPU.</p> </li> <li> <p>After seeing I2Cn_INTFL0.addr_match = 1, the software reads I2Cn_CTRL.read to determine whether the transaction is a transmit (read = 1) or receive (read = 0) operation. In this case, assume I2Cn_CTRL.read, indicating transmit:</p> <p>a. At this point, the hardware begins sending out the preloaded data into the transmit FIFO.</p> <p>b. Once the first data byte is sent, the hardware also automatically clears I2Cn_TXCTRL1.preload_rdy to 0.</p> </li> <li> <p>While the master keeps requesting data and sending ACKs, I2Cn_INTFL0.done remains 0, and the software should continue to monitor the transmit FIFO and refill it as needed.</p> <p>a. The FIFO level can be monitored synchronously through the transmit FIFO interrupt flags or asynchronously by setting I2Cn_TXCTRL0.thd_val and setting I2Cn_INTEN0.tx_thd interrupt.</p> <p>b. If clock stretching is disabled and the transmit FIFO ever empties during the transaction, the hardware sets I2Cn_INTFL1.tx_un = 1 and sends 0xFF for all following data bytes requested by the master.</p> </li> <li> <p>The master ends the transaction by sending a NACK. Once this happens, the I2Cn_INTFL0.done interrupt flag is set.</p> <p>a. If the transmit FIFO goes empty at the same time that the master indicates the transaction is complete by sending a NACK, this is not considered an underrun event, I2Cn_INTFL1.tx_un flag remains 0.</p> </li> <li> <p>The transaction is complete. The software should clean up, which should include clearing I2Cn_INTFL0.done.</p> <p>a. If the software needs to know how many data bytes were transmitted to the master, it should check the transmit FIFO level as soon as the software sees I2Cn_INTFL0.done = 1 and use that to determine how many data bytes were successfully sent.</p> <p>b. By default, any data remaining in the transmit FIFO is NOT discarded and instead is reused for the next transmit operation.</p> <p>c. If this is not desired, the software can flush the transmit FIFO. The safest way to do this is by clearing and then resetting I2Cn_CTRL.en. This flushes both the transmit and receive FIFOs.</p> <p>d. Return to step 3 and prepare for the next transaction.</p> </li> </ol> <p>Once a slave starts transmitting out of the I2Cn_FIFO, detection of an out of sequence STOP, START, or RESTART condition terminates the current transaction. When a transaction is terminated in such a manner, I2Cn_INTFL0.start_err or I2Cn_INTFL0.stop_err is set to 1.</p> <p>If the transmit FIFO is not ready (I2Cn_TXCTRL1.preload_rdy = 0) and the I2C controller receives a data read request from the master, the hardware automatically sends a NACK at the end of the first address byte. In this case, the setting of the do not respond field is ignored by the hardware because the only opportunity to send a NACK for an I2C read transaction is after the address byte.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#slave-receivers","title":"Slave Receivers","text":"<p>The device operates as a slave receiver when the received address matches the device slave address with the R/W bit set to 0. The external master is writing to the slave.</p> <p>Program flow for a receive operation is as follows:</p> <ol> <li> <p>With I2Cn_CTRL.en = 0, initialize all relevant registers, including:</p> <p>a. Set the I2Cn_SLAVE.addr field with the desired I2C slave address.</p> <p>b. Set the I2Cn_SLAVE.ext_addr_en for either 7-bit or 10-bit addressing.</p> </li> <li> <p>Set I2Cn_CTRL.en = 1.</p> <p>a. If an address match with R/W = 0 occurs, and the receive FIFO is empty, the peripheral responds with an ACK, and the I2Cn_INTFL0.addr_match flag is set.</p> <p>b. If the receive FIFO is not empty, then depending on the value of I2Cn_RXCTRL0.dnr, the peripheral NACKs either the address byte (I2Cn_RXCTRL0.dnr = 1) or the first data byte (I2Cn_RXCTRL0.dnr = 0).</p> </li> <li> <p>Wait for I2Cn_INTFL0.addr_match = 1, either by polling or by enabling the wr_addr_match interrupt to the CPU. Once a successful address match occurs, the hardware sets I2Cn_INTFL0.addr_match = 1.</p> </li> <li>Read I2Cn_CTRL.read to determine whether the transaction is a transmit (I2Cn_CTRL.read = 1) or receive (I2Cn_CTRL.read = 0) operation. In this case, assume I2Cn_CTRL.read = 0, indicating receive. At this point, the device begins receiving data into the receive FIFO.</li> <li> <p>Clear I2Cn_INTFL0.addr_match, and while the master keeps sending data, I2Cn_INTFL0.done remains 0, and the software should continue to monitor the receive FIFO and empty it as needed.</p> <p>a. The FIFO level can be monitored synchronously through the receive FIFO status/interrupt flags or asynchronously by setting I2Cn_RXCTRL0.thd_lvl and enabling the I2Cn_INTFL0.rx_thd interrupt.</p> <p>b. If the receive FIFO ever fills up during the transaction, then the hardware sets I2Cn_INTFL1.rx_ov and then either:</p> <pre><code>i. If I2Cn_CTRL.clkstr_dis = 0, start clock stretching and wait for the software to read from the receive FIFO, OR\nii. If I2Cn_CTRL.clkstr_dis = 1, respond to the master with a NACK, and the last byte is discarded.\n</code></pre> </li> <li> <p>The master ends the transaction by sending a RESTART or STOP. Once this happens, the I2Cn_INTFL0.done interrupt flag is set, and software can stop monitoring the receive FIFO.</p> </li> <li> <p>Once a slave starts receiving into its receive FIFO, detection of an out of sequence STOP, START, or RESTART condition releases the I2C bus to the Idle state, and the hardware sets the I2Cn_INTFL0.start_err field or I2Cn_INTFL0.stop_err field to 1 based on the specific condition.</p> </li> </ol> <p>Suppose the software has not emptied the data in the receive FIFO from the previous transaction by the time a master addresses it for another write transaction (i.e., a slave receive). In that case, the controller does not participate in the transaction, and no additional data is written into the FIFO. Although a NACK is sent to the master, the software can control whether the NACK is sent with the initial address match or at the end of the first data byte. Setting I2Cn_RXCTRL0.dnr to 1 sends the NACK with the initial address match. Setting I2Cn_RXCTRL0.dnr to 0 chooses to send the NACK at the end of the first data byte.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#interrupt-sources","title":"Interrupt Sources","text":"<p>The I\u00b2C controller has a very flexible interrupt generator that generates an interrupt signal to the interrupt controller on any of several events. On recognizing the I\u00b2C interrupt, the software determines the cause of the interrupt by reading the I\u00b2C interrupt flags registers I2Cn_INTFL0 and I2Cn_INTFL1. Interrupts can be generated for the following events:</p> <ul> <li> <p>In either master or slave mode:</p> <ul> <li>Transaction complete</li> <li>Transaction timeout</li> <li>FIFO is empty, not empty, and full to a configurable threshold level</li> <li>Transmit FIFO lockout during a FIFO flush</li> <li>Out of sequence START and STOP conditions</li> </ul> </li> <li> <p>In master mode only:</p> <ul> <li>Address ACK or NACK received from the slave</li> <li>Data NACK received from the slave</li> <li>Lost arbitration</li> </ul> </li> <li> <p>In slave mode only:</p> <ul> <li>Sent a NACK to an external master because the transmit or receive FIFO was not ready</li> <li>Incoming address match</li> <li>Transmit FIFO underflow or receive FIFO overflow</li> </ul> </li> </ul> <p>Interrupts for each event can be enabled or disabled by setting or clearing the corresponding bit in the I2Cn_INTEN0 or I2Cn_INTEN1 interrupt enable registers.</p> <p>Note: Disabling the interrupt does not prevent the corresponding flag from being set by the hardware but does prevent an interrupt when the interrupt flag is set.</p> <p>Note: Before enabling an interrupt, the status of the corresponding interrupt flag should be checked and, if necessary, serviced or cleared. This prevents a previous interrupt event from interfering with a new I2C communications session.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#transmit-fifo-and-receive-fifo","title":"Transmit FIFO and Receive FIFO","text":"<p>There are separate transmit and receive FIFOs. Both are accessed using the FIFO data register I2Cn_FIFO. Writes to this register enqueue data into the transmit FIFO. Writing to a full transmit FIFO has no effect. Reads from I2Cn_FIFO dequeue data from the receive FIFO. Writing to a full transmit FIFO has no effect, and reading from an empty receive FIFO returns 0xFF.</p> <p>The transmit and receive FIFO only reads or writes one byte at a time. Transactions larger than 8 bits can still be performed, however. A 16- or 32-bit write to the transmit FIFO stores just the lowest 8 bits of the write data. A 16- or 32-bit read from the receive FIFO has the valid data in the lowest 8 bits and 0's in the upper bits. In any case, the transmit and receive FIFOs only accepts 8 bits at a time for either read or write.</p> <p>To offload work from the CPU, the DMA can read and write to each FIFO. See section DMA Control for more information on configuring the DMA.</p> <p>During a receive transaction (which during master operation is a READ, and during slave operation is a WRITE), received bytes are automatically written to the receive FIFO. The software should monitor the receive FIFO level and unload data from it as needed by reading I2Cn_FIFO. If the receive FIFO becomes full during a master mode transaction, then the controller sets the I2Cn_INTFL1.rx_ov the I2Cn_INTFL1.rx_ov bit, and one of two things happen, depending on the value of I2Cn_CTRL.clkstr_dis:</p> <ul> <li> <p>If clock stretching is enabled (I2Cn_CTRL.clkstr_dis = 0), then the controller stretches the clock until the software makes space available in the receive FIFO by reading from I2Cn_FIFO. Once space is available, the peripheral moves the data byte from the shift register into the receive FIFO, the SCL device pin is released, and the master is free to continue the transaction.</p> </li> <li> <p>If clock stretching is disabled (I2Cn_CTRL.clkstr_dis = 1), the controller responds to the master with a NACK, and the data byte is lost. The master can return the bus to idle with a STOP condition or start a new transaction with a RESTART condition.</p> </li> </ul> <p>During a transmit transaction (which during master operation is a WRITE, and during slave operation is a READ), either the software or the DMA can provide data to be transmitted by writing to the transmit FIFO. Once the peripheral finishes transmitting each byte, it removes it from the transmit FIFO and, if available, begins transmitting the next byte.</p> <p>Interrupts can be generated for the following FIFO status:</p> <ul> <li>Transmit FIFO level less than or equal to the threshold</li> <li>Receive FIFO level greater than or equal to the threshold</li> <li>Transmit FIFO underflow</li> <li>Receive FIFO overflow</li> <li>Transmit FIFO locked for writing</li> </ul> <p>Both the receive and transmit FIFOs are flushed when the I2C port is disabled by clearing I2Cn_CTRL.en = 0. While the peripheral is disabled, writes to the transmit FIFO have no effect and reads from the receive FIFO return 0xFF.</p> <p>The transmit FIFO and receive FIFO can be flushed by setting the transmit FIFO flush bit (I2Cn_TXCTRL0.flush = 1) or the receive FIFO flush bit (I2Cn_RXCTRL0.flush = 1), respectively. In addition, under certain conditions, the transmit FIFO is automatically locked by the hardware and flushed so stale data is not unintentionally transmitted. The transmit FIFO is automatically flushed and writes locked out from software under the following conditions:</p> <ul> <li> <p>General call address match </p> <ul> <li>Automatic flushing and lockout can be disabled by setting I2Cn_TXCTRL0.gc_addr_flush_dis.</li> </ul> </li> <li> <p>Slave address match write </p> <ul> <li>Automatic flushing and lockout can be disabled by setting I2Cn_TXCTRL0.wr_addr_flush_dis.</li> </ul> </li> <li> <p>Slave address match read </p> <ul> <li>Automatic flushing and lockout can be disabled by setting I2Cn_TXCTRL0.rd_addr_flush_dis.</li> </ul> </li> <li> <p>During operation as a slave transmitter, a NACK is received. </p> <ul> <li>Automatic flushing and lockout can be disabled by setting I2Cn_TXCTRL0.nack_flush_dis.</li> </ul> </li> <li> <p>Any of the following interrupts (Automatic flushing cannot be disabled for these conditions):</p> <ul> <li>Arbitration error</li> <li>Timeout error</li> <li>Master mode address NACK error</li> <li>Master mode data NACK error</li> <li>Start error</li> <li>Stop error</li> </ul> </li> </ul> <p>When the above conditions occur, the transmit FIFO is flushed so that data intended for a previous transaction is not transmitted unintentionally for a new transaction. In addition to flushing the transmit FIFO, the transmit lockout flag is set (I2Cn_INTFL0.tx_lockout = 1), and writes to the transmit FIFO are ignored until the software acknowledges the external event by clearing I2Cn_INTFL0.tx_lockout.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#transmit-fifo-preloading","title":"Transmit FIFO Preloading","text":"<p>There may be situations during slave mode operation where software wants to preload the transmit FIFO before transmission, such as when clock stretching is disabled. In this scenario, rather than responding to an external master requesting data with an ACK and clock stretching while software writes the data to the transmit FIFO, the controller instead responds with a NACK until the software has preloaded the requested data into the transmit FIFO.</p> <p>When transmit FIFO preloading is enabled, the software controls ACKs to the external master using the transmit ready (I2Cn_TXCTRL1.preload_rdy) bit. When I2Cn_TXCTRL1.preload_rdy is set to 0, the hardware automatically NACKs all read transactions from the master. Setting I2Cn_TXCTRL1.preload_rdy to 1 sends an ACK to the master on the next read transaction and transmits the data in the transmit FIFO. Preloading the transmit FIFO should be complete before setting the I2Cn_TXCTRL1.preload_rdy field to 1.</p> <p>The required steps for implementing transmit FIFO Preloading in an application are as follow:</p> <ol> <li>Enable transmit FIFO preloading by setting I2Cn_TXCTRL0.preload_mode to 1. This automatically clears I2Cn_TXCTRL1.preload_rdy to 0.</li> <li>If the transmit FIFO lockout flag (I2Cn_INTFL0.tx_lockout) is set to 1, write 1 to clear the flag and enable writes to the transmit FIFO.</li> <li>Enable DMA or Interrupts if required.</li> <li>Load the transmit FIFO with the data to send when the master sends the next read request.</li> <li>Set I2Cn_TXCTRL1.preload_rdy to 1 to automatically let the hardware send the preloaded FIFO on the next read from a master.</li> <li>I2Cn_TXCTRL1.preload_rdy is cleared by the hardware once it finishes transmitting the first byte, and data is transmitted from the transmit FIFO. Once cleared, the software may repeat the preloading process or disable transmit FIFO preloading.</li> </ol> <p>Note: To prevent the preloaded data from being cleared when the master tries to read it, the software must at least set I2Cn_INTFL0.rd_addr_flush_dis to 1, disabling auto flush on READ address match. The software determines whether the other auto flush disable bits should be set. For example, if a master uses I2C WRITE transactions to determine what data the slave should send in the following READ transactions, then the software can clear I2Cn_INTFL0.wr_addr_flush_dis to 0. Then when a WRITE occurs, the transmit FIFO is flushed, giving the software time to load the new data. For the READ transaction, the external master can poll the slave address until the new data has been loaded and I2Cn_TXCTRL1.preload_rdy is set, at which point the peripheral responds with an ACK.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#interactive-receive-mode-irxm","title":"Interactive Receive Mode (IRXM)","text":"<p>In some situations, the I2C peripheral might want to inspect and respond to each byte of received data. In this case, IRXM can be used. IRXM is enabled by setting I2Cn_CTRL.irxm_en = 1. If IRXM is enabled, it must occur before any I2C transfer is initiated.</p> <p>When IRXM is enabled, after every data byte received, the I2C peripheral automatically holds SCL low before the ACK bit. Additionally, after the 8th SCL falling edge, the I2C peripheral sets the IRXM interrupt status flag (I2Cn_INTFL0.irxm = 1). The software must read the data and generate a response (ACK or NACK) by setting the IRXM acknowledge (I2Cn_CTRL.irxm_ack) bit accordingly. Send an ACK by clearing the I2Cn_CTRL.irxm_ack bit to 0. Send a NACK by setting the I2Cn_CTRL.irxm_ack bit to 1.</p> <p>After setting the I2Cn_CTRL.irxm_ack bit, clear the IRXM interrupt flag. Write 1 to I2Cn_INTFL0.irxm to clear the interrupt flag. When the IRXM interrupt flag is cleared, the I2C peripheral hardware releases the SCL line and sends the I2Cn_CTRL.irxm_ack on the SDA line. </p> <p>While the I2C peripheral is waiting for the software to clear the I2Cn_INTFL0.irxm flag, the software can disable IRXM and, if operating as a master, load the remaining number of bytes to be received for the transaction. This allows the software to examine the initial bytes of a transaction, which might be a command, and then disable IRXM to receive the remaining bytes in normal operation.</p> <p>During IRXM, received data is not placed in the receive FIFO. Instead, the I2Cn_FIFO address is repurposed to directly read the receive shift register, bypassing the receive FIFO. Therefore, before disabling IRXM, the software must first read the data byte from I2Cn_FIFO.data. If the IRXM byte is not read, the byte is lost, and the next read from the receive FIFO returns 0xFF.</p> <p>Note: IRXM does not apply to address bytes, only to data bytes.</p> <p>Note: IRXM does not apply to general call address responses or START byte responses.</p> <p>Note: When enabling IRXM and operating as a slave, clock stretching must remain enabled (I2Cn_CTRL.clkstr_dis = 0).</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#clock-stretching","title":"Clock Stretching","text":"<p>When the I2C peripheral requires some response or intervention from the software to continue with a transaction, it holds SCL low, preventing the transfer from continuing. This is called \"clock stretching\" or \"stretching the clock.\" While the I2C Bus Specification defines the term \"clock stretching\" to only apply to a slave device holding the SCL line low, this section describes situations where the I2C peripheral holds the SCL line low in either slave or master mode and refers to both as clock stretching.</p> <p>When the I2C peripheral stretches the clock, it typically does so in response to either a full receive FIFO during a receive operation or an empty transmit FIFO during a transmit operation. Necessarily, this occurs before the next data byte begins, either between the ACK bit and the first data bit or, if at the beginning of a transaction, immediately after a START or RESTART condition. However, when operating in IRXM (I2Cn_CTRL.irxm_en = 1), the peripheral can also clock stretch before the ACK bit, allowing the software to decide whether to send an ACK or NACK.</p> <p>For a transmit operation (as either master or slave), when the transmit FIFO is empty, SCL is automatically held low after the ACK bit and before the next data byte begins. The software must write data to I2Cn_FIFO.data to stop clock stretching and continue the transaction. However, if operating in master mode, instead of sending more data, the software may also set either I2Cn_MSTCTRL.stop or I2Cn_MSTCTRL.restart to send a STOP or RESTART condition, respectively.</p> <p>For a receive operation (as either master or slave), when both the receive FIFO and the receive shift register are full, SCL is automatically held low until at least one data byte is read from the receive FIFO. The software must read data from I2Cn_FIFO.data to stop clock stretching and continue the transaction. If operating in master mode and this is the final byte of the transaction, as determined by I2Cn_RXCTRL1.cnt, the software must also set either I2Cn_MSTCTRL.stop or I2Cn_MSTCTRL.restart to send a STOP or RESTART condition, respectively. This must be done in addition to reading from the receive FIFO since the peripheral cannot start sending the STOP or RESTART until the last data byte has been moved from the receive shift register into the receive FIFO. (This automatically occurs once there is space in the receive FIFO.)</p> <p>Note: Since some masters do not support other devices stretching the clock, it is possible to completely disable all clock stretching during slave mode by setting I2Cn_CTRL.clkstr_dis to 1 and clearing I2Cn_CTRL.irxm_en to 0. In this case, instead of clock stretching, the peripheral automatically sends a NACK if receiving data or sends 0xFF if transmitting data.</p> <p>Note: The clock synchronization required to support other I2C master or slave devices stretching the clock is built into the peripheral and requires no intervention from software to operate correctly.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#bus-timeout","title":"Bus Timeout","text":"<p>The timeout register, I2Cn_TIMEOUT.scl_to_val, is used to detect bus errors. Equation 14-8 and Equation 14-9 show equations for calculating the maximum and minimum timeout values based on the value loaded into the I2Cn_TIMEOUT.scl_to_val field.</p> <p>Equation 14-8: I2C Timeout Maximum </p> \\[t_{TIMEOUT} \\leq \\left( \\frac{1}{f_{I2C\\text{_}CLK}} \\right) \\times \\left( \\left( I2Cn\\text{_}TIMEOUT.scl\\text{_}to\\text{_}val \\times 32 \\right) + 3 \\right)\\] <p>Due to clock synchronization, the timeout is guaranteed to meet the following minimum time calculation shown in Equation 14-9.</p> <p>Equation 14-9: I2C Timeout Minimum </p> \\[t_{TIMEOUT} \\leq \\left( \\frac{1}{f_{I2C\\text{_}CLK}} \\right) \\times \\left( \\left( I2Cn\\text{_}TIMEOUT.scl\\text{_}to\\text{_}val \\times 32 \\right) + 2 \\right)\\] <p>The timeout feature is disabled when I2Cn_TIMEOUT.scl_to_val = 0 and is enabled for any non-zero value. When the timeout is enabled, the timeout timer starts counting when the I2C peripheral hardware drives SCL low and is reset by the I2C peripheral hardware when the SCL line is released.</p> <p>The timeout counter only monitors if the I2C peripheral hardware is driving the SCL line low. It does not monitor if an external I2C device is actively holding the SCL line low. The timeout counter also does not monitor the status of the SDA line.</p> <p>If the timeout timer expires, a bus error condition has occurred. When a timeout error occurs, the I2C peripheral hardware releases the SCL and SDA lines and sets the timeout error interrupt flag to 1 (I2Cn_INTFL0.to_err = 1).</p> <p>For applications where the device may hold the SCL line low longer than the maximum timeout supported, the timeout can be disabled by setting the timeout field to 0 (I2Cn_TIMEOUT.scl_to_val = 0).</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#dma-control","title":"DMA Control","text":"<p>There are independent DMA channels for each transmit FIFO and receive FIFO. DMA activity is triggered by the transmit FIFO (I2Cn_TXCTRL0.thd_val) and receive FIFO (I2Cn_RXCTRL0.thd_lvl) threshold levels.</p> <p>When the transmit FIFO byte count (I2Cn_TXCTRL1.lvl) is less than or equal to the transmit FIFO Threshold Level I2Cn_TXCTRL0.thd_val, then the DMA transfers data into the transmit FIFO according to the DMA configuration.</p> <p>The DMA burst size should be set as shown in Equation 14-10 to ensure the DMA does not overflow the transmit FIFO:</p> <p>Equation 14-10: DMA Burst Size Calculation for I2C Transmit </p> \\[ \\text{DMA Burst Size} \\leq \\text{TX FIFO Depth} - \\text{I2C}_n\\text{TXCTRL0.tx_thresh} = 8 - \\text{I2C}_n\\text{TXCTRL0.tx_thresh}, \\\\ \\] \\[ \\text{where } 0 \\leq \\text{I2C}_n\\text{TXCTRL0.tx_thresh} \\leq 7 \\] <p>Applications trying to avoid transmit underflow or clock stretching should use a smaller burst size and higher I2Cn_TXCTRL0.thd_val setting. This fills up the FIFO more frequently but increases internal bus traffic.</p> <p>When the receive FIFO count (I2Cn_RXCTRL1.lvl) is greater than or equal to the receive FIFO Threshold Level I2Cn_RXCTRL0.thd_lvl, the DMA transfers data out of the receive FIFO according to the DMA configuration. The DMA burst size should be set as shown in Equation 14-11 to ensure the DMA does not underflow the receive FIFO:</p> <p>Equation 14-11: DMA Burst Size Calculation for I2C Receive </p> \\[ \\text{DMA Burst Size} \\leq \\text{I2C}_n\\text{RXCTRL0.rx_thresh}  \\] \\[ \\text{where } 1 \\leq \\text{I2C}_n\\text{RXCTRL0.rx_thresh} \\leq 8 \\] <p>Applications trying to avoid receive overflow or clock stretching should use a smaller burst size and lower I2Cn_RXCTRL0.thd_lvl. This results in reading from the receive FIFO more frequently but increases internal bus traffic.</p> <p>Note: For receive operations, the length of the DMA transaction (in bytes) must be an integer multiple of I2Cn_RXCTRL0.thd_lvl. Otherwise, the receive transaction ends with some data still in the receive FIFO, but not enough to trigger an interrupt to the DMA, leaving the DMA transaction incomplete. One easy way to ensure this for all transaction lengths is to set burst size to 1 (I2Cn_RXCTRL0.thd_lvl = 1).</p> <p>To enable DMA transfers, enable the transmit DMA channel (I2Cn_DMA.tx_en) and the receive DMA channel (I2Cn_DMA.rx_en) if receiving data.</p>"},{"location":"i2c-master-slave-serial-communication-peripheral/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. If multiple instances of the peripheral are provided, each instance has its own independent set of the registers shown in Table 14-5. Register names for a specific instance are defined by replacing \"n\" with the instance number. For example, a register PERIPHERALn_CTRL resolves to PERIPHERAL0_CTRL and PERIPHERAL1_CTRL for instances 0 and 1, respectively.</p> <p>See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 14-5: I\u00b2C Register Summary </p> Offset Register Description [0x0000] I2Cn_CTRL I2C Control Register [0x0004] I2Cn_STATUS I2C Status Register [0x0008] I2Cn_INTFL0 I2C Interrupt Flags 0 Register [0x000C] I2Cn_INTEN0 I2C Interrupt Enable 0 Register [0x0010] I2Cn_INTFL1 I2C Interrupt Flags 1 Register [0x0014] I2Cn_INTEN1 I2C Interrupt Enable 1 Register [0x0018] I2Cn_FIFOLEN I2C FIFO Length Register [0x001C] I2Cn_RXCTRL0 I2C Receive Control 0 Register [0x0020] I2Cn_RXCTRL1 I2C Receive Control 1 Register [0x0024] I2Cn_TXCTRL0 I2C Transmit Control 0 Register [0x0028] I2Cn_TXCTRL1 I2C Transmit Control 1 Register [0x002C] I2Cn_FIFO I2C Transmit and Receive FIFO Register [0x0030] I2Cn_MSTCTRL I2C Master Control Register [0x0034] I2Cn_CLKLO I2C Clock Low Time Register [0x0038] I2Cn_CLKHI I2C Clock High Time Register [0x003C] I2Cn_HSCLK I2C Hs-Mode Clock Control Register [0x0040] I2Cn_TIMEOUT I2C Timeout Register [0x0048] I2Cn_DMA I2C DMA Enable Register [0x004C] I2Cn_SLAVE I2C Slave Address Register"},{"location":"i2c-master-slave-serial-communication-peripheral/#register-details","title":"Register Details","text":"<p>Table 14-6: I\u00b2C Control Register </p> I\u00b2C Control I2Cn_CTRL [0x0000] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 hs_en R/W 0 Hs-Mode Enable         Set this field to 1 for I\u00b2C Hs-Mode operation.                  0: Disabled         1: Enabled          14 - RO 0 Reserved 13 one_mst_mode R/W 0 Single Master Only When set to 1, the device MUST ONLY be used in a single master application with slave devices that are NOT going to hold SCL low (i.e., the slave devices never clock stretch) 12 clkstr_dis R/W 0 Slave Mode Clock Stretching          0: Enabled         1: Disabled          11 read R 0 Slave Read/Write Bit StatusReturns the logic level of the R/W bit on a received address match (I2Cn_INTFL0.addr_match = 1) or general call match         (I2Cn_INTFL0.gc_addr_match\u00a0=\u00a01). This bit is valid for three system clock cycles after the address match status flag is set. 10 bb_mode R/W 0 Software Output Control Enabled Setting this field to 1 enables software bit-bang control of the I<sup>2</sup>C Bus.                  0: The I<sup>2</sup>C controller manages the SDA and SCL pins in the hardware.         1: SDA and SCL are controlled by the software using the I2Cn_CTRL.sda_out and I2Cn_CTRL.scl_out fields. 9 sda R - SDA Status          0: SDA pin is logic low.         1: SDA pin is logic high. 8 scl R - SCL Status          0: SCL pin is logic low.         1: SCL pin is logic high. 7 sda_out R/W 0 SDA Pin Output Control Set the state of the SDA hardware pin (actively pull low or float).                  0: Pull SDA Low         1: Release SDA Note: Only valid when I2Cn_CTRL.bb_mode = 1 6 scl_out R/W 0 SCL Pin Output Control         Set the state of the SCL hardware pin (actively pull low or float).                  0: Pull SCL low         1: Release SCL Note: Only valid when I2Cn_CTRL.bb_mode = 1 5 - RO 0 Reserved 4 irxm_ack R/W 0 IRXM AcknowledgeIf IRXM is enabled (I2Cn_CTRL.rx_mode\u00a0=\u00a01), this field determines if the hardware sends an ACK or a NACK to an IRXM transaction.                  0: Respond to IRXM with an ACK.         1: Respond to IRXM with a NACK. 3 irxm_en R/W 0 IRXM Enable When receiving data, this field allows for an interactive receive mode (IRXM) interrupt event after each received byte of data. The I<sup>2</sup>C peripheral hardware can be enabled to send either an ACK or NACK for IRXM. See the Interactive Receive Mode section for detailed information.                  0: Disable         1: Enable Note: Only set this field when the I<sup>2</sup>C bus is inactive. 2 gc_addr_en R/W 0 General Call Address Enable          0: Ignore General Call Address         1: Acknowledge General Call Address 1 mst_mode R/W 0 Master Mode Enable          0: Slave mode enabled.         1: Master mode enabled. 0 en R/W 0 I<sup>2</sup>C Peripheral Enable          0: Disabled         1: Enabled <p>Table 14-7: I2C Status Register </p> I2C Status I2Cn_STATUS [0x0004] Bits Name Access Reset Description 31:6 - RO 0 Reserved 5 mst_busy RO 0 Master Mode I<sup>2</sup>C Bus Transaction Active         The peripheral is operating in master mode, and a valid transaction beginning with a START command is in progress on the I<sup>2</sup>C bus. This bit reads 1 until the master ends the transaction with a STOP command. This bit continues to read 1 while a slave performs clock stretching.                  0: Device not actively driving SCL clock cycles.         1: Device operating as master and actively driving SCL clock cycles. 4 tx_full RO 0 Transmit FIFO Full          0: Not full         1: Full 3 tx_em RO 1 Transmit FIFO Empty          0: Not empty         1: Empty 2 rx_full RO 0 Receive FIFO Full          0: Not full         1: Full 1 rx_em RO 1 Receive FIFO Empty          0: Not empty         1: Empty 0 busy RO 0 Master or Slave Mode I<sup>2</sup>C Busy Transaction Active         The peripheral is operating in master or slave mode, and a valid transaction beginning with a START command is in progress on the I<sup>2</sup>C bus. This bit reads 1 until the peripheral acting as a master or an external master ends the transaction with a STOP command. This bit continues to read 1 while a slave performs clock stretching.                  0: I<sup>2</sup>C bus is idle.         1: I<sup>2</sup>C bus transaction in progress. <p>Table 14-8: I2C Interrupt Flag 0 Register </p> I2C Interrupt Flag 0 I2Cn_INTFL0 [0x0008] Bits Name Access Reset Description 31:24 - RO 0 Reserved 23 wr_addr_match R/W1C 0 Slave Write Address Match Interrupt Flag If set, the device has been accessed for a write (i.e., receive) transaction in slave mode, and the address received matches the device slave address.                  0: No address match.         1: Address match. 22 rd_addr_match R/W1C 0 Slave Read Address Match Interrupt Flag         If set, the device has been accessed for a read (i.e., transmit) transaction in slave mode, and the address received matches the device slave address.                  0: No address match.         1: Address match. 21:17 - RO 0 Reserved 16 - R/W1C 0 MAMI Interrupt Flag 15 tx_lockout R/W1C 0 Transmit FIFO Locked Interrupt Flag If set, the transmit FIFO is locked and writes to the transmit FIFO are ignored. When set, the transmit FIFO is automatically flushed. Writes to the transmit FIFO are ignored until this flag is cleared. Write 1 to clear.                  0: Transmit FIFO not locked.         1: Transmit FIFO is locked, and all writes to the transmit FIFO are ignored. 14 stop_err R/W1C 0 Out of Sequence STOP Interrupt Flag This flag is set if a STOP condition occurs out of sequence. Write 1 to clear this field. Writing 0 has no effect.                  0: Normal operation         1: Out of sequence STOP condition occurred. 13 start_err R/W1C 0 Out of Sequence START Interrupt Flag This flag is set if a START condition occurs out of sequence. Write 1 to clear this field. Writing 0 has no effect.                  0: Error condition has not occurred.         1: Out of sequence START condition occurred. 12 dnr_err R/W1C 0 Slave Mode Do Not Respond Interrupt Flag This flag is set if an address match is made, but the transmit FIFO or receive FIFO is not ready. Write 1 to clear this field. Writing 0 has no effect.                  0: Normal operation         1: I<sup>2</sup>C address match has occurred, and either the transmit or receive FIFO is not configured. 11 data_err R/W1C 0 Master Mode Data NACK from External Slave Interrupt Flag          This flag is set by hardware if a NACK is received from a slave. This flag is only valid if the I<sup>2</sup>C peripheral is configured for master mode operation. Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: Data NACK received from a slave. 10 addr_nack_err R/W1C 0 Master Mode Address NACK from Slave Error Flag The hardware sets this flag if an address NACK is received from a slave bus. This flag is only valid if the I<sup>2</sup>C peripheral is configured for master mode operation. Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: Address NACK received from a slave. 9 to_err R/ W1C 0 Timeout Error Interrupt Flag This field is set to 1 when this device holds the SCL low longer than the programmed timeout value, in either master or slave mode. Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: Timeout error occurred.          8 arb_err R/ W1C 0 Master Mode Arbitration Lost Interrupt Flag Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: Condition occurred. 7 addr_ack R/ W1C 0 Master Mode Address ACK from External Slave Interrupt Flag This field is set when a slave address ACK is received. Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: The slave device ACK for the address was received. 6 stop R/ W1C 0 Slave Mode STOP Condition Interrupt Flag         This flag is set by the hardware when a STOP condition is detected. Write 1 to clear. Write 0 has no effect.                  0: Normal operation         1: Condition occurred. 5 tx_thd RO 1 Transmit FIFO Threshold Level Interrupt Flag The hardware sets this field if the number of bytes in the transmit FIFO is less than or equal to the transmit FIFO threshold level. Write 1 to clear. This field is automatically cleared by the hardware when the transmit FIFO contains fewer bytes than the transmit threshold level.                  0: Transmit FIFO contains more bytes than the transmit threshold level.         1: Transmit FIFO contains fewer than or equal to the transmit threshold level. 4 rx_thd R/W1C 1 Receive FIFO Threshold Level Interrupt Flag The hardware sets this field if the number of bytes in the receive FIFO is greater than or equal to the receive FIFO threshold level. This field is automatically cleared when the receive FIFO contains fewer bytes than the receive threshold setting.                  0: Receive FIFO contains fewer bytes than the receive threshold level.         1: Receive FIFO contains at least receive threshold level of bytes. 3 addr_match R/W1C 0 Slave Mode Incoming Address Match Status Interrupt Flag Write 1 to clear. Writing 0 has no effect.                  0: Slave address match has not occurred.         1: Slave address match occurred. 2 gc_addr_match R/W1C 0 Slave Mode General Call Address Match Received Interrupt Flag Write 1 to clear. Writing 0 has no effect.                  0: Normal operation         1: General call address match occurred. 1 irxm R/W1C 0 IRXM Interrupt Flag          Write 1 to clear. Writing 0 is ignored.                  0: Normal operation         1: Interrupt condition occurred. 0 done R/W1C 0 Transfer Complete Interrupt Flag         This flag is set for both master and slave mode once a transaction completes. Write 1 to clear. Writing 0 has no effect.                  0: Transfer is not complete.         1: Transfer complete. <p>Table 14-9: I2C Interrupt Enable 0 Register </p> I2C Interrupt Enable 0 I2Cn_INTEN0 [0x000C] Bits Name Access Reset Description 31:24 - RO 0 Reserved 23 wr_addr_match R/W 0 Slave Write Address Match Interrupt Enable This bit is set to enable interrupts when the device is accessed in slave mode, and the address received matches the device slave addressed for a write transaction.                  0: Disabled         1: Enabled          22 rd_addr_match R/W 0 Slave Read Address Match Interrupt Enable This bit is set to enable interrupts when the device is accessed in slave mode, and the address received matches the device slave addressed for a read transaction.                  0: Disabled         1: Enabled          21:17 - RO 0 Reserved 16 mami R/W 0 MAMI Interrupt Enable 15 tx_lockout R/W 0 Transmit FIFO Lock Out Interrupt Enable          0: Disabled         1: Enabled          14 stop_err R/W 0 Out of Sequence STOP Condition Detected Interrupt Enable          0: Disabled         1: Enabled          13 start_err R/W 0 Out of Sequence START Condition Detected Interrupt Enable          0: Disabled         1: Enabled          12 dnr_err R/W 0 Slave Mode Do Not Respond Interrupt Enable Set this field to enable interrupts in slave mode when the \"Do Not Respond\" condition occurs.                  0: Disabled         1: Enabled          11 data_err R/W 0 Master Mode Received Data NACK from Slave Interrupt Enable          0: Disabled         1: Enabled          10 addr_nack_err R/W 0 Master Mode Received Address NACK from Slave Interrupt Enable          0: Disabled         1: Enabled          9 to_err R/W 0 Timeout Error Interrupt Enable          0: Disabled         1: Enabled          8 arb_err R/W 0 Master Mode Arbitration Lost Interrupt Enable          0: Disabled         1: Enabled          7 addr_ack R/W 0 Received Address ACK from Slave Interrupt Enable Set this field to enable interrupts for master mode slave device address ACK events.          0: Disabled         1: Enabled          6 stop R/W 0 STOP Condition Detected Interrupt Enable          0: Disabled         1: Enabled          5 tx_thd R/W 0 Transmit FIFO Threshold Level Interrupt Enable          0: Disabled         1: Enabled          4 rx_thd R/W 0 Receive FIFO Threshold Level Interrupt Enable          0: Disabled         1: Enabled          3 addr_match R/W 0 Slave Mode Incoming Address Match Interrupt Enable          0: Disabled         1: Enabled          2 gc_addr_match R/W 0 Slave Mode General Call Address Match Received Interrupt Enable          0: Disabled         1: Enabled 1 irxm R/W 0 Interactive Receive Interrupt Enable          0: Disabled         1: Enabled 0 done R/W 0 Transfer Complete Interrupt Enable          0: Disabled         1: Enabled <p>Table 14-10: I2C Interrupt Flag 1 Register </p> I2C Interrupt Status Flags 1 I2Cn_INTFL1 [0x0010] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2 start R/W1C 0 START Condition Status Flag If set, a device START condition has been detected.                  0: START condition not detected.         1: START condition detected.  1 tx_un R/W1C 0 Slave Mode Transmit FIFO Underflow Status Flag In slave mode operation, the hardware sets this flag automatically if the transmit FIFO is empty and the master requests more data by sending an ACK after the previous byte is transferred.                  0: Slave mode transmit FIFO underflow condition has not occurred.         1: Slave mode transmit FIFO underflow condition occurred. 0 rx_ov R/W1C 0 Slave Mode Receive FIFO Overflow Status Flag In slave mode operation, the hardware sets this flag automatically when a receive FIFO overflow occurs. Write 1 to clear. Writing 0 has no effect.                  0: Slave mode receive FIFO overflow event has not occurred.         1: Slave mode receive FIFO overflow condition occurred (data lost). <p>Table 14-11: I2C Interrupt Enable 1 Register </p> I2C Interrupt Enable 1 I2Cn_INTEN1 [0x0014] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2 start R/W 0 START Condition Interrupt Enable          0: Disabled.         1: Enabled. 1 tx_un R/W 0 Slave Mode Transmit FIFO Underflow Interrupt Enable          0: Disabled.         1: Enabled. 0 rx_ov R/W 0 Slave Mode Receive FIFO Overflow Interrupt Enable          0: Disabled.         1: Enabled. <p>Table 14-12: I2C FIFO Length Register </p> I2C FIFO Length I2Cn_FIFOLEN [0x0018] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:8 tx_depth RO 8 Transmit FIFO Length         Reading this field returns the depth of the transmit FIFO.                  8: 8-bytes 7:0 rx_depth RO 8 Receive FIFO Length          Reading this field returns the depth of the receive FIFO.                  8: 8-bytes <p>Table 14-13: I2C Receive Control 0 Register </p> I2C Receive Control 0 I2Cn_RXCTRL0 [0x001C] Bits Name Access Reset Description 31:12 - RO 0 Reserved 11:8 thd_lvl R/W 0 Receive FIFO Threshold Level          Set this field to the required number of bytes to trigger a receive FIFO threshold event. When the number of bytes in the receive FIFO is equal to or greater than this field, the hardware sets the I2Cn_INTFL0.rx_thd bit indicating a receive FIFO         threshold level event.                  0: 0 bytes or more in the receive FIFO causes a threshold event.         1: 1+ bytes in the receive FIFO triggers a receive threshold event (recommended minimum value).         \u2026         8: Receive FIFO threshold event only occurs when the receive FIFO is full. 7 flush R/W1O 0 Flush Receive FIFO         Write 1 to this field to initiate a receive FIFO flush, clearing all data in the receive FIFO. This field is automatically cleared by the hardware when the receive FIFO flush completes. Writing 0 has no effect.                  0: Receive FIFO flush complete or not active.         1: Flush the receive FIFO 6:1 - RO 0 Reserved 0 dnr R/W 0 Slave Mode Do Not Respond         Slave mode operation only. If the device has been addressed for a write operation, and there is still data in the receive FIFO, then:                  0: Always respond to an address match with an ACK and always respond to data bytes with a NACK.         1: NACK the address. <p>Table 14-14: I2C Receive Control 1 Register </p> I2C Receive Control 1 I2Cn_RXCTRL1 [0x0020] Bits Name Access Reset Description 31:12 - RO 0 Reserved 11:8 lvl R 0 Receive FIFO Byte Count Status         This field returns the number of bytes in the receive FIFO.                  0: 0 bytes (No data)         1: 1 byte         2: 2 bytes         3: 3 bytes         4: 4 bytes         5: 5 bytes         6: 6 bytes         7: 7 bytes         8: 8 bytes          7:0 cnt R/W 1 Receive FIFO Transaction Byte Count Configuration         When in master mode, write the number of bytes to be received in a transaction from 1 to 256. 0x00 represents 256.                  0: 256 byte receive transaction.         1: 1 byte receive transaction.         2: 2 byte receive transaction.         \u2026         255: 255 byte receive transaction.         This field is ignored when I2Cn_CTRL.irxm_en = 1. To receive more than 256 bytes, use I2Cn_CTRL.irxm_en = 1 <p>Table 14-15: I2C Transmit Control 0 Register </p> I2C Transmit Control 0 I2Cn_TXCTRL0 [0x0024] Bits Name Access Reset Description 31:12 - RO 0 Reserved 11:8 thd_val R/W 0 Transmit FIFO Threshold Level          This field sets the level for a transmit FIFO threshold event interrupt. If the number of bytes remaining in the transmit FIFO falls to this level or lower, the interrupt flag         I2Cn_INTFL0.thd_val is set, indicating a transmit FIFO Threshold Event occurred.                  0: 0 bytes remaining in the transmit FIFO triggers a transmit FIFO threshold event.         1: 1 byte or fewer remaining in the transmit FIFO triggers a transmit FIFO threshold event (recommended minimum value).         \u2026         7: 7 or fewer bytes remaining in the transmit FIFO triggers a transmit FIFO threshold event          7 flush R/W1O 0 Transmit FIFO Flush         A transmit FIFO flush clears all remaining data from the transmit FIFO.                  0: transmit FIFO flush is complete or not active.         1: Flush the transmit FIFO Note: The hardware automatically clears this bit to 0 after it is written to 1 when the flush is completed. <p>If I2Cn_INTFL0.tx_lockout\u00a0=\u00a01, then I2Cn_TXCTRL0.flush\u00a0=\u00a01.         </p> 6 - RO 0 Reserved 5 nack_flush_dis R/W 0 Transmit FIFO received NACK Auto Flush Disable         Various situations or conditions are described in this user guide that leads to the transmit FIFO being flushed and locked out (I2Cn_INTFL0.tx_lockout = 1).                  0: Received NACK at the end of a slave transmit operation enabled         1: Received NACK at the end of a slave transmit operation disabled. Note: upon entering transmit preload mode, the hardware automatically sets this bit to 0          <p>The software can subsequently set to any value desired (i.e., The hardware does not continuously force the bitfield to this value).</p> 4 rd_addr_flush_dis R/W 0 Transmit FIFO Slave Address Match Read Auto Flush Disable         Various situations or conditions are described in this user guide that leads to the transmit FIFO being flushed and locked out (I2Cn_INTFL0.tx_lockout = 1).                  0: Enabled.         1: Disabled.         <p>Note: upon entering transmit preload mode, the hardware automatically sets this bit to 1 </p> <p>The software can subsequently set to any value desired (i.e., The hardware does not continuously force the bitfield to this value).</p> 3 wr_addr_flush_dis R/W 0 Transmit FIFO Slave Address Match Write Auto Flush Disable         Various situations or conditions are described in this user guide that leads to the transmit FIFO being flushed and locked out (I2Cn_INTFL0.tx_lockout = 1).                  0: Enabled         1: Disabled.          <p>Note: upon entering transmit preload mode, the hardware automatically sets this bit to 1</p> <p>The software can subsequently set to any value desired (i.e., The hardware does not continuously force the bitfield to this value).</p> 2 gc_addr_flush_dis R/W 0 Transmit FIFO General Call Address Match Auto Flush Disable          Various situations or conditions are described in this user guide that leads to the transmit FIFO being flushed and locked out (I2Cn_INTFL0.tx_lockout = 1).                  0: Enabled.         1: Disabled.          <p>Note: upon entering transmit preload mode, the hardware automatically sets this bit to 1</p> <p>The software can subsequently set to any value desired (i.e., The hardware does not continuously force the bitfield to this value).</p> 1 tx_ready_mode R/W 0 Transmit FIFO Ready Manual Mode          0: The hardware controls the I2Cn_TXCTRL1.preload_rdy field.         1: The software control of the I2Cn_TXCTRL1.preload_rdy field.          0 preload_mode R/W 0 Transmit FIFO Preload Mode Enable          0: Normal operation. An address match in slave mode, or a general call address match, flushes and locks the transmit FIFO so it cannot be written and sets the I2Cn_INTFL0.tx_lockout field to 1.         1: transmit FIFO preload mode. An address match in slave mode, or a general call address match, does not lock the transmit FIFO and does not set I2Cn_INTFL0.tx_lockout. This allows the software to preload data into the transmit FIFO. The status of the I<sup>2</sup>C is controllable at I2Cn_TXCTRL1.preload_rdy. <p>Table 14-16: I2C Transmit Control 1 Register </p> I2C Transmit Control Register 1 I2Cn_TXCTRL1 [0x0028] Bits Name Access Reset Description 31:12 - RO 0 Reserved 11:8 lvl R 0 Transmit FIFO Byte Count Status          0: 0 bytes (No data)         1: 1 byte         2: 2 bytes         3: 3 bytes         4: 4 bytes         5: 5 bytes         6: 6 bytes         7: 7 bytes         8: 8 bytes (max value) 7:1 - RO 0 Reserved 0 preload_rdy R/W1O 1 Transmit FIFO Preload Ready Status         When transmit FIFO preload mode is enabled, I2Cn_TXCTRL0.preload_mode\u00a0=\u00a01, this bit is automatically cleared to 0. While this bit is 0, if the hardware receives a slave address match, a NACK is sent. Once the hardware is ready, the software must set this bit to 1, so the hardware sends an ACK on a slave address match. See Transmit FIFO Preloading for additional details. <p>When transmit FIFO preload mode is disabled, I2Cn_TXCTRL0.preload_mode\u00a0=\u00a01, this bit is forced to 1, and the hardware behaves normally.</p> <p>Table 14-17: I2C Data Register </p> I2C Data I2Cn_FIFO [0x002C] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 data R/W 0xFF FIFO Data  Reads from this register pop data off the receive FIFO. Writes to this register push data onto the transmit FIFO. Reading from an empty receive FIFO returns 0xFF. Writes to a full transmit FIFO are ignored. <p>Table 14-18: I2C Master Control Register </p> I2C Master Control I2Cn_MSTCTRL [0x0030] Bits Name Access Reset Description 31:11 - RO 0 Reserved 10:8 mcode R/W 0 MCODE         This field sets the master code used in Hs-Mode operation          7 ex_addr_en R/W 0 Slave Extended Addressing Enable          0: Send a 7-bit address to the slave.         1: Send a 10-bit address to the slave. 6:3 - RO 0 Reserved 2 stop R/W1O 0 Send STOP Condition          1: Send a STOP Condition at the end of the current transaction <p>Note: This bit is automatically cleared by the hardware when the STOP condition begins.</p> 1 restart R/W1O 0 Send Repeated START Condition         After sending data to a slave, the master may send another START to retain control of the bus.                  1: Send a repeated START condition to the slave instead of sending a STOP condition at the end of the current transaction. <p>Note: This bit is automatically cleared by the hardware when the repeated START condition begins.</p> 0 start R/W1O 0 Start Master Mode Transfer          1: Start master mode transfer <p>Note: This bit is automatically cleared by the hardware when the transfer is completed or aborted.</p> <p>Table 14-19: I2C SCL Low Control Register </p> I2C Clock Low Control I2Cn_CLKLO [0x0034] Bits Name Access Reset Description 31:9 - RO 0 Reserved 8:0 lo R/W 0x001 Clock Low Time In master mode, this configures the SCL low time.          t<sub>SCL_LO</sub>\u2004=\u2004f<sub>I2C_CLK</sub>\u2005\u00d7\u2005(lo\u2005+\u20051) <p>Note: 0 is not a valid setting for this field.</p> <p>Table 14-20: I2C SCL High Control Register </p> I2C Clock High Control I2Cn_CLKHI [0x0038] Bits Name Access Reset Description 31:9 - RO 0 Reserved 8:0 hi R/W 0x001 Clock High Time  In master mode, this configures the SCL high time.          <p>$$t_{SCL\\text{_}HI} =         \\frac{1}{f_{I2C\\text{_}CLK}} \\times (hi + 1)$$ <p>In both master and slave mode, this configures the time SCL is held low after new data is loaded from the transmit FIFO or after the software clears I2Cn_INTFL0.irxm during IRXM.</p> <p>Note: 0 is not a valid setting for this field.</p> <p>Table 14-21: I2C Hs-Mode Clock Control Register </p> I2C Hs-Mode Clock Control I2Cn_HSCLK [0x003C] Bits Name Access Reset Description 31:16 - R/W 0 Reserved 15:8 hi R/W 0 Hs-Mode Clock High Time This field sets the Hs-Mode clock high count. In slave mode, this is the time SCL is held high after data is output on SDA.     <p>Note: See SCL Clock Generation for Hs-Mode for details on the requirements for the Hs-Mode clock high and low times.</p> 7:0 lo R/W 0 Hs-Mode Clock Low Time This field sets the Hs-Mode clock low count. In slave mode, this is the time SCL is held low after data is output on SDA.         <p>Note: See SCL Clock Generation for Hs-Mode for details on the requirements for the Hs-Mode clock high and low times.</p> <p>Table 14-22: I2C Timeout Register </p> I2C Timeout I2Cn_TIMEOUT [0x0040] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:0 scl_to_val R/W 0 Bus Error SCL Timeout Period  Set this value to the number of I<sup>2</sup>C clock cycles desired to cause a bus timeout error. The peripheral timeout timer starts when it pulls SCL low. After the peripheral releases the line, if the line is not pulled high before the timeout number of I<sup>2</sup>C clock cycles, a bus error condition is set (I2Cn_INTFL0.to_err\u00a0=\u00a01), and the peripheral releases the         SCL and SDA lines                  0: Timeout disabled.         All other values result in a timeout calculation of: <p>$$t_{BUS\\text{_}TIMEOUT} =         \\frac{1}{f_{I2C\\text{_}CLK}} \\times         scl\\text{_}to\\text{_}val$$ <p>Note: The timeout counter monitors the I<sup>2</sup>C peripheral's driving of the SCL pin, not an external I<sup>2</sup>C device driving the SCL pin.</p> <p>Table 14-23: I2C DMA Register </p> I2C DMA I2Cn_DMA [0x0048] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1 rx_en R/W 0 Receive DMA Channel Enable          0: Disable         1: Enable 0 tx_en R/W 0 Transmit DMA Channel Enable          0: Disable         1: Enable  <p>Table 14-24: I2C Slave Address Register </p> I2C Slave Address I2Cn_SLAVE [0x004C] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 ext_addr_en R/W 0 Slave Mode Extended Address Length Select          0: 7-bit addressing         1: 10-bit addressing 14:10 - RO 0 Reserved 9:0 addr R/W 0 Slave Mode Slave Address          In slave mode operation (I2Cn_CTRL.mstr\u00a0=\u00a00), set this field to the slave address for the I<sup>2</sup>C port. For 7-bit addressing, the address occupies the least significant 7 bits. For 10-bit addressing, the 9-bits of address occupies the most significant 9 bit,         and the R/W bit occupies the least significant bit.         <p>Note: I2Cn_SLAVE.ext_addr_en controls if this field is a 7-bit or 10-bit address.</p>"},{"location":"inter-ic-interface-i2s/","title":"Inter-IC Interface (I\u00b2S)","text":"<p>I\u00b2S is a serial audio interface for communicating pulse-code modulation (PCM) encoded streams between devices. The peripheral supports both master and slave modes.</p> <p>Key features:</p> <ul> <li>Stereo (2 channel) and mono (left or right channel option) formats</li> <li>Separate DMA channels for transmit and receive.</li> <li> <p>Flexible timing:</p> <ul> <li>Configurable sampling rate from 165536 to 1 of the I2S input clock.</li> </ul> </li> <li> <p>Flexible data format:</p> <ul> <li>The number of bits per data word can be selected from 1 to 32, typically 8, 16, 24, or 32-bit width.</li> <li> <p>Feature enhancement not in the I2S specification.</p> <ul> <li>Word/Channel select polarity control.</li> <li>First bit position selection.</li> <li>Selectable FIFO data alignment to the MSB or the LSB of the sample</li> <li>Sample size less than the word size with adjustment to MSB or LSB of the word.</li> <li>Optional sign extension.</li> </ul> </li> </ul> </li> <li> <p>Full-duplex serial communication with separate I2S serial data input and serial data output pins</p> </li> </ul>"},{"location":"inter-ic-interface-i2s/#instances","title":"Instances","text":"<p>Table 15-1: MAX78000 I2S Instances</p>"},{"location":"inter-ic-interface-i2s/#i2s-bus-lines-and-definitions","title":"I2S Bus Lines and Definitions","text":""},{"location":"inter-ic-interface-i2s/#details","title":"Details","text":""},{"location":"inter-ic-interface-i2s/#master-and-slave-mode-configuration","title":"Master and Slave Mode Configuration","text":""},{"location":"inter-ic-interface-i2s/#clocking","title":"Clocking","text":""},{"location":"inter-ic-interface-i2s/#bclk-generation-for-master-mode","title":"BCLK Generation for Master Mode","text":""},{"location":"inter-ic-interface-i2s/#lrclk-period-calculation","title":"LRCLK Period Calculation","text":""},{"location":"inter-ic-interface-i2s/#data-formatting","title":"Data Formatting","text":""},{"location":"inter-ic-interface-i2s/#sample-size","title":"Sample Size","text":""},{"location":"inter-ic-interface-i2s/#word-select-polarity","title":"Word Select Polarity","text":""},{"location":"inter-ic-interface-i2s/#first-bit-location-control","title":"First Bit Location Control","text":""},{"location":"inter-ic-interface-i2s/#sample-adjustment","title":"Sample Adjustment","text":""},{"location":"inter-ic-interface-i2s/#stereomono-configuration","title":"Stereo/Mono Configuration","text":""},{"location":"inter-ic-interface-i2s/#transmit-and-receive-fifos","title":"Transmit and Receive FIFOs","text":""},{"location":"inter-ic-interface-i2s/#fifo-data-width","title":"FIFO Data Width","text":""},{"location":"inter-ic-interface-i2s/#transmit-fifo","title":"Transmit FIFO","text":""},{"location":"inter-ic-interface-i2s/#receive-fifo","title":"Receive FIFO","text":""},{"location":"inter-ic-interface-i2s/#fifo-word-control","title":"FIFO Word Control","text":""},{"location":"inter-ic-interface-i2s/#fifo-data-alignment","title":"FIFO Data Alignment","text":""},{"location":"inter-ic-interface-i2s/#typical-audio-configurations","title":"Typical Audio Configurations","text":""},{"location":"inter-ic-interface-i2s/#interrupt-events","title":"Interrupt Events","text":""},{"location":"inter-ic-interface-i2s/#receive-fifo-overrun","title":"Receive FIFO Overrun","text":""},{"location":"inter-ic-interface-i2s/#receive-fifo-threshold","title":"Receive FIFO Threshold","text":""},{"location":"inter-ic-interface-i2s/#transmit-fifo-half-empty","title":"Transmit FIFO Half-Empty","text":""},{"location":"inter-ic-interface-i2s/#transmit-fifo-one-entry-remaining","title":"Transmit FIFO One Entry Remaining","text":""},{"location":"inter-ic-interface-i2s/#direct-memory-access","title":"Direct Memory Access","text":""},{"location":"inter-ic-interface-i2s/#block-operation","title":"Block Operation","text":""},{"location":"inter-ic-interface-i2s/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 15-9: I2S Register Summary</p>"},{"location":"inter-ic-interface-i2s/#register-details","title":"Register Details","text":"<p>Table 15-10: I2S Control 0 Register</p>"},{"location":"interrupts-exceptions/","title":"Interrupts and Exceptions","text":"<p>Interrupts and exceptions are managed by either the Arm Cortex-M4 with FPU NVIC or the RV32 interrupt controller. The NVIC manages the interrupts, exceptions, priorities, and masking. Table 5-1 and Table 5\u20112 detail the MAX78000\u2019s interrupt vector tables for the CM4 and RV32 processors, respectively, and describe each exception and interrupt.</p>"},{"location":"interrupts-exceptions/#cm4-interrupt-and-exception-features","title":"CM4 Interrupt and Exception Features","text":"<ul> <li>8 programmable priority levels</li> <li>Nested exception and interrupt support</li> <li>Interrupt masking</li> </ul>"},{"location":"interrupts-exceptions/#cm4-interrupt-vector-table","title":"CM4 Interrupt Vector Table","text":"<p>Table 5-1 lists the interrupt and exception table for the MAX78000\u2019s CM4 core. There are 119 interrupt entries for the MAX78000, including reserved for future use interrupt placeholders. Including the 15 system exceptions for the Arm Cortex-M4 with FPU, the total number of entries is 134.</p> <p>Table 5-1: MAX78000 CM4 Interrupt Vector Table </p> Exception (Interrupt) Number Offset Name Description 1 [0x0004] Reset_IRQn Reset 2 [0x0008] NonMaskableInt_IRQn Non-Maskable Interrupt 3 [0x000C] HardFault_IRQn Hard Fault 4 [0x0010] MemoryManagement_IRQn Memory Management Fault 5 [0x0014] BusFault_IRQn Bus Fault 6 [0x0018] UsageFault_IRQn Usage Fault 7:10 [0x001C]-[0x0028] - Reserved 11 [0x002C] SVCall_IRQn Supervisor Call Exception 12 [0x0030] DebugMonitor_IRQn Debug Monitor Exception 13 [0x0034] - Reserved 14 [0x0038] PendSV_IRQn Request Pending for System Service 15 [0x003C] SysTick_IRQn System Tick Timer 16 [0x0040] PF_IRQn Power Fail interrupt 17 [0x0044] WDT0_IRQn Windowed Watchdog Timer 0 Interrupt 18 [0x0048] - Reserved 19 [0x004C] RTC_IRQn Reserved 20 [0x0050] TRNG_IRQn True Random Number Generator Interrupt 21 [0x0054] TMR0_IRQn Timer 0 Interrupt 22 [0x0058] TMR1_IRQn Timer 1 Interrupt 23 [0x005C] TMR2_IRQn Timer 2 Interrupt 24 [0x0060] TMR3_IRQn Timer 3 Interrupt 25 [0x0064] TMR4_IRQn Timer 4 (LPTMR0) Interrupt 26 [0x0068] TMR5_IRQn Timer 5 (LPTMR1) Interrupt 27:28 [0x006C]:[0x0070] - Reserved 29 [0x0074] I2C0_IRQn I<sup>2</sup>C Port 0 Interrupt 30 [0x0078] UART0_IRQn UART Port 0 Interrupt 31 [0x007C] UART1_IRQn UART Port 1 Interrupt 32 [0x0080] SPI1_IRQn SPI Port 1 Interrupt 33:35 [0x0084]:[0x008C] - Reserved 36 [0x90] ADC_IRQn ADC Interrupt 37:38 [0x0094]:[0x0098] - Reserved 39 [0x009C] FLC0_IRQn Flash Controller 0 Interrupt 40 [0x00A0] GPIO0_IRQn GPIO Port 0 Interrupt 41 [0x00A4] GPIO1_IRQn GPIO Port 1 Interrupt 42 [0x00A8] GPIO2_IRQn GPIO Port 2 Interrupt 43 [0x00AC] - Reserved 44 [0x00B0] DMA0_IRQn DMA0 Interrupt 45 [0x00B4] DMA1_IRQn DMA1 Interrupt 46 [0x00B8] DMA2_IRQn DMA2 Interrupt 47 [0x00BC] DMA3_IRQn DMA3 Interrupt 48:49 [0x00C0 : 0x00C4] - Reserved 50 [0x00C8] UART2_IRQn UART Port 2 Interrupt 51 [0x00CC] - Reserved 52 [0x00D0] I2C1_IRQn I<sup>2</sup>C Port 1 Interrupt 53:68 [0x00D4]: [0x0110] - Reserved 69 [0x0114] WUT_IRQn Wakeup Timer Interrupt 70 [0x0118] GPIOWAKE_IRQn GPIO Wakeup Interrupt 71 [0x011C] - Reserved 72 [0x0120] SPI0_IRQn SPI Port 0 Interrupt 73 [0x0124] WDT1_IRQn Low Power Watchdog Timer 0 (WDT1) Interrupt 74 [0x0128] - Reserved 75 [0x012C] PT_IRQn Pulse Train Interrupt 76:77 [0x0130]:[0x0134] - Reserved 78 [0x0138] I2C2_IRQn I<sup>2</sup>C Port 2 Interrupt 79 [0x013C] RISCV_IRQn CPU1 (RV32) Interrupt 80:82 [0x0140]:[0x0148] - Reserved 83 [0x014C] OWM_IRQn 1-Wire Master Interrupt 84:97 [0x0150]:[0x0184] - Reserved 98 [0x0188] ECC_IRQn Error Correction Coding Block Interrupt 99 [0x018C] DVS_IRQn Digital Voltage Scaling Interrupt 100 [0x0190] SIMO_IRQn Single Input Multiple Output Interrupt 101:103 [0x0194]:[0x019C] - Reserved 104 [0x01A0} UART3_IRQn UART3 (LPUART0) Interrupt 105:106 [0x01A4]:[0x01A8] - Reserved 107 [0x01AC] PCIF_IRQn Parallel Camera Interface Interrupt 108:112 [0x01B0]:[0x01C0] - Reserved 113 [0x01C4] AES_IRQn AES Interrupt 114 [0x01C8] - Reserved 115 [0x01CC] I2S_IRQn I<sup>2</sup>S Interrupt 116 [0x01D0] CNN_FIFO_IRQn CNN FIFO Interrupt 117 [0x01D4] CNN_IRQn CNN Interrupt 118 [0x01D8] - Reserved 119 [0x01DC] LPCMP_IRQn Low Power Comparator Interrupt"},{"location":"interrupts-exceptions/#rv32-interrupt-vector-table","title":"RV32 Interrupt Vector Table","text":"<p>Table 5\u20112 lists the interrupt and exception table for the MAX78000\u2019s RV32 core.</p> <p>Table 5-2: MAX78000 RV32 Interrupt Vector Table </p> Exception (Interrupt) Number Name Description 4 PF_IRQn Power Fail/System Fault/CM4/Bus Fault 5 WDT0_IRQn Windowed Watchdog Timer 0 Interrupt 6 GPIOWAKE_IRQn GPIO Wakeup Interrupt 7 RTC_IRQn RTC Interrupt 8 TMR0_IRQn Timer 0 Interrupt 9 TMR1_IRQn Timer 1 Interrupt 10 TMR2_IRQn Timer 2 Interrupt 11 TMR3_IRQn Timer 3 Interrupt 12 TMR4_IRQn Timer 4 (LPTMR0) Interrupt 13 TMR5_IRQn Timer 5 (LPTMR1) Interrupt 14 I2C0_IRQn I<sup>2</sup>C Port 0 Interrupt 15 UART0_IRQn UART Port 0 Interrupt 16 - Reserved 17 I2C1_IRQn I<sup>2</sup>C Port 1 Interrupt 18 UART1_IRQn UART Port 1 Interrupt 19 UART2_IRQn UART Port 2 Interrupt 20 I2C2_IRQn I<sup>2</sup>C Port 2 Interrupt 21 UART3_IRQn UART3 (LPUART0) Interrupt 22 SPI1_IRQn SPI Port 1 Interrupt 23 WUT_IRQn Wakeup Timer Interrupt 24 FLC0_IRQn Flash Controller 0 Interrupt 25 GPIO0_IRQn GPIO Port 0 Interrupt 26 GPIO1_IRQn GPIO Port 1 Interrupt 27 GPIO2_IRQn GPIO Port 2 Interrupt 28 DMA0_IRQn DMA0 Interrupt 29 DMA1_IRQn DMA1 Interrupt 30 DMA2_IRQn DMA2 Interrupt 31 DMA3_IRQn DMA3 Interrupt 32:45 - Reserved 46 AES_IRQn AES Interrupt 47 TRNG_IRQn TRNG Interrupt 48 WDT1_IRQn Watchdog Timer 1 (LPWDT0) Interrupt 49 DVS_IRQn Digital Voltage Scaling Interrupt 50 SIMO_IRQn Single Input Multiple Output Interrupt 51 - Reserved 52 PT_IRQn Pulse Train Interrupt 53 ADC_IRQn ADC Interrupt 54 OWM_IRQn 1-Wire Master Interrupt 55 I2S_IRQn I<sup>2</sup>S Interrupt 56 CNN_FIFO_IRQn CNN TX FIFO Interrupt 57 CNN_IRQn CNN Interrupt 58 - Reserved 59 PCIF_IRQn Parallel Camera Interface Interrupt"},{"location":"memory-register-mapping-access/","title":"Memory, Register, Mapping, and Access","text":""},{"location":"memory-register-mapping-access/#overview","title":"Overview","text":"<p>The Arm Cortex-M4 architecture defines a standard memory space for unified code and data access. This memory space is addressed in units of single bytes but is most typically accessed in 32-bit (4 byte) units. It may also be accessed, depending on the implementation, in 8-bit (1 byte) or 16-bit (2 byte) widths. The total range of the memory space is 32 bits wide (4GB addressable total), from addresses 0x0000 0000 to 0xFFFF FFFF.</p> <p>However, it is important to note that the architectural definition does not require the entire 4GB memory range to be populated with addressable memory instances.</p> <p>Figure 3-1: CM4 Code Memory Mapping </p> <p></p> <p>Figure 3-2: RISC-V IBUS Code Memory Mapping </p> <p></p> <p>Figure 3-3: CM4 Peripheral and Data Memory Mapping </p> <p></p> <p>Figure 3-4: RV32 Peripheral and Data Memory Mapping </p> <p></p>"},{"location":"memory-register-mapping-access/#standard-memory-regions","title":"Standard Memory Regions","text":"<p>Several standard memory regions are defined for the Arm Cortex-M4 (CPU0) and RISC-V (CPU1) architectures; many of these are optional for the system integrator. At a minimum, the MAX78000 must contain some code and data memory for application software, stack, and variable space for CPU0.</p>"},{"location":"memory-register-mapping-access/#code-space","title":"Code Space","text":"<p>The code space area of memory is designed to contain the primary memory used for code execution by the device. This memory area is defined from byte address range 0x0000 0000 to 0x1FFF FFFF (0.5GB maximum). The Cortex-M4 core and Arm debugger use two different standard core bus masters to access this memory area. The I-Code AHB bus master is used for instruction decode fetching from code memory, while the D-Code AHB bus master is used for data fetches from code memory. This is arranged so that data fetches avoid interfering with instruction execution. Additionally, the RV32 uses the D-BUS to access code memory in this area and the I-Bus to access data fetches from the code memory.</p> <p>The MAX78000 code memory mapping is illustrated in Figure 3-1 and Figure 3-2. The code space memory area contains the main internal flash memory, which holds most of the software executed on the device. The internal flash memory is mapped into both code and data space from 0x1000 0000 to 0x1007 FFFF. The main program flash memory is 512KB and consists of 64 logical pages of 8,192 Bytes per page.</p> <p>This program memory area must also contain the default system vector table and the initial settings for all system exception handlers and interrupt handlers for the CM4 core. The reset vector for the device is 0x0000 0000 and contains the device ROM code that transfers execution to user code at address 0x1000 0000.</p> <p>The code space memory on the MAX78000 also contains the mapping for the flash information block, from 0x1080 0000 to 0x1080 3FFF. However, this mapping is only present during production test; it is disabled once the information block has been loaded with valid data and the info block lockout option has been set. This memory is accessible for data reads only and cannot be used for code execution. See Information Block Flash Memory for additional details.</p>"},{"location":"memory-register-mapping-access/#internal-cache-memory","title":"Internal Cache Memory","text":"<p>The MAX78000 includes a dedicated unified internal cache controller with 16,384 bytes of internal cache memory (ICC0) for the CM4 core. Optionally, sysram3 can be used as a unified internal cache controller (ICC1) for the RV32.</p> <p>The unified internal cache memory is used to cache data and instructions fetched through the I-Code bus for the CM4 or the IBUS for the RV32 from the internal flash memory. See section Unified Internal Cache Controller for detailed instructions on enabling the unified internal cache controllers.</p>"},{"location":"memory-register-mapping-access/#information-block-flash-memory","title":"Information Block Flash Memory","text":"<p>The information block is a separate area of the internal flash memory and is 16,384 Bytes. The information block is used to store trim settings (option configuration and analog trim) and other nonvolatile device-specific information. The information block also contains the device's unique serial number (USN). The USN is a 104-bit field. USN bits 0 thru 7 contain the die revision.</p> <p>Figure 3-5: Unique Serial Number Format </p> <p></p> <p>Reading the USN requires unlocking the information block. Unlocking the information block does not enable write access to the block but allows the contents of the USN to be read from the block. Unlock the information block using the following steps:</p> <ol> <li>Write 0x3A7F 5CA3 to FLC_ACTRL.</li> <li>Write 0xA1E3 4F20 to FLC_ACTRL.</li> <li>Write 0x9608 B2C1 to FLC_ACTRL.</li> <li>The information block is now read-only accessible.</li> </ol> <p>To re-lock the information block to prevent access, write any 32-bit word to FLC_ACTRL.</p>"},{"location":"memory-register-mapping-access/#sram-space","title":"SRAM Space","text":"<p>The SRAM area of memory is intended to contain the primary SRAM data memory of the device and is defined from byte address range 0x2000 0000 to 0x3FFF FFFF (0.5GB maximum). This memory can be used for general-purpose variable and data storage, code execution, the CM4 stack, and the RV32 stack. The MAX78000 CM4's data memory mapping is illustrated in Figure 3-1. The MAX78000 RV32's data memory mapping is illustrated in Figure 3-4.</p> <p>The system SRAM configuration is defined in Table 3-1. Additionally, the CNN memory is covered in the CNN chapter in the section Memory Configuration.</p> <p>The SRAM area contains the main system RAM. The size of the internal general-purpose data SRAM is 128KB. The SRAM is divided into four blocks and consists of the contiguous address range from 0x2000 0000 to 0x2001 FFFF. The SRAM area on the MAX78000 can be used for data storage and code execution by the CM4. The RV32 is limited to sysram2 and sysram3 for code and data storage.</p> <p>Note: After a POR, the CM4 has access to all four SRAM regions. sysram2 and sysram3 can be configured to restrict access from the CM4 to prevent unintended modifications of these SRAM instances by the CM4. Set the FCR_URVCTRL.memsel field to 1 to set the RV32 core as the exclusive master for sysram2 and sysram3.</p> <p>Code stored in the SRAM is accessed directly for execution (using the system bus) and is not cached. The SRAM is also where the CM4 and RV32 stack must be located, as it is the only general-purpose SRAM on the device capable of this function.</p> <p>Table 3-1: System SRAM Configuration </p> System RAM Block # Size Start Address End Address CM4 Accessible RV32 Accessible sysram0 32KB 0x2000 0000 0x2000 7FFF \u2713 No sysram1 32KB 0x2000 8000 0x2000 FFFF \u2713 No sysram2 48KB 0x2001 0000 0x2001 BFFF Configurable \u2713 sysram3 16KB 0x2001 C000 0x2001 FFFF Configurable \u2713 (Optional ICC1) <p>The MAX78000 specific AHB Bus Masters can access the SRAM to use as general storage or working space.</p> <p>The entirety of the SRAM space on the MAX78000 is contained within the dedicated Arm Cortex-M4 SRAM bit-banding region from 0x2000 0000 to 0x200F FFFF (1MB maximum for bit-banding). This means that the CPU can access the entire SRAM either using standard byte/word/doubleword access or using bit-banding operations. The bit-banding mechanism allows any single bit of any given SRAM byte address location to be set, cleared, or read individually by reading from or writing to a corresponding doubleword (32-bit wide) location in the bit-banding alias area.</p> <p>The alias area for the SRAM bit-banding is located beginning at 0x2200 0000 and is a total of 32MB maximum, which allows the entire 128KB bit banding area to be accessed. Each 32-bit (4 byte aligned) address location in the bit-banding alias area translates into a single bit access (read or write) in the bit-banding primary area. Reading from the location performs a single bit read while writing either a 1 or 0 to the location performs a single bit set or clear.</p> <p>Note: The Arm Cortex-M4 core translates the access in the bit-banding alias area into the appropriate read cycle (for a single bit read) or a read-modify-write cycle (for a single bit set or clear) of the bit-banding primary area. Bit-banding is a core function (i.e., not a function of the SRAM interface layer or the AHB bus layer) and thus is only applicable to accesses generated by the core. Reads and writes to the bit-banding alias area by other (non-Arm-core) bus masters does not trigger a bit-banding operation and instead results in an AHB bus error.</p>"},{"location":"memory-register-mapping-access/#peripheral-space","title":"Peripheral Space","text":"<p>The peripheral space area of memory is intended to map control registers, internal buffers, and other features needed for the software control of non-core peripherals. It is defined from byte address range 0x4000 0000 to 0x5FFF FFFF (0.5GB maximum). On the MAX78000, all device-specific module registers are mapped to this memory area and any local memory buffers or FIFOs that are required by modules.</p> <p>As with the SRAM region, there is a dedicated 1MB area at the bottom of this memory region (from 0x4000 0000 to 0x400F FFFF) used for bit-banding operations by the Arm core. Four-byte-aligned read/write operations in the peripheral bit-banding alias area (32MB in length, from 0x4200 0000 to 0x43FF FFFF) are translated by the core into read/mask/shift or read/modify/write operation sequences to the appropriate byte location in the bit-banding area.</p> <p>Note: The bit-banding operation within peripheral memory space is, like bit-banding function in SRAM space, a core remapping function. As such, it is only applicable to operations performed directly by the Arm core. If another memory bus master accesses the peripheral bit-banding alias region, the bit-banding remapping operation does not occur. In this case, the bit-banding alias region appears to be a non-implemented memory area (causing an AHB bus error).</p> <p>On the MAX78000, access to the region containing most peripheral registers (0x4000 0000 to 0x400F FFFF) goes from the AHB bus through an AHB-to-APB bridge enabling the peripheral modules to operate on the lower power APB bus matrix. This also ensures that peripherals with slower response times do not tie up bandwidth on the AHB bus, which must necessarily have a faster response time since it handles main application instruction and data fetching.</p>"},{"location":"memory-register-mapping-access/#aes-key-and-working-space-memory","title":"AES Key and Working Space Memory","text":"<p>The AES key memory and working space for AES operations (including input and output parameters) are in a dedicated register file memory tied to the AES engine block. This AES memory is mapped into AHB space for rapid software access.</p>"},{"location":"memory-register-mapping-access/#system-area-private-peripheral-bus","title":"System Area (Private Peripheral Bus)","text":"<p>The system area (private peripheral bus) memory space contains register areas for functions that are only accessible by the Arm core itself (and the Arm debugger, in certain instances). It is defined from byte address range 0xE000 0000 to 0xE00F FFFF. This APB bus is restricted and can only be accessed by the Arm core and core-internal functions. It cannot be accessed by other modules which implement AHB memory masters, such as the DMA interface.</p> <p>In addition to being restricted to the core, application software can only access this area when running in privileged execution mode (instead of the standard user thread execution mode). This helps ensure that critical system settings controlled in this area are not altered inadvertently or by errant code that should not access this area.</p> <p>Core functions controlled by registers mapped to this area include the SysTick timer, debug and tracing functions, the nested vector interrupt controller (NVIC), and the flash breakpoint controller.</p>"},{"location":"memory-register-mapping-access/#ahb-interfaces","title":"AHB Interfaces","text":"<p>The following sections detail memory accessibility on the AHB and the organization of AHB master and slave instances.</p>"},{"location":"memory-register-mapping-access/#arm-core-ahb-interfaces","title":"Arm Core AHB Interfaces","text":""},{"location":"memory-register-mapping-access/#i-code","title":"I-Code","text":"<p>The Arm core uses the I-Code AHB master for instruction fetching from memory instances located in code space from byte addresses 0x0000 0000 to 0x1FFF FFFF. This bus master is used to fetch instructions from the internal flash memory.</p> <p>Instructions fetched by this bus master are returned by the cache, which in turn triggers a cache line fill cycle to fetch instructions from the internal flash memory when a cache miss occurs.</p>"},{"location":"memory-register-mapping-access/#d-code","title":"D-Code","text":"<p>The Arm core uses the D-Code AHB master for data fetches from memory instances in code space from byte addresses 0x0000 0000 to 0x1FFF FFFF. This bus master has access to the internal flash memory and the information block.</p>"},{"location":"memory-register-mapping-access/#system","title":"System","text":"<p>The Arm core uses the system AHB master for all instruction fetches, and data read and write operations involving the SRAM data cache. The APB mapped peripherals (through the AHB-to-APB bridge) and AHB mapped peripheral and memory areas are also accessed using this bus master.</p>"},{"location":"memory-register-mapping-access/#ahb-slaves","title":"AHB Slaves","text":""},{"location":"memory-register-mapping-access/#standard-dma","title":"Standard DMA","text":"<p>The standard DMA AHB slave has access to all non-core memory areas accessible by the system bus. The standard DMA does not have access to the internal flash memory or Information blocks.</p>"},{"location":"memory-register-mapping-access/#cnn-and-cnn-tx-fifo","title":"CNN and CNN TX FIFO","text":"<p>The CNN and CNN TX FIFO AHB slaves have access to all non-core memory areas accessible by the system bus. They do not have access to the internal flash memory or information blocks.</p>"},{"location":"memory-register-mapping-access/#spio","title":"SPIO","text":"<p>The SPI0 AHB slave has access to all non-core memory areas accessible by the system bus. SPI0 does not have access to the internal flash memory or information blocks.</p>"},{"location":"memory-register-mapping-access/#ahb-slave-base-address-map","title":"AHB Slave Base Address Map","text":"<p>Table 3-2 contains the base address for each of the AHB slave peripherals. The base address for a given peripheral is the start of the register map for the peripheral. For a given peripheral, the address for a register within the peripheral is defined as the peripheral's AHB base address plus the register's offset.</p> <p>Table 3-2: AHB Slave Base Address Map </p> AHB Slave Register Name Register Prefix AHB Base Address AHB End Address SPI0 SPI0_ 0x400B E000 0x400B E3FF CNN TX FIFO CNN_FIFO_ 0x400C 0400 0x400C 0400"},{"location":"memory-register-mapping-access/#peripheral-register-map","title":"Peripheral Register Map","text":""},{"location":"memory-register-mapping-access/#apb-peripheral-base-address-map","title":"APB Peripheral Base Address Map","text":"<p>Table 3-3 contains the base address for each of the APB mapped peripherals. The base address for a given peripheral is the start of the register map for the peripheral. For a given peripheral, the address for a register within the peripheral is defined as the APB peripheral base address plus the registers offset.</p> <p>Table 3-3: APB Peripheral Base Address Map </p> Peripheral Register Name Register Prefix APB Base Address APB End Address Global ControlGCR_0x4000 00000x4000 03FF System InterfaceSIR_0x4000 04000x4000 07FF Function ControlFCR_0x4000 08000x4000 0BFF Watchdog Timer 0WDT0_0x4000 30000x4000 33FF Dynamic Voltage Scaling ControllerDVS_0x4000 3C000x4000 3C3F Single Input Multiple OutputSIMO_0x4000 44000x4000 47FF Trim System InitializationTRIMSIR_0x4000 54000x4000 57FF General Control FunctionGCFR_0x4000 58000x4000 5BFF Real time ClockRTC_0x4000 60000x4000 63FF Wakeup TimerWUT_0x4000 64000x4000 67FF Power SequencerPWRSEQ_0x4000 68000x4000 6BFF Miscellaneous ControlMCR_0x4000 6C000x4000 6FFF AESAES_0x4000 74000x4000 77FF AES KeyAESKEY_0x4000 78000x4000 7BFF GPIO Port 0GPIO0_0x4000 80000x4000 8FFF GPIO Port 1GPIO1_0x4000 90000x4000 9FFF Parallel Camera InterfacePCIF_0x4000 E0000x4000 EFFF CRCCRC_0x4000 F0000x4000 FFFF Timer 0TMR0_0x4001 00000x4001 0FFF Timer 1TMR1_0x4001 10000x4001 1FFF Timer 2TMR2_0x4001 20000x4001 2FFF Timer 3TMR3_0x4001 30000x4001 3FFF I2C 0I2C0_0x4001 D0000x4001 DFFF I2C 1I2C1_0x4001 E0000x4001 EFFF I2C 2I2C2_0x4001 F0000x4001 FFFF Standard DMADMA_0x4002 80000x4002 8FFF Flash Controller 0FLC0_0x4002 90000x4002 93FF Instruction-Cache Controller 0 (CM4)ICC0_0x4002 A0000x4002 A7FF Instruction Cache Controller 1 (RV32)ICC1_0x4002 A8000x4002 AFFF ADCADC_0x4003 40000x4003 4FFF Pulse Train EnginePT_0x4003 C0000x4003 C09F 1-Wire MasterOWM0_0x4003 D0000x4003 DFFF SemaphoreSEMA_0x4003 E0000x4003 EFFF UART 0UART0_0x4004 20000x4004 2FFF UART 1UART1_0x4004 30000x4004 3FFF UART 2UART2_0x4004 40000x4004 4FFF SPI1SPI1_0x4004 60000x4004 7FFF TRNGTRNG_0x4004 D0000x4004 DFFF I2SI2S_0x4006 00000x4006 0FFF Low Power General ControlLPGCR_0x4008 00000x4008 03FF GPIO Port 2GPIO2_0x4008 04000x4008 05FF Low Power Watchdog Timer 0 (WDT1)WDT1_0x4008 08000x4008 0BFF Low Power Timer 4TMR4_0x4008 0C000x4008 0FFF Low Power Timer 5TMR5_0x4008 10000x4008 13FF Low Power UART 0 (UART3)UART3_0x4008 14000x4008 17FF Low Power ComparatorLPCMP_0x4008 80000x4008 83FF CNN Global ControlCNN_0x5000 00000x500F FFFF CNNx16 Quadrant 0CNNx16_0_0x5010 00000x504F FFFF CNNx16 Quadrant 1CNNx16_1_0x5050 00000x508F FFFF CNNx16 Quadrant 2CNNx16_2_0x5090 00000x50CF FFFF CNNx16 Quadrant 3CNNx16_3_0x50D0 00000x510F FFFF"},{"location":"memory-register-mapping-access/#error-correction-coding-ecc-module","title":"Error Correction Coding (ECC) Module","text":"<p>This device features an Error Correction Coding (ECC) module that helps ensure data integrity by detecting and correcting bit corruption of the system RAM0 (sysram0) memory array. More specifically, the ECC module is a single error-correcting, double error detecting (SEC-DED). It corrects any single bit flip, detects two bit errors, and features a transparent zero wait state operation for reads.</p> <p>The ECC works by creating check bits for all data written to sysram0. These check bits are then stored along with the data. During a read, both the data and check bits are used to determine if one or more bits have become corrupt. If a single bit has been corrupted, this can be corrected. If two bits have been corrupted, it is detected but not corrected.</p> <p>If only one bit is determined to be corrupt, reads contain the \"corrected\" value. Reading memory does not correct the error value stored at the read memory location. It is up to the software to determine the appropriate time and method to write the correct data to memory. It is strongly recommended that the software correct the memory as soon as possible to minimize the chance of a second bit from becoming corrupt, resulting in data loss. Since ECC error checking occurs only during a read operation, it is recommended that the application periodically reads critical memory so that errors can be identified and corrected.</p>"},{"location":"memory-register-mapping-access/#sram","title":"SRAM","text":"<p>A check bit RAM is used to store sysram0's check bits, enabling ECC SEC-DED for sysram0. The check bit RAM is not mapped to the user memory space and is unavailable for application usage.</p>"},{"location":"memory-register-mapping-access/#limitations","title":"Limitations","text":"<p>Any read from non-initialized memory can trigger an ECC error since the random check bits most likely do not match the random data bits contained in the memory. Writing sysram0 to all zeroes before enabling ECC functionality can prevent this at the expense of the time required. To zeroize sysram0, write GCR_MEMZ.ram0 to 1.</p>"},{"location":"overview/","title":"Overview","text":"<p>Info</p> <p>The MAX78000 User Guide on this website is preliminary. To access the full document, refer to MAX7800 User Guide </p> <p>The MAX78000 is a new breed of low-power microcontrollers built to thrive in the rapidly evolving AI at the edge market. These products include Maxim's proven ultra-low-power MCU IP along with deep neural network AI acceleration.</p> <p>The MAX78000 is an advanced system-on-chip featuring an Arm\u00ae Cortex\u00ae-M4 with FPU CPU to efficiently compute complex functions and algorithms with integrated power management. It also includes a 442KB weight CNN accelerator. The devices offer large on-chip memory with 512KB flash and up to 128KB SRAM. Multiple high-speed and low-power communications interfaces are supported, including high-speed SPI, I2C serial interface, and LPUART. Additional low-power peripherals include flexible low-power timers (LPTMR) and analog comparators.</p> <p>The high-level block diagram for the MAX78000 is shown in Figure 2-1.</p> <p>Figure 2-1: MAX78000 Block Diagram </p> <p></p>"},{"location":"revision/","title":"Revision History","text":""},{"location":"revision/#online-document-revision-history","title":"Online Document Revision History","text":"REVISION NUMBER REVISION DATE DESCRIPTION"},{"location":"revision/#offline-document-revision-history","title":"Offline Document Revision History","text":"REVISION NUMBER REVISION DATE DESCRIPTION 0 07/2021 Initial release 1 03/2024          Added I2C slave address steps for operating as a slave device. See Slave Mode Operation for details.          Updated WDT sequence to show 8-bit writes. See WDT Feed Sequence for details.          Updated WDT window threshold fields and counter fields to indicate watchdog timer must be disabled for changing or reading. See WDTn_CTRL register for details.          Updated PWM Mode (3) to show PWM diagram.          Added Compare Mode (5) for wake-up timer.          Updated DAP interface pins to P0.28 and P0.29 in Table 8-1.          Marked flash controller registers as only reset on POR. See Flash Registers.          Removed GCR_RST0.smphr, use GCR_RST1.smphr instead.          Updated Table 20-1 to show correct WUT_CTRL.pres values for prescalers of 512, 1024, 2048, and 4096.          Removed package specific information from Table 17-1.          Fixed conditions in Table 18-2 to show when the RTC_TODA and RTC_SSECA registers are writable.          Removed GCR_SYSCTRL.flash_bank_flip field.          Corrected Table 26-1 to match published data sheet."},{"location":"semaphore/","title":"Semaphore","text":"<p>The semaphore peripheral allows multiple cores in a system to cooperate when accessing shared resources. The peripheral contains eight semaphore registers that can be atomically set and cleared. Reading the status field of a semaphore register returns the current state of the status field, and if the field is 0 automatically sets the status to 1. The semaphore status register reflects the state of each of the semaphore\u2019s statuses. The status register enables checking each of the semaphore\u2019s states, but it is not guaranteed that the semaphore status fields cannot change after checking the status register\u2019s value.</p> <p>It is left to the discretion of the software architect to decide how and when the semaphores are used and how they are allocated. Existing hardware does not have to be modified for this type of cooperative sharing, and the use of semaphores is exclusively within the software domain.</p> <p>The semaphore peripheral includes two general-purpose mailbox registers which enable communication between the RV32 and CM4 cores. Additionally, either core can generate a semaphore interrupt for either the CM4 or the RV32 providing immediate communication notification through the mailbox registers.</p>"},{"location":"semaphore/#instances","title":"Instances","text":"<p>There is one instance of the semaphore peripheral, as shown in Table 9-1.</p> <p>Table 9-1: MAX78000 Semaphore Instances </p> Instance Number of Semaphores SEMA 8"},{"location":"semaphore/#multiprocessor-communications","title":"Multiprocessor Communications","text":"<p>The semaphore includes support for multicore communications through two mailbox registers and provides the ability to generate an RV32 semaphore interrupt and a CM4 semaphore interrupt.</p> <p>The mailbox registers, SEMA_MAIL0 and SEMA_MAIL1, are general-purpose 32-bit registers. The CM4 and RV32 have read and write access to both registers. The application software should manage how these registers are used to prevent collisions from occurring if both cores attempt to modify the registers simultaneously.</p>"},{"location":"semaphore/#reset","title":"Reset","text":"<p>Globally reset the semaphore peripheral by setting GCR_RST1.smphr to 1.</p>"},{"location":"semaphore/#cm4-semaphore-interrupt-generation","title":"CM4 Semaphore Interrupt Generation","text":"<p>The SEMA_IRQ0 register provides the ability to generate a CM4 semaphore interrupt. Setting the SEMA_IRQ0.cm4_irq bit to 1 and then setting the SEMA_IRQ0.en bit to 1 generates a CM4 semaphore interrupt. The CM4 interrupt handler should write the SEMA_IRQ0.en or the SEMA_IRQ0.cm4_irq field to 0 to clear the interrupt condition.</p>"},{"location":"semaphore/#rv32-semaphore-interrupt-generation","title":"RV32 Semaphore Interrupt Generation","text":"<p>The SEMA_IRQ1 register provides the ability to generate an RV32 semaphore interrupt. Setting the SEMA_IRQ1.rv32_irq bit to 1 and then setting the SEMA_IRQ1.en bit to 1 generates an RV32 semaphore interrupt. The RV32 interrupt handler should write the SEMA_IRQ1.en or the SEMA_IRQ1.rv32_irq field to 0 to clear the interrupt condition.</p>"},{"location":"semaphore/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 9-2: Semaphore Register Summary </p> Offset Register Name [0x0000] SEMA_SEMAPHORES0 Semaphore 0 Register [0x0004] SEMA_SEMAPHORES1 Semaphore 1 Register [0x0008] SEMA_SEMAPHORES2 Semaphore 2 Register [0x000C] SEMA_SEMAPHORES3 Semaphore 3 Register [0x0010] SEMA_SEMAPHORES4 Semaphore 4 Register [0x0014] SEMA_SEMAPHORES5 Semaphore 5 Register [0x0018] SEMA_SEMAPHORES6 Semaphore 6 Register [0x0020] SEMA_SEMAPHORES7 Semaphore 7 Register [0x0040] SEMA_IRQ0 Semaphore Interrupt 0 Register [0x0044] SEMA_MAIL0 Semaphore Mailbox 0 Register [0x0048] SEMA_IRQ1 Semaphore Interrupt 1 Register [0x004C] SEMA_MAIL1 Semaphore Mailbox 1 Register [0x0100] SEMA_STATUS Semaphore Status Register"},{"location":"semaphore/#register-details","title":"Register Details","text":"<p>Table 9-3: Semaphore 0 Register </p> Semaphore 0 SEMA_SEMAPHORES0 [0x0000] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status0 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-4: Semaphore 1 Register </p> Semaphore 1 SEMA_SEMAPHORES1 [0x0004] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status1 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-5: Semaphore 2 Register </p> Semaphore 2 SEMA_SEMAPHORES2 [0x0008] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status2 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-6: Semaphore 3 Register </p> Semaphore 3 SEMA_SEMAPHORES3 [0x000C] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status3 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-7: Semaphore 4 Register </p> Semaphore 4 SEMA_SEMAPHORES4 [0x0010] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status4 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-8: Semaphore 5 Register </p> Semaphore 5 SEMA_SEMAPHORES5 [0x0014] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status5 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-9: Semaphore 6 Register </p> Semaphore 6 SEMA_SEMAPHORES6 [0x0018] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status6 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-10: Semaphore 7 Register </p> Semaphore 7 SEMA_SEMAPHORES7 [0x001C] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 status * 0 Semaphore Status         Reading this field returns its current value, and if 0, it automatically sets the field to 1. Write 0 to clear this field. Modifications to this field are mirrored in the SEMA_STATUS.status7 field.                  0: Semaphore is available          1: Semaphore is taken          <p>Table 9-11: Semaphore Interrupt 0 Register </p> Semaphore Interrupt 0 SEMA_IRQ0 [0x0040] Bits Name Access Reset Description 31:17 - RO 0 Reserved 16 cm4_irq R/W 0 CM4 Interrupt        The RV32 can use this bit to communicate with the CM4 through the semaphore interrupt. The RV32 generates a semaphore interrupt for the CM4 by setting this field to 1 and also setting the SEMA_IRQ0.en bit to 1.  15:1 - RO 0 Reserved 0 en R/W 0 Interrupt Enable         Set this field to enable interrupt generation on semaphore events.           0: Interrupt disabled          1: Interrupt enabled          <p>Table 9-12: Semaphore Mailbox 0 Register </p> Semaphore Mailbox 0 SEMA_MAIL0 [0x0044] Bits Name Access Reset Description 31:0 data R/W 0 Data        This register is readable and writable by both the CM4 and RV32 cores allowing communication between the two cores. In conjunction with the SEMA_IRQ0 register, the RV32 can write data to this register and then notify the CM4 by generating a semaphore interrupt. Alternately, the CM4 can write to this register and then notify the RV32 using the SEMA_IRQ1 register to generate an RV32 semaphore interrupt event.        <p>Note: The management of the SEMA_MAIL0 and SEMA_IRQ1 registers is left to application software. It is recommended that one mailbox is used for communication from the CM4 to the RV32, and the other mailbox register is used for communication from the RV32 to the CM4. However, there are no hardware read/write restrictions on the mailbox registers.</p> <p>Table 9-13: Semaphore Interrupt 1 Register </p> Semaphore Interrupt 1 SEMA_IRQ1 [0x0048] Bits Name Access Reset Description 31:17 - RO 0 Reserved 16 rv32_irq R/W 0 RV32 Interrupt        The CM4 can use this bit to communicate with the RV32 through the semaphore interrupt. The CM4 generates a semaphore interrupt for the RV32 by setting this field to 1 and also setting the SEMA_IRQ1.en bit to 1.          0: RV32 interrupt event not active or received by RV32.         1: RV32 interrupt event is generated when the SEMA_IRQ1.en bit is also set to 1.         15:1 - RO 0 Reserved 0 en R/W 0 Interrupt Enable         Set this field to generate an RV32 semaphore interrupt when the SEMA_IRQ1.rv32_irq is also set to 1. The RV32 should write this bit to 0 when a semaphore interrupt is generated to prevent repeat interrupt generation.           0: Interrupt disabled          1: Interrupt enabled          <p>Table 9-14: Semaphore Mailbox 1 Register </p> Semaphore Mailbox 1 SEMA_MAIL1 [0x004C] Bits Name Access Reset Description 31:0 data R/W 0 Data        This register is readable and writable by both the CM4 and RV32 cores allowing communication between the two cores. In conjunction with the SEMA_IRQ0 register, the RV32 can write data to this register and then notify the CM4 by generating a semaphore interrupt. Alternately, the CM4 can write to this register and then notify the RV32 using the SEMA_IRQ1 register to generate an RV32 semaphore interrupt event.        <p>Note: The management of the SEMA_MAIL0 and SEMA_MAIL1 registers is left to application software. It is recommended that one mailbox is used for communication from the CM4 to the RV32, and the other mailbox register is used for communication from the RV32 to the CM4. However, there are no hardware read/write restrictions on the mailbox registers.</p> <p>Table 9-15: Semaphore Status Register </p> Semaphore Status SEMA_STATUS [0x0100] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7 status7 R 0 Semaphore 7 Status             This field mirrors the semaphore 7 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES7.status is 0                 1: SEMA_SEMAPHORES7.status is 1              6 status6 R 0 Semaphore 6 Status             This field mirrors the semaphore 6 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES6.status is 0                 1: SEMA_SEMAPHORES6.status is 1              5 status5 R 0 Semaphore 5 Status             This field mirrors the semaphore 5 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES5.status is 0                 1: SEMA_SEMAPHORES5.status is 1              4 status4 R 0 Semaphore 4 Status             This field mirrors the semaphore 4 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES4.status is 0                 1: SEMA_SEMAPHORES4.status is 1              3 status3 R 0 Semaphore 3 Status             This field mirrors the semaphore 3 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES3.status is 0                 1: SEMA_SEMAPHORES3.status is 1              2 status2 R 0 Semaphore 2 Status             This field mirrors the semaphore 2 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES2.status is 0                 1: SEMA_SEMAPHORES2.status is 1              1 status1 R 0 Semaphore 1 Status             This field mirrors the semaphore 1 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES1.status is 0                 1: SEMA_SEMAPHORES1.status is 1              0 status0 R 0 Semaphore 0 Status             This field mirrors the semaphore 0 status field. Reads from this field do not affect the corresponding semaphore\u2019s status field.                  0: SEMA_SEMAPHORES0.status is 0                 1: SEMA_SEMAPHORES0.status is 1"},{"location":"serial-peripheral-interface/","title":"Serial Peripheral Interface","text":"<p>The Serial Peripheral Interface (SPI) is a highly configurable, flexible, and efficient synchronous interface between multiple SPI devices on a single bus. The SPI bus uses a single clock signal, and single, dual, or quad data lines, and one or more slave select lines for communication with external SPI devices.</p> <p>The provided SPI ports support full-duplex, bi-direction I/O, and each SPI includes a bit rate generator (BRG) for generating the clock signal when operating in master mode. Each SPI port operates independently and requires minimal processor overhead. All instances of the SPI peripheral support both master and slave modes and support single master and multi-master networks.</p> <p>Features include:</p> <ul> <li> <p>Dedicated Bit Rate Generator for precision serial clock generation in Master Mode</p> <ul> <li>Up to \\(\\frac{f_{\\text{PCLK}}}{2}\\) for instances on the APB bus</li> <li>Up to \\(\\frac{f_{\\text{HCLK}}}{2}\\) for instances on the AHB bus</li> <li>Programmable SCK duty cycle timing</li> </ul> </li> <li> <p>Full-duplex, synchronous communication of 2 to 16-bit characters</p> <ul> <li>1-bit and 9-bit characters are not supported</li> <li>2-bit and 10-bit characters do not support maximum clock speed. SPIn_CLKCTRL.clkdiv must be &gt; 0</li> </ul> </li> <li> <p>3-wire and 4-wire SPI operation for single-bit communication</p> </li> <li>Single, dual, or quad I/O operation</li> <li> <p>Byte-wide transmit and receive FIFOs with 32-byte depth</p> <ul> <li>For character sizes greater than 8, each character uses 2 entries per character resulting in 16 entries for the transmit and receive FIFO</li> </ul> </li> <li> <p>Transmit and receive DMA support</p> </li> <li>SPI modes 0, 1, 2, 3</li> <li> <p>Configurable slave select lines</p> <ul> <li>Programmable slave select level</li> </ul> </li> <li> <p>Programmable slave select timing with respect to SCK starting edge and ending edge</p> </li> <li>Multi-master mode fault detection</li> </ul> <p>Figure 13-1 shows a high-level block diagram of the SPI peripheral. See Table 13-1 for the peripheral-specific peripheral bus assignment and bit rate generator clock source.</p> <p>Figure 13-1: SPI Block Diagram </p> <p></p>"},{"location":"serial-peripheral-interface/#instances","title":"Instances","text":"<p>There are two instances of the SPI peripheral, as shown in Table 13-1. Table 13-2 lists the locations of the SPI signals for each of the SPI instances.</p> <p>Table 13-1: MAX78000 SPI Instances </p> Instance Formats Hardware Bus Bit Rate Generator  Clock Source Frequency Slave Select Signals 3-Wire 4-Wire Dual Quad 81-CTBGA SPI0 Yes Yes Yes Yes AHB f<sub>SYS_CLK</sub> 3 SPI1 Yes Yes Yes Yes APB f<sub>PCLK</sub> 1 <p>Note: Refer to the MAX78000 data sheet for each peripheral's definitive list of alternate function assignments.</p> <p>Table 13-2: MAX78000 SPI Peripheral Pins </p> Instance Signal Description Alternate Function Alternate Function Number 81 CTBGA SPI0 SPI Clock SPI0_SCK AF1 P0.7 Slave Select 0 SPI0_SS0 AF1 P0.4 Slave Select 1 SPI0_SS1 AF2 P0.11 Slave Select 2 SPI0_SS2 AF2 P0.10 MOSI (SDIO0) SPI0_MOSI AF1 P0.5 MISO (SDIO1) SPI0_MISO AF1 P0.6 SDIO2 SPI0_SDIO2 AF1 P0.8 SDIO3 SPI0_SDIO3 AF1 P0.9 SPI1 SPI Clock SPI1_SCK AF1 P0.23 Slave Select 0 SPI1_SS0 AF1 P0.20 MOSI (SDIO0) SPI1_MOSI AF1 P0.21 MISO (SDIO1) SPI1_MISO AF1 P0.22 SDIO2 SPI1_SDIO2 AF1 P0.24 SDIO3 SPI1_SDIO3 AF1 P0.25"},{"location":"serial-peripheral-interface/#format","title":"Format","text":""},{"location":"serial-peripheral-interface/#four-wire-spi","title":"Four-Wire SPI","text":"<p>SPI devices operate as either a master or a slave device. In four-wire SPI, four signals are required for communication, as shown in Table 13-3.</p> <p>Table 13-3: Four-Wire Format Signals </p> Signal Description Direction SCK Serial Clock The master generates the serial clock signal, an output from the master, and an input to the slave. MOSI Master Output Slave Input In master mode, this signal is used as an output for sending data to the slave.  In slave mode, this is the input data from the master. MISO Master Input Slave Output In master mode, this signal is used as an input for receiving data from the slave. In slave mode, this signal is an output for transmitting data to the master. SS Slave Select In master mode, this signal is an output used to select a slave device before communication. Peripherals may have multiple slave select outputs to communicate with one or more external slave devices. In slave mode, SPIn_SS0 is a dedicated input that indicates when an external master is starting communication. Other slave select signals into the peripheral are ignored in slave mode. <p>In a typical SPI network, the master device selects the slave device using the slave select output. The master starts the communication by selecting the slave device by asserting the slave select output. The master then starts the SPI clock through the SCK output pin. When a slave device's slave select pin is deasserted, the device must put the SPI pins in tri-state mode.</p> <p>Figure 13-2: 4-Wire SPI Connection Diagram </p> <p></p>"},{"location":"serial-peripheral-interface/#three-wire-spi","title":"Three-Wire SPI","text":"<p>The signals in three-wire SPI operation are shown in Table 13-4. The MOSI signal is used as a bi-directional, half-duplex I/O referred to as slave input slave output (SISO). Three-wire SPI also uses a serial clock signal generated by the master and a slave select pin controlled by the master.</p> <p>Table 13-4: Three-Wire Format Signals </p> Signal Description Direction SCK Serial Clock The master generates the serial clock signal, an output from the master, and an input to the slave. MOSI (SISO) Slave Input Slave Output The SISO is a half-duplex, bidirectional I/O pin used for communication between the SPI master and slave. This signal is used to transmit data from the master to the slave and receive data from the slave by the master. SS Slave Select In master mode, this signal is an output used to select a slave device before communication. In slave mode, SPIn_SS0 is a dedicated input that indicates when an external master is starting communication. Other slave select signals into the peripheral are ignored in slave mode. <p>A three-wire SPI network is shown in Figure 13-3. The master device selects the slave device using the slave select output. The communication starts with the master asserting the slave select line and then starting the clock (SCK). In three-wire SPI communication, the master and slave must know the data's intended direction to prevent bus contention. For a write, the master drives the data out of the SISO pin. The master must release the SISO line for a read and let the slave drive the SISO line. The direction of transmission is controlled using the FIFO. Writing to the FIFO starts the three-wire SPI write, and reading from the FIFO starts a three-wire SPI read transaction.</p> <p>Figure 13-3: Generic 3-Wire SPI Master to Slave Connection </p> <p></p>"},{"location":"serial-peripheral-interface/#pin-configuration","title":"Pin Configuration","text":"<p>Before configuring the SPI peripheral, first, disable any SPI activity for the port by clearing the SPIn_CTRL0.en field to 0.</p>"},{"location":"serial-peripheral-interface/#spi-alternate-function-mapping","title":"SPI Alternate Function Mapping","text":"<p>Pin selection and configuration are required to use the SPI port. The following information applies to SPI master and slave operations in three-wire, four-wire, dual, and quad mode communications. Determine the pins required for the SPI type and mode in the application, and configure the required GPIO as described in the following sections. Refer to the MAX78000 data sheet for pin availability for a specific package.</p> <p>When the SPI port is disabled, SPIn_CTRL0.en = 0, the GPIO pins enabled for SPI alternate function are placed in high-impedance input mode.</p>"},{"location":"serial-peripheral-interface/#four-wire-format-configuration","title":"Four-Wire Format Configuration","text":"<p>Four-wire SPI uses SCK, MISO, MOSI, and one or more SS pins. Four-wire SPI may use more than one slave select pin for a transaction, resulting in more than four wires total; however, the communication is referred to as four-wire for legacy reasons.</p> <p>Note: Select the pins mapped to the SPI external device in the design and modify the setup accordingly. There is no restriction on which alternate function is used for a specific SPI pin, and each SPI pin can be used independently from the other pins chosen. However, it is recommended that only one set of GPIO port pins are used for any network.</p>"},{"location":"serial-peripheral-interface/#three-wire-format-configuration","title":"Three-Wire Format Configuration","text":"<p>Three-wire SPI uses SCK, MOSI, and one or more slave select pins for an SPI transaction. Three-wire SPI configuration is identical to the four-wire configuration, except SPIn_MISO does not need to be set up for the SPI alternate function. The direction of communication in three-wire SPI mode is controlled by the SPI transmit and receive FIFO enables. Enabling the receive FIFO and disabling the transmit FIFO indicates a read transaction. Enabling the transmit FIFO and disabling the receive FIFO indicates a write transaction. It is an illegal condition to enable both the transmit and receive FIFOs in three-wire SPI operation.</p>"},{"location":"serial-peripheral-interface/#dual-mode-format-configuration","title":"Dual-Mode Format Configuration","text":"<p>In dual-mode SPI, two I/O pins are used to transmit 2-bits of data per SCK clock cycle. The communication is half-duplex, and the direction of the data transmission must be known by both the master and slave for a given transaction. Dual-mode SPI uses SCK, SDIO0, SDIO1, and one or more slave select lines, as shown in Figure 13-4. The configuration of the GPIO pins for dual-mode SPI is identical to four-wire SPI. The mode is controlled by setting SPIn_CTRL2.data_width to 1, indicating that the SPI hardware uses SDIO0 and SDIO1 for half-duplex communication.</p> <p>Figure 13-4: Dual Mode SPI Connection Diagram </p> <p></p>"},{"location":"serial-peripheral-interface/#quad-mode-format-configuration","title":"Quad-Mode Format Configuration","text":"<p>Quad-mode SPI uses four I/O pins to transmit four bits of data per transaction. In quad-mode SPI, the communication is half-duplex, and the master and slave must know the direction of transmission for each transaction. Quad-mode SPI uses SCK, SDIO0, SDIO1, SDIO2, SDIO3, and one or more slave select pins.</p> <p>Quad-mode SPI transmits four bits per SCK cycle. The selection of quad mode SPI is selected by setting SPIn_CTRL2.data_width to 2.</p>"},{"location":"serial-peripheral-interface/#clock-configuration","title":"Clock Configuration","text":""},{"location":"serial-peripheral-interface/#serial-clock","title":"Serial Clock","text":"<p>The SCK signal synchronizes data movement in and out of the device. The master drives SCK as an output to the slave's SCK pin. When SPI is set to master mode, the SPI bit rate generator creates the serial clock and outputs it on the configured SPIn_SCK pin. When SPI is configured for slave operation, the SPIn_SCK pin is an input from the external master, and the SPI hardware synchronizes communications using the SCK input. Operating as a slave, if an SPI slave select input is not asserted, the SPI ignores any signals on the serial clock and serial data lines.</p> <p>In both master and slave devices, data is shifted on one edge of the SCK and is sampled on the opposite edge where data is stable. Data availability and sampling time are controlled using the SPI phase control field, SPIn_CTRL2.clkpha. The SCK clock polarity field, SPIn_CTRL2.clkpol, controls if the SCK signal is active high or active low.</p> <p>The SPI peripheral supports four combinations of SCK phase and polarity referred to as SPI Modes 0, 1, 2, and 3. Clock Polarity (SPIn_CTRL2.clkpol) selects an active low/high clock and does not affect the transfer format. Clock phase (SPIn_CTRL2.clkpha) selects one of two different transfer formats.</p> <p>The clock phase and polarity must be identical for the SPI master and slave for proper data transmission. The master always places data on the MOSI line a half-cycle before the SCK edge for the slave to latch the data. See Clock Phase and Polarity Control for additional details.</p>"},{"location":"serial-peripheral-interface/#peripheral-clock","title":"Peripheral Clock","text":"<p>See Table 13-1 for the specific input clock, \\(f_{SPI\\text{_CLK}}\\), used for each SPI instance. For SPI instances assigned to the AHB bus, the SPI input clock is the system clock, SYS_CLK. For SPI instances mapped to the APB bus, the SPI input clock is the system peripheral clock, PCLK. The SPI input clock drives the SPI peripheral clock. </p> <p>The SPI provides an internal clock, SPIn_CLK, used within the SPI peripheral for the base clock to control the module and generate the SCK clock when in master mode. Set the SPI internal clock using the field SPIn_CLKCTRL.clkdiv as shown in Equation 13-1. Valid settings for SPIn_CLKCTRL.clkdiv are 0 to 8, allowing a divisor of 1 to 256.</p> <p>Equation 13-1: SPI Peripheral Clock </p> \\[f_{SPI\\text{_CLK}} = \\frac{f_{INPUT\\text{_CLK}}}{2^{clkdiv}}\\]"},{"location":"serial-peripheral-interface/#master-mode-serial-clock-configuration","title":"Master Mode Serial Clock Configuration","text":"<p>In master and multi-master mode, the SCK clock is generated by the master. The SPI provides control for both the high time and low time of the SCK clock. This control allows setting the high and low times for the SCK to duty cycles other than 50% if required. The SCK clock uses the SPI peripheral clock as a base value, and the high and low values are a count of the number of \\(f_{SPI\\text{_CLK}}\\) clocks. Figure 13-5 visually represents the use of the SPIn_CLKCTRL.hi and SPIn_CLKCTRL.lo fields for a non-50% duty cycle serial clock generation. See Equation 13-2 and Equation 13-3 for calculating the SCK high and low time from the SPIn_CLKCTRL.hi and SPIn_CLKCTRL.lo field values.</p> <p>Figure 13-5: SCK Clock Rate Control </p> <p></p> <p>Equation 13-2: SCK High Time </p> \\[t_{\\text{SCK_HI}} = t_{\\text{SPIn_CLK}} \\times \\text{SPIn_CLKCTRL.hi}\\] <p>Equation 13-3: SCK Low Time </p> \\[t_{\\text{SCK_LOW}} = t_{\\text{SPIn_CLK}} \\times \\text{SPIn_CLKCTRL.lo}\\]"},{"location":"serial-peripheral-interface/#clock-phase-and-polarity-control","title":"Clock Phase and Polarity Control","text":"<p>SPI supports four combinations of clock and phase polarity as shown in Table 13-5. Clock polarity is controlled using the SPIn_CTRL2.clkpol bit and determines if the clock is active high or active low, as shown in Figure 13-6. Clock polarity does not affect the transfer format for SPI. The clock phase determines when the data must be stable for sampling. Setting the clock phase to 0, SPIn_CTRL2.clkpha = 0, dictates that the SPI data is sampled on the initial SPI clock edge regardless of clock polarity. Phase 1, SPIn_CTRL2.clkpha = 1, results in the data sample occurring on the second edge of the clock regardless of clock polarity.</p> <p>Figure 13-6: SPI Clock Polarity </p> <p></p> <p>The clock phase and polarity must be identical for the SPI master and slave for proper data transmission. The master always places data on the MOSI line a half-cycle before the SCK edge for the slave to latch the data.</p> <p>Table 13-5: SPI Modes Clock Phase and Polarity Operation </p> SPI Mode SPIn_CTRL2.clkpha SPIn_CTRL2.clkpol SCK Transmit Edge SCK Receive Edge SCK Idle State 0 0 0 Falling Rising Low 1 0 1 Rising Falling High 2 1 0 Rising Falling Low 3 1 1 Falling Rising High"},{"location":"serial-peripheral-interface/#transmit-and-receive-fifos","title":"Transmit and Receive FIFOs","text":"<p>The transmit FIFO hardware is 32 bytes deep. The write data width can be 8-, 16- or 32-bits wide. A 16-bit write queues a 16-bit word to the FIFO hardware. A 32-bit write queues two 16-bit words to the FIFO hardware with the least significant word dequeued first. Bytes must be written to two consecutive byte addresses, with the odd byte as the most significant byte and the even byte as the least significant byte. The FIFO logic waits for both the odd and even bytes to be written before dequeuing the 16-bit result to the FIFO.</p> <p>The receive FIFO hardware is 32 bytes deep. Read data width can be 8-, 16- or 32-bits. A byte read from this register dequeues one byte from the FIFO. A 16-bit read from this register dequeues two bytes from the FIFO, the least significant byte first. A 32-bit read from this register dequeues four bytes from the FIFO, the least significant byte first.</p>"},{"location":"serial-peripheral-interface/#interrupts-and-wakeups","title":"Interrupts and Wakeups","text":"<p>The SPI supports multiple interrupt sources. Status flags for each interrupt are set regardless of the state of the interrupt enable bit for that event. The event happens once when the condition is satisfied. The software must clear the status flag by writing a 1 to the interrupt flag.</p> <p>The following FIFO interrupts are supported:</p> <ul> <li>Transmit FIFO empty</li> <li>Transmit FIFO threshold</li> <li>Receive FIFO full</li> <li>Receive FIFO threshold</li> <li> <p>Transmit FIFO underrun</p> <ul> <li>Slave mode only, master mode stalls the serial clock</li> </ul> </li> <li> <p>Transmit FIFO overrun</p> </li> <li>Receive FIFO underrun</li> <li> <p>Receive FIFO overrun</p> <ul> <li>Slave mode only, master mode stalls the serial clock</li> </ul> </li> <li> <p>SPI supports interrupts for the internal state of the SPI and the external signals. The following transmission interrupts are supported:</p> <ul> <li>SSn asserted or deasserted</li> <li>SPI transaction complete</li> <li>Master mode only</li> <li>Slave mode transaction aborted</li> <li>Multi-master fault</li> </ul> </li> </ul> <p>The SPI port can wake up the microcontroller from low-power modes when the wake event is enabled. SPI events that can wake the microcontroller are:</p> <ul> <li>Receive FIFO full</li> <li>Transmit FIFO empty</li> <li>Receive FIFO threshold</li> <li>Transmit FIFO threshold</li> </ul>"},{"location":"serial-peripheral-interface/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. If multiple instances of the peripheral are provided, each instance has its own independent set of the registers shown in Table 13-6. Register names for a specific instance are defined by replacing \"n\" with the instance number. As an example, a register PERIPHERALn_CTRL resolves to PERIPHERAL0_CTRL and PERIPHERAL1_CTRL for instances 0 and 1, respectively.</p> <p>See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 13-6: SPI Register Summary </p> Offset Register Description [0x0000] SPIn_FIFO32 SPI FIFO Data Register [0x0000] SPIn_FIFO16 SPI 16-bit FIFO Data Register [0x0000] SPIn_FIFO8 SPI 8-bit FIFO Data Register [0x0004] SPIn_CTRL0 SPI Master Signals Control Register [0x0008] SPIn_CTRL1 SPI Transmit Packet Size Register [0x000C] SPIn_CTRL2 SPI Static Configuration Register [0x0010] SPIn_SSTIME SPI Slave Select Timing Register [0x0014] SPIn_CLKCTRL SPI Master Clock Configuration Register [0x001C] SPIn_DMA SPI DMA Control Register [0x0020] SPIn_INTFL SPI Interrupt Flag Register [0x0024] SPIn_INTEN SPI Interrupt Enable Register [0x0028] SPIn_WKFL SPI Wakeup Flags Register [0x002C] SPIn_WKEN SPI Wakeup Enable Register [0x0030] SPIn_STAT SPI Status Register"},{"location":"serial-peripheral-interface/#register-details","title":"Register Details","text":"<p>Table 13-7: SPI 32-bit FIFO Register </p> SPI FIFO Data SPIn_FIFO32 [0x0000] Bits Name Access Reset Description 31:0 data R/W 0 SPI FIFO Data Register         This register is used for the SPI transmit and receive FIFO. Reading from this register returns characters from the receive FIFO, and writing to this register adds characters to the transmit FIFO. Read and write this register in either 1-byte, 2-byte, or 4-byte widths only. Reading from an empty FIFO or writing to a full FIFO results in undefined behavior.          <p>Table 13-8: SPI 16-bit FIFO Register </p> SPI FIFO Data SPIn_FIFO16 [0x0000] Bits Name Access Reset Description 31:16 - R/W 0 Reserved 15:0 data R/W 0 SPI 16-bit FIFO Data Register         This register is used for the SPI transmit and receive FIFO. Reading from this register returns characters from the receive FIFO, and writing to this register adds characters to the transmit FIFO. Read and write this register in 2-byte width only for 16-bit FIFO access. Reading from an empty FIFO or writing to a full FIFO results in undefined behavior. <p>Table 13-9: SPI 8-bit FIFO Register </p> SPI 8-bit FIFO Data Register SPIn_FIFO8 [0x0000] Bits Name Access Reset Description 31:0 - RO 0 Reserved 7:0 data R/W 0 SPI 8-bit FIFO Data RegisterThis register is used for the SPI transmit and receive FIFO. Reading from this register returns characters from the receive FIFO, and writing to this register adds characters to the transmit FIFO. Read and write this register in 1-byte width only for 8-bit FIFO access. Reading from an empty FIFO or writing to a full FIFO results in undefined behavior. <p>Table 13-10: SPI Control 0 Register </p> SPI Control 0 SPIn_CTRL0 [0x0004] Bits Name Access Reset Description 31:20 - RO 0 Reserved 19:16 ss_active R/W 0 Master Slave Select          The SPI includes up to four slave select lines for each port. This field selects which slave select pin is active when the next SPI transaction is started (SPIn_CTRL0.start\u00a0=\u00a01). One or more slave select pins can be selected for each SPI transaction by setting the bit for each slave select pin. For example, use SPIn_SS0 and SPIn_SS2 by setting this field to 0b0101 or select all slave selects by setting this field to 0b1111.         Note: This field is only used when the SPI is configured for Master         Mode (SPIn_CTRL0.mst_mode\u00a0=\u00a01). 15:9 - RO 0 Reserved 8 ss_ctrl R/W 0 Master Slave Select Control This field controls the behavior of the slave select pins at the completion of a transaction. The default behavior, ss_ctrl = 0, deasserts the slave select pin at the completion of the transaction. Set this field to 1 to leave the slave select pins asserted at the completion of the transaction. If the external device supports this behavior, leaving the slave select pins asserted allows multiple transactions without the delay associated with deassertion of the slave select pin between transactions.                  0: Slave Select is deasserted at the end of a transmission         1: Slave Select stays asserted at the end of a transmission          7:6 - RO 0 Reserved 5 start R/W1O 0 Master Start Data Transmission         Set this field to 1 to start an SPI master mode transaction.                  0: No master mode transaction active.         1: Master initiates data transmission. Ensure that all pending transactions are complete before setting this field to 1.          <p> Note: This field is only used when the SPI is configured for Master         Mode (SPIn_CTRL0.mst_mode = 1). 4 ss_io R/W 0 Master Slave Select Signal Direction         Set the I/O direction for                  0: Slave select is an output         1: Slave select is an input&lt; <p>Note: This field is only used when the SPI is configured for Master         Mode (SPIn_CTRL0.mst_mode = 1). 3:2 - RO 0 Reserved 1 mst_mode R/W 0 SPI Master Mode Enable This field selects between slave mode and master mode operation for the SPI port. Write this field to 0 to operate as an SPI slave. Setting this field to 1 sets the port as an SPI master.                  0: Slave mode SPI operation.         1: Master mode SPI operation.          0 en R/W 0 SPI Enable/DisableThis field enables and disables the SPI port. Disable the SPI port by setting this field to 0. Disabling the SPI port does not affect the SPI FIFOs or register settings. Access to SPI registers is always available.                  0: SPI port is disabled          1: SPI port is enabled          <p>Table 13-11: SPI Control 1 Register </p> SPI Transmit Packet Size SPIn_CTRL1 [0x0008] Bits Name Access Reset Description 31:16 rx_num_char R/W 0 Number of Receive Characters This field sets the number of characters to receive in receive FIFO.         <p>Note: If the SPI port is set to operate in 4-wire mode, this field is         ignored, and the SPIn_CTRL1.tx_num_char field is used for both the         number of characters to receive and transmit.</p> 15:0 tx_num_char R/W 0 Number of Transmit CharactersThis field sets the number of characters to transmit from transmit FIFO.         <p>Note: If the SPI port is set to operate in 4-wire mode, this field is         used for both the number of characters to receive and transmit.</p> <p>Table 13-12: SPI Control 2 Register </p> SPI Control 2 SPIn_CTRL2 [0x000C] Bits Name Access Reset Description 31:20 - RO 0 Reserved 19:16 ss_pol R/W 0 Slave Select PolarityControls the polarity of each individual SS signal where each bit position corresponds to a SS signal. SPIn_SS0 is controlled with bit position 0, and SPIn_SS2 is controlled with bit position 2.         <p>For each bit position,</p>          0: SS is active low         1: SS is active high          15 three_wire R/W 0 Three-Wire SPI EnableSet this field to 1 to enable three-wire SPI communication. Set this field to 0 for four-wire full-duplex SPI communication.          0: Four-wire full-duplex mode enabled.         1: Three-wire mode enabled <p>Note: This field is ignored for Dual SPI, SPIn_CTRL2.data_width\u00a0=1,         and Quad SPI, SPIn_CTRL2.data_width\u00a0=2.</p> 14 - RO 0 Reserved 13:12 data_width R/W 0b00 SPI Data Width This field controls the number of data lines used for SPI communications.         <p>Three-wire SPI: data_width\u00a0=\u00a00</p> <p>Set this field to 0, indicating SPIn_MOSI is used for half-duplex communication.</p> <p>Four-wire full-duplex SPI: data_width\u00a0=\u00a00</p> <p>Set this field to 0, indicating the SPIn_MOSI and the SPIn_MISO are used for the SPI data output and input, respectively.</p> <p>Dual Mode SPI: data_width\u00a0=\u00a01         <p> Set this field to 1, indicating SPIn_SDIO0 and SPIn_SDIO1 are used for         half-duplex communication.</p> <p>Quad Mode SPI: data_width\u00a0=\u00a02         <p>Set this field to 2, indicating SPIn_SDIO0, SPIn_SDIO1, SPIn_SDIO2, and SPIn_SDIO3 are used for half-duplex communication.</p>         0: 1-bit per SCK cycle (Three-wire half-duplex SPI and Four-wire full-duplex SPI)         1: 2-bits per SCK cycle (Dual mode SPI)         2: 4-bits per SCK cycle (Quad mode SPI)         3: Reserved         <p>Note: When this field is set to 0, use the field SPIn_CTRL2.three_wire to select either three-wire SPI or four-wire SPI operation.</p> 11:8 numbits R/W 0 Number of Bits per Character         Set this field to the number of bits per character for the SPI transaction. Setting this field to 0 indicates a character size of 16.                  0: 16-bits per character         1: 1-bit per character (not supported)         2: 2-bits per character         \u2026         14: 14-bits per character         15: 15-bits per character          <p>Note: 1-bit and 9-bit character lengths are not supported.</p> <p>Note: 2-bit and 10-bit character lengths do not support maximum SCK speeds in master mode. SPIn_CLKCTRL.clkdiv must be &gt; 0</p> <p>Note: For dual and quad mode SPI, the character size should be divisible by the number of bits per SCK cycle.</p> 7:2 - RO 0 Reserved 1 clkpol R/W 0 Clock Polarity         This field controls the SCK polarity. The default clock polarity is for SPI mode 0 and mode 1 operation and is active high. Invert the SCK polarity for SPI mode 2 and mode 3 operation.                  0: Standard SCK for use in SPI mode 0 and mode 1         1: Inverted SCK for use in SPI mode 2 and mode 3          0 clkpha R/W 0 Clock Phase          0: Data sampled on clock rising edge. Use when in SPI mode 0 and mode 2         1: Data sampled on clock falling edge. Use when in SPI mode 1 and mode 3          <p>Table 13-13: SPI Slave Select Timing Register </p> SPI Slave Select Timing SPIn_SSTIME [0x0010] Bits Name Access Reset Description 31:24 - RO 0 Reserved 23:16 inact R/W 0 Inactive Stretch This field controls the number of system clocks the bus is inactive between the end of a transaction (slave select inactive) and the start of the next transaction (slave select active).                  0: 256         1: 1         2: 2         3:3         \u2026         \u2026         254: 254         255: 255          <p>Note: The SPIn_SSTIME register bit settings only apply when SPI is operating in master mode (SPIn_CTRL0.mst_mode = 1)</p> 15:8 post R/W 0 Slave Select Hold Post Last SCKThis field sets the number of system clock cycles that SS remains active after the last SCK edge.                  0: 256         1: 1         2: 2         3:3         \u2026         \u2026         254: 254         255: 255          <p>Note: The SPIn_SSTIME register bit settings only apply when SPI is operating in master mode (SPIn_CTRL0.mst_mode = 1)</p> 7:0 pre R/W 0 Slave Select Delay to First SCK This field sets the number of system clock cycles the slave select is held active before the first SCK edge.                  0: 256          1: 1         2: 2         3:3         \u2026         \u2026         254: 254         255: 255          <p>Note: The SPIn_SSTIME register bit settings only apply when SPI is operating in master mode (SPIn_CTRL0.mst_mode = 1)</p> <p>Table 13-14: SPI Master Clock Configuration Registers </p> SPI Master Clock Configuration SPIn_CLKCTRL [0x0014] Bits Name Access Reset Description 31:20 - RO 0 Reserved 19:16 clkdiv R/W 0 SPI Peripheral Clock Scale         Scales the SPI input clock (PCLK) by 2<sup>scale</sup> to generate the SPI peripheral clock. <p>$$f_{SPInCLK} = \\frac{f_{SPIn\\text{_INPUT}\\text{_CLK}}}{2^{clkdiv}}$$</p> <p>Valid values for scale are 0 to 8 inclusive. Values greater than 8 are reserved for future use.</p> <p>Note: 1-bit and 9-bit character lengths are not supported.</p> <p>Note: If SPIn_CLKCTRL.clkdiv = 0, SPIn_CLKCTRL.hi = 0, and SPIn_CLKCTRL.lo = 0, character sizes of 2 and 10 bits are not supported.</p> 15:8 hi R/W 0 SCK Hi Clock Cycles Control          0: Hi duty cycle control disabled. Only valid if SPIn_CLKCTRL.clkdiv = 0.         1 - 15: The number of SPI peripheral clocks,         f<sub>SPInCLK</sub>,         that SCK is high.          <p>Note: 1-bit and 9-bit character lengths are not supported.</p> <p>Note: If SPIn_CLKCTRL.clkdiv = 0, SPIn_CLKCTRL.hi = 0, and SPIn_CLKCTRL.lo = 0, character sizes of 2 and 10 bits are not supported.</p> 7:0 lo R/W 0 SCK Low Clock Cycles Control         This field controls the SCK low clock time and controls the overall SCK duty cycle in combination with the SPIn_CLKCTRL.hi field.                  0: Low duty cycle control disabled. Setting this field to 0 is only valid if SPIn_CLKCTRL.clkdiv\u00a0=\u00a00.         1 to 15: The number of SPI peripheral clocks,          f<sub>SPInCLK</sub>,         that the SCK signal is low. <p>Note: 1-bit and 9-bit character lengths are not supported.</p> <p>Note: If SPIn_CLKCTRL.clkdiv = 0, SPIn_CLKCTRL.hi = 0, and SPIn_CLKCTRL.lo = 0, character sizes of 2 and 10 bits are not supported.</p> <p>Table 13-15: SPI DMA Control Registers </p> SPI DMA Control SPIn_DMA [0x001C] Bits Name Access Reset Description 31 dma_rx_en R/W 0 Receive DMA Enable          0: Disabled. Any pending DMA requests are cleared         1: Enabled          30:24 dma_rx_en R 0 Number of Bytes in the Receive FIFO         Read returns the number of bytes currently in the receive FIFO.          23 rx_flush W1O - Clear the Receive FIFO          1: Clear the receive FIFO and any pending receive FIFO flags in SPIn_INTFL. This should be done when the receive FIFO is inactive.          <p>Note: Writing a 0 to this field has no effect.</p> 22 rx_fifo_en R/W 0 Receive FIFO Enabled          0: Disabled         1: Enabled 21 - RO 0 Reserved 20:16 rx_thd_val R/W 0x00 Receive FIFO Threshold Level         Set this value to the desired receive FIFO threshold level. When the receive FIFO level crosses above this setting, a DMA request is triggered if enabled by setting SPIn_DMA.dma_tx_en, and SPIn_INTFL.rx_thd becomes set. Valid values are 0 to 30.         <p>Note: 31 is an invalid setting and reserved for future use.</p> 15 dma_tx_en R/W 0 Transmit DMA Enable          0: Disabled. Any pending DMA requests are cleared.         1: Transmit DMA is enabled 14:8 tx_lvl R 0 Number of Bytes in the Transmit FIFO         Read this field to determine the number of bytes currently in the transmit FIFO.          7 tx_flush R/W 0 Transmit FIFO Clear         Set this bit to clear the transmit FIFO and all transmit FIFO flags in the SPIn_INTFL register.         <p>Note: The transmit FIFO should be disabled (SPIn_DMA.tx_fifo_en\u00a0=\u00a00) before setting this field.</p> <p>Note: Setting this field to 0 has no effect.</p> 6 tx_fifo_en R/W 0 Transmit FIFO Enabled <p>0: Disabled</p> <p>1: Enabled 5 - RO 0 Reserved 4:0 tx_thd_val R/W 0x10 Transmit FIFO Threshold Level         Set this value to the desired transmit FIFO threshold level. When the transmit FIFO count (SPIn_DMA.tx_lvl) falls below this value, a DMA request is triggered if enabled by setting SPIn_DMA.dma_tx_en, and SPIn_INTFL.tx_thd         becomes set.          <p>Table 13-16: SPI Interrupt Status Flags Registers </p> SPI Interrupt Status Flags SPIn_INTFL [0x0020] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 rx_un R/W1C 0 Receive FIFO Underrun Flag         This field is set when a read is attempted from an empty receive FIFO.          14 rx_ov R/W1C 0 Receive FIFO Overrun Flag         This field is set if SPI is in slave mode, and a write to a full receive FIFO is attempted. If the SPI is in master mode, this bit is not set as the SPI stalls the clock until data is read from the receive FIFO. 13 tx_un R/W1C 0 Transmit FIFO Underrun Flag         This field is set if SPI is in slave mode, and a read from empty transmit FIFO is attempted. If SPI is in master mode, this bit is not set as the SPI stalls the clock until data is written to the empty transmit FIFO.          12 tx_ov R/W1C 0 Transmit FIFO Overrun Flag          This field is set when a write is attempted to the full transmit FIFO.          11 mst_done R/W1C 0 Master Data Transmission Done Flag This field is set if the SPI is in master mode and all transactions have been completed. SPIn_CTRL1.tx_num_char has been reached.          10 - RO 0 Reserved 9 abort R/W1C 0 Slave Mode Transaction Abort Detected Flag         This field is set if the SPI is in slave mode, and SS is deasserted before a complete character is received.          8 fault R/W1C 0 Multi-Master Fault Flag         This field is set if the SPI is in master mode, multi-master mode is enabled, and a slave select input is asserted. A collision also sets this flag.          7:6 - RO 0 Reserved 5 ssd R/W1C 0 Slave Select Deasserted Flag 4 ssa R/W1C 0 Slave Select Asserted Flag 3 rx_full R/W1C 0 Receive FIFO Full Flag 2 rx_thd R/W1C 0 Receive FIFO Threshold Level Crossed Flag         This field is set when the receive FIFO exceeds the value in SPIn_DMA.rx_lvl. Cleared once receive FIFO level drops below SPIn_DMA.rx_lvl. 1 tx_em R/W1C 1 Transmit FIFO Empty Flag         This field is set if the transmit FIFO is empty.          0 tx_thd R/W1C 0 Transmit FIFO Threshold Level Crossed Flag         This field is set when the transmit FIFO level is less than the value in the SPIn_DMA.tx_lvl field. This field is cleared by hardware when the transmit FIFO level exceeds SPIn_DMA.tx_lvl. <p>Table 13-17: SPI Interrupt Enable Registers </p> SPI Interrupt Enable SPIn_INTEN [0x0024] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 rx_un R/W 0 Receive FIFO Underrun Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          14 rx_ov R/W 0 Receive FIFO Overrun Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          13 tx_un R/W 0 Transmit FIFO Underrun Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          12 tx_ov R/W 0 Transmit FIFO Overrun Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          11 mst_done R/W 0 Master Data Transmission Done Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          10 - RO 0 Reserved 9 abort R/W 0 Slave Mode Abort Detected Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 8 fault R/W 0 Multi-Master Fault Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled          7:6 - RO 0 Reserved 5 ssd R/W 0 Slave Select Deasserted Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 4 ssa R/W 0 Slave Select Asserted Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 3 rx_full R/W 0 Receive FIFO Full Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 2 rx_thd R/W 0 Receive FIFO Threshold Level Crossed Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 1 tx_em R/W 0 Transmit FIFO Empty Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled 0 tx_thd R/W 0 Transmit FIFO Threshold Level Crossed Interrupt Enable          0: Interrupt is disabled         1: Interrupt is enabled <p>Table 13-18: SPI Wakeup Status Flags Registers </p> SPI Wakeup Flags SPIn_WKFL [0x0028] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 rx_full R/W1C 0 Wake on Receive FIFO Full Flag          0: Normal operation         1: Wake condition occurred. 2 rx_thd R/W1C 0 Wake on Receive FIFO Threshold Level Crossed Flag          0: Normal operation         1: Wake condition occurred. 1 tx_em R/W1C 0 Wake on Transmit FIFO Empty Flag          0: Normal operation         1: Wake condition occurred.          0 tx_thd R/W1C 0 Wake on Transmit FIFO Threshold Level Crossed Flag          0: Normal operation         1: Wake condition occurred. <p>Table 13-19: SPI Wakeup Enable Registers </p> SPI Wakeup Enable SPIn_WKEN [0x002C] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 rx_full R/W 0 Wake on Receive FIFO Full Enable          0: Disabled         1: Enabled 2 rx_thd R/W 0 Wake on Receive FIFO Threshold Level Crossed Enable          0: Disabled         1: Enabled          1 tx_em R/W 0 Wake on Transmit FIFO Empty Enable          0: Disabled         1: Enabled 0 tx_thd R/W 0 Wake on Transmit FIFO Threshold Level Crossed Enable          0: Disabled         1: Enabled <p>Table 13-20: SPI Slave Select Timing Registers </p> SPI Status SPIn_STAT [0x0030] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 busy R 0 SPI Active Status         This field indicates the status of the SPI port. See the descriptions for details of each value.                  0: SPI is not active. In master mode, the busy flag is cleared when the last character is sent. In slave mode, the busy field is cleared when the configured slave select input is deasserted.         1: SPI is active. In master mode, the busy flag is set when a transaction starts. In slave mode, the busy flag is set when a configured slave select input is asserted.          <p>Note: SPIn_CTRL0, SPIn_CTRL1, SPIn_CTRL2, SPIn_SSTIME, and SPIn_CLKCTRL should not be configured if this bit is set.</p>"},{"location":"standard-dma/","title":"Standard DMA","text":"<p>The DMA controller is a hardware feature that provides the ability to perform high-speed, block memory transfers of data independent of the device CPU. All DMA transactions consist of a burst read from the source into the internal DMA FIFO followed by a burst write from the internal DMA FIFO to the destination.</p> <p>DMA transfers are one of three types:</p> <ul> <li>From a receive FIFO to a memory address,</li> <li>to a transmit FIFO from a memory address, or</li> <li>from a source memory address to a destination memory address.</li> </ul> <p>The DMA supports multiple channels. Each channel provides the following features:</p> <ul> <li>Full 32-bit source and destination addresses with 24-bit (16 Mbytes) address increment capability</li> <li>The ability to chain DMA buffers when a count-to-zero (CTZ) condition occurs</li> <li>Interrupt upon CTZ</li> <li>Up to 16 Mbytes for each DMA transfer</li> <li>8 \u00d7 32-byte transmit and receive FIFO<ul> <li>Programmable source and destination width with support for byte, half-word, and word</li> </ul> </li> <li>Programmable channel timeout period</li> <li>Programmable burst size</li> <li>Programmable priority</li> <li>Abort on error</li> </ul>"},{"location":"standard-dma/#instances","title":"Instances","text":"<p>There is one instance of the DMA, generically referred to as DMA. Each instance provides four channels, generically referred to as DMA_CHn. Each instance of the DMA has a set of interrupt registers common to all its channels and a set of registers unique to each channel instance.</p> <p>Table 10-1: MAX78000 DMA and Channel Instances </p> DMA Instance DMA_CHn Channel Instance DMA DMA_CH0 DMA_CH1 DMA_CH2 DMA_CH3"},{"location":"standard-dma/#dma-channel-operation-dma_ch","title":"DMA Channel Operation (DMA_CH)","text":""},{"location":"standard-dma/#channel-arbitration-and-dma-bursts","title":"Channel Arbitration and DMA Bursts","text":"<p>The DMA peripheral contains an internal arbiter that allows enabled channels to access the AHB and move data. Once a channel is programmed and enabled, it generates a request to the arbiter immediately (for memory-to-memory DMA) or whenever its associated peripheral requests DMA (for memory-to-peripheral or peripheral-to-memory DMA).</p> <p>Granting is done based on priority; a higher priority request is always granted. Within a given priority level, requests are granted on a round-robin basis. The DMA_CHn_CTRL.pri field determines the DMA channel priority.</p> <p>When a channel's request is granted, the channel runs a DMA transfer. The arbiter grants requests to a single channel at a time. Once the DMA transfer completes, the channel relinquishes its grant.</p> <p>A DMA channel is enabled using the DMA_CHn_CTRL.en bit.</p> <p>When disabling a channel, poll the DMA_CHn_STATUS.status bit to determine if the channel is disabled. In general, DMA_CHn_STATUS.status follows the setting of the DMA_CHn_CTRL.en bit. However, the DMA_CHn_STATUS.status bit is automatically cleared under the following conditions:</p> <ul> <li>Bus error (cleared immediately)</li> <li>CTZ when the DMA_CHn_CTRL.rlden = 0 (cleared at the end of the AHB R/W burst)</li> <li>DMA_CHn_CTRL.en bit transitions to 0 (cleared at the end of the AHB R/W burst)</li> </ul> <p>Whenever DMA_CHn_STATUS.status transitions from 1 to 0, the corresponding DMA_CHn_CTRL.en bit is also cleared. If an active channel is disabled during an AHB read/write burst, the current burst continues until completed.</p> <p>Only an error condition can interrupt an ongoing data transfer.</p>"},{"location":"standard-dma/#source-and-destination-addressing","title":"Source and Destination Addressing","text":"<p>The source and destination for DMA transfers are dictated by the request select dedicated to the peripheral instance. The DMA_CHn_CTRL.request field dictates the source and destination for a channel's DMA transfer, as shown in Table 10-2. depending on the specific operation, the DMA_CHn_SRC and DMA_CHn_DST registers hold the source or destination memory addresses.</p> <p>The DMA_CHn_CTRL.srcinc field is ignored when the DMA source is peripheral memory, and the DMA_CHn_CTRL.dstinc field is ignored when the DMA destination is peripheral memory.</p> <p>Table 10-2: DMA Source and Destination by Peripheral </p> DMA_CHn_CTRL.request Peripheral DMA Source DMA Destination 0 Memory-to-Memory DMA_CHn_SRC DMA_CHn_DST 1 SPI1 SPI1 Receive FIFO DMA_CHn_DST 2-3 Reserved - - 4 UART0 UART0 Receive FIFO DMA_CHn_DST 5 UART1 UART1 Receive FIFO DMA_CHn_DST 6 Reserved - - 7 I2C0 I2C0 Receive FIFO DMA_CHn_DST 8 I2C1 I2C1 Receive FIFO DMA_CHn_DST 9 ADC ADC Data Register DMA_CHn_DST 10 I2C2 I2C2 Receive FIFO DMA_CHn_DST 11-12 Reserved - - 13 PCIF PCIF Receive FIFO DMA_CHn_DST 14 UART 2 UART2 Receive FIFO DMA_CHn_DST 15 SPI 0 SPI0 Receive FIFO DMA_CHn_DST 16-27 Reserved - - 28 LPUART0 (UART 3) UART3 Receive FIFO DMA_CHn_DST 29 Reserved - - 30 I<sup>2</sup>S I<sup>2</sup>S Data Register DMA_CHn_DST 31-32 Reserved - - 33 SPI 1 DMA_CHn_SRC SPI1 Transmit FIFO 34-35 Reserved - - 36 UART 0 DMA_CHn_SRC UART0 Transmit FIFO 37 UART 1 DMA_CHn_SRC UART1 Transmit FIFO 38 Reserved - - 39 I2C0 DMA_CHn_SRC I2C0 Transmit FIFO 40 I2C1 DMA_CHn_SRC I2C1 Transmit FIFO 41 Reserved - - 42 I2C2 DMA_CHn_SRC I2C2 Transmit FIFO 43 Reserved - - 44 CRC DMA_CHn_SRC CRC Data Register 45 PCIF DMA_CHn_SRC PCIF Transmit FIFO 46 UART2 DMA_CHn_SRC UART2 Transmit FIFO 47 SPI0 DMA_CHn_SRC SPI0 Transmit FIFO 48-59 Reserved - - 60 LPUART 0 (UART 3) DMA_CHn_SRC UART3 Transmit FIFO 61 Reserved - - 62 I<sup>2</sup>S DMA_CHn_SRC I<sup>2</sup>S Data Register 63 Reserved - -"},{"location":"standard-dma/#data-movement-from-source-to-dma","title":"Data Movement from Source to DMA","text":"<p>Table 10-3 shows the fields that control the burst movement of data into the DMA FIFO. The source is a peripheral or memory.</p> <p>Table 10-3: Data Movement from Source to DMA FIFO </p> Register/Field Description Comments DMA_CHn_SRC Source address If the increment enable is set, this increments on every read cycle of the burst. This field is ignored when the DMA source is a peripheral. DMA_CHn_CNT Number of bytes to transfer before a CTZ condition occurs This register is decremented on each read of a burst. DMA_CHn_CTRL.burst_size Burst size (1-32) This is the maximum number of bytes moved during the burst read. DMA_CHn_CTRL.srcwd Source width This field determines the maximum data width used during each read of the AHB burst (byte, half-word, or word). The actual AHB width might be less if DMA_CHn_CNT is not great enough to supply all the needed data. DMA_CHn_CTRL.srcinc Source increments enable Increments DMA_CHn_SRC. This field is ignored when the DMA source is a peripheral."},{"location":"standard-dma/#data-movement-from-dma-to-destination","title":"Data Movement from DMA to Destination","text":"<p>Table 10-4 shows the fields that control the burst movement of data out of the DMA FIFO. The destination is a peripheral or memory.</p> <p>Table 10-4: Data Movement from the DMA FIFO to Destination </p> Register/Field Description Comments DMA_CHn_DST Destination address If the increment enable is set, this increments on every write cycle of the burst. This field is ignored when the DMA destination is a peripheral. DMA_CHn_CTRL.burst_size Burst size (1-32) The is the maximum number of bytes moved during a single AHB read/write burst. DMA_CHn_CTRL.dstwd Destination width This determines the maximum data width used during each write of the AHB burst (byte, half-word, or word). DMA_CHn_CTRL.dstinc Destination address increment enable Increments DMA_CHn_DST. This field is ignored when the DMA destination is a peripheral."},{"location":"standard-dma/#usage","title":"Usage","text":"<p>Use the following procedure to perform a DMA transfer from a peripheral's receive FIFO to memory, from memory to a peripheral's transmit FIFO, or from memory to memory.</p> <ol> <li>Ensure DMA_CHn_CTRL.en, DMA_CHn_CTRL.rlden = 0, and DMA_CHn_STATUS.ctz_if = 0.</li> <li>If using memory for the destination of the DMA transfer, configure DMA_CHn_DST to the starting address of the destination in memory.</li> <li>If using memory for the source of the DMA transfer, configure DMA_CHn_SRC to the starting address of the source in memory.</li> <li>Write the number of bytes to transfer to the DMA_CHn_CNT register.</li> <li> <p>Configure the following DMA_CHn_CTRL register fields in one or more instructions. Do not set DMA_CHn_CTRL.en to 1 or DMA_CHn_CTRL.rlden to 1 in this step:</p> <p>a. Configure DMA_CHn_CTRL.request to select the transfer operation associated with the DMA channel.</p> <p>b. Configure DMA_CHn_CTRL.burst_size for the desired burst size.</p> <p>c. Configure DMA_CHn_CTRL.pri to set the channel priority relative to other DMA channels.</p> <p>d. Configure DMA_CHn_CTRL.dstwd to set the width of the data written in each transaction.</p> <p>e. If desired, set DMA_CHn_CTRL.dstinc to 1 to enable automatic incrementing of the DMA_CHn_DST register upon every AHB transaction.</p> <p>f. Configure DMA_CHn_CTRL.srcwd to set the width of the data read in each transaction.</p> <p>g. If desired, set DMA_CHn_CTRL.srcinc to 1 to enable automatic incrementing of the DMA_CHn_DST register upon every AHB transaction.</p> <p>h. If desired, set DMA_CHn_CTRL.dis_ie = 1 to generate an interrupt when the channel becomes disabled. The channel becomes disabled when the DMA transfer completes, or a bus error occurs.</p> <p>i. If desired, set DMA_CHn_CTRL.ctz_ie 1 to generate an interrupt when the DMA_CHn_CNT register is decremented to zero.</p> <p>j. If using the reload feature, configure the reload registers to set the destination, source, and count for the following DMA transaction.</p> <ol> <li>Load the DMA_CHn_SRCRLD register with the source address reload value.</li> <li>Load the DMA_CHn_DSTRLD register with the destination address reload value.   </li> <li>Load the DMA_CHn_CNTRLD register with the count reload value.</li> </ol> <p>k. If desired, enable the channel timeout feature described in Channel Timeout Detect. Clear DMA_CHn_CTRL.to_clkdiv to 0 to disable the channel timeout feature.</p> </li> <li> <p>Set DMA_CHn_CTRL.rlden to 1 to enable the reload feature if using.</p> </li> <li>Set DMA_CHn_CTRL.en = 1 to start the DMA transfer immediately.</li> <li>Wait for the interrupt flag to become 1 to indicate the completion of the DMA transfer.</li> </ol>"},{"location":"standard-dma/#count-to-zero-ctz-condition","title":"Count-To-Zero (CTZ) Condition","text":"<p>When an AHB channel burst completes, a CTZ condition exists if  DMA_CHn_CNT is decremented to 0. At this point, there are two responses are possible depending on the value of the DMA_CHn_CTRL.rlden:</p> <ol> <li> <p>If DMA_CHn_CTRL.rlden = 1, then the DMA_CHn_SRC, DMA_CHn_DST, and  DMA_CHn_CNT registers are loaded from the reload registers, and the channel remains active and continues operating using the newly-loaded address/count values and the previously programmed configuration values.</p> </li> <li> <p>If DMA_CHn_CTRL.rlden = 0, then the channel is disabled, and DMA_CHn_STATUS.status is cleared.</p> </li> </ol>"},{"location":"standard-dma/#chaining-buffers","title":"Chaining Buffers","text":"<p>Chaining buffers reduce the DMA interrupt response time and allow the DMA to service requests without intermediate processing from the CPU. Figure 10-1 shows the procedure for generating a DMA transfer using one or more chain buffers.</p> <p>Configure the following reload registers to configure a channel for chaining:</p> <ul> <li>DMA_CHn_SRC</li> <li>DMA_CHn_DST</li> <li>DMA_CHn_CNT</li> <li>DMA_CHn_SRCRLD</li> <li>DMA_CHn_DSTRLD</li> <li>DMA_CHn_CNTRLD</li> </ul> <p>Writing to any register while a channel is disabled is supported, but there are certain restrictions when a channel is enabled. The DMA_CHn_STATUS.status bit indicates whether the channel is enabled or not. Because an active channel might be in the middle of an AHB read/write burst, do not write to the DMA_CHn_SRC,DMA_CHn_DST, or DMA_CHn_CNT registers while a channel is active (DMA_CHn_STATUS.status = 1). To disable any DMA channel, clear the DMA_INTEN.ch bit. Then, poll the DMA_CHn_STATUS.status bit to verify that the channel is disabled. <p></p>"},{"location":"standard-dma/#dma-interrupts","title":"DMA Interrupts","text":"<p>Enable interrupts for each channel by setting DMA_INTEN.ch. When an interrupt for a channel is pending, the corresponding DMA_INTFL.ch = 1. Set the corresponding enable bit to cause an interrupt when the flag is set. <p>A channel interrupt (DMA_CHn_STATUS.ipend = 1) is caused by:</p> <ul> <li>DMA_CHn_CTRL.ctz_ie = 1<ul> <li>If enabled, all CTZ occurrences set the DMA_CHn_STATUS.ipend bit.</li> </ul> </li> <li>DMA_CHn_CTRL.dis_ie = 1<ul> <li>If enabled, any clearing of the DMA_CHn_STATUS.status bit sets the DMA_CHn_STATUS.ipend bit. </li> </ul> </li> </ul> <p>Examine the DMA_CHn_STATUS register to determine which reasons caused the disable. The DMA_CHn_CTRL.dis_ie bit also enables the DMA_CHn_STATUS.to_if bit. The DMA_CHn_STATUS.to_if bit does not clear the DMA_CHn_STATUS.status bit.</p> <p>To clear the channel interrupt, write 1 to the cause of the interrupt (the DMA_CHn_STATUS.ctz_if, DMA_CHn_STATUS.rld_if, DMA_CHn_STATUS.bus_err, or DMA_CHn_STATUS.to_if bits).</p> <p>When running in normal mode without buffer chaining (DMA_CHn_CTRL.rlden = 0), set the DMA_CHn_CTRL.dis_ie bit only. An interrupt is generated upon DMA completion or an error condition (bus error or timeout error).</p> <p>When running in buffer chaining mode (DMA_CHn_CTRL.rlden = 1), set both the DMA_CHn_CTRL.dis_ie and DMA_CHn_CTRL.ctz_ie bits. The CTZ interrupts occur on completion of each DMA (count reaches zero, and reload occurs). The setting of DMA_CHn_CTRL.dis_ie ensures that an error condition generates an interrupt. If DMA_CHn_CTRL.ctz_ie = 0, then the only interrupt occurs when the DMA completes and DMA_CHn_CTRL.rlden = 0 (final DMA).</p>"},{"location":"standard-dma/#channel-timeout-detect","title":"Channel Timeout Detect","text":"<p>Each channel can optionally generate an interrupt when its associated peripheral does not request a transfer in a user-configurable period. When the timeout start conditions are met, an internal 10-bit counter begins incrementing at a frequency determined by the AHB clock, the DMA_CHn_CTRL.to_clkdiv field, and the DMA_CHn_CTRL.to_per field. See Table 10-5 for details. A channel timeout event is generated if the timer is not reset by one of the events listed below before the timeout period expires.</p> <p>Table 10-5: DMA Channel Timeout Configuration </p> DMA_CHn_CTRL.to_clkdiv Timeout Period (\u00b5s) 0 Channel timeout disabled. 1      $$     \\frac{2^{8} \\times \\text{Value from } \\texttt{DMA_CHn_CTRL.to_per}}{f_{HCLK}}     $$      2      $$     \\frac{2^{16} \\times \\text{Value from } \\texttt{DMA_CHn_CTRL.to_per}}{f_{HCLK}}     $$      3      $$     \\frac{2^{24} \\times \\text{Value from } \\texttt{DMA_CHn_CTRL.to_per}}{f_{HCLK}}     $$      <p>DMA_CHn_CTRL.to_wait controls the start of the timeout period as follows: - If DMA_CHn_CTRL.to_wait = 0, the timer begins immediately counting after DMA_CHn_CTRL.to_per is configured to a value other than 0, and the channel is enabled. - If DMA_CHn_CTRL.to_wait = 1, the timer begins counting when the first DMA request is received from the peripheral.</p> <p>The timer is reset whenever: - The DMA request line programmed for the channel is activated. - The channel is disabled for any reason (DMA_CHn_STATUS.status = 0).</p> <p>If the timeout timer period expires, hardware sets DMA_CHn_STATUS.to_if = 1 to indicate a channel timeout event has occurred. A channel timeout does not disable the DMA channel.</p>"},{"location":"standard-dma/#memory-to-memory-dma","title":"Memory-to-Memory DMA","text":"<p>Memory-to-memory transfers are processed as if the request is permanently active. This means that the DMA channel generates an almost constant request for the bus until its transfer is complete. For this reason, assign a lower priority to channels executing memory-to-memory transfers to prevent starvation of other DMA channels.</p>"},{"location":"standard-dma/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 10-6: DMA Register Summary </p> Offset Register Description [0x0000] DMA_INTEN DMA Channel Interrupt Enable [0x0004] DMA_INTFL DMA Interrupt Status register"},{"location":"standard-dma/#register-details","title":"Register Details","text":"<p>Table 10-7: DMA Interrupt Enable Register </p> DMA Interrupt Enable DMA_INTEN [0x0000] Bits Name Access Reset Description 31:0 ch&lt;n&gt; R/W 0 DMA Channel n Interrupt Enable             Each bit in this field enables the corresponding channel interrupt &lt;n&gt; in DMA_INTFL.              Register bits associated with unimplemented channels should not be changed from their default reset value.                  0: Disabled                 1: Enabled              <p>Table 10-8: DMA Interrupt Status Register </p> DMA Interrupt Flag DMA_INTFL [0x0004] Bits Name Access Reset Description 31:0 ch&lt;n&gt; R/W 0 DMA Channel n Interrupt Flag             Each bit in this field represents an interrupt for the corresponding channel interrupt &lt;n&gt;. To clear an interrupt, clear the corresponding active interrupt bit in the DMA_CHn_STATUS register. An interrupt bit in this field is set if the corresponding interrupt enable field is set in the DMA_INTEN register and a channel's interrupt occurs. Register bits associated with unimplemented channels should be ignored.                  0: No interrupt                 1: Interrupt pending"},{"location":"standard-dma/#dma-channel-registers","title":"DMA Channel Registers","text":"<p>Table 10-9: Standard DMA Channel 0 to Channel 3 Register Summary </p> Offset DMA Channel Description [0x0100] DMA_CH0 DDMA Channel 0 [0x0120] DMA_CH1 DDMA Channel 1 [0x0140] DMA_CH2 DDMA Channel 2 [0x0160] DMA_CH3 DDMA Channel 3"},{"location":"standard-dma/#channel-register-details","title":"Channel Register Details","text":"<p>See Table 3-3 for the base address of this peripheral/module. If multiple instances of the peripheral are provided, each instance has its own independent set of the registers shown in Table 10-10. Register names for a specific instance are defined by replacing \"n\" with the instance number. As an example, a register PERIPHERALn_CTRL resolves to PERIPHERAL0_CTRL and PERIPHERAL1_CTRL for instances 0 and 1, respectively.</p> <p>See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 10-10: DMA Channel Registers Summary </p> Offset Register Description [0x0000] DMA_CHn_CTRL DMA Channel n Configuration Register [0x0004] DMA_CHn_STATUS DMA Channel n Status Register [0x0008] DMA_CHn_SRC DMA Channel n Source Register [0x000C] DMA_CHn_DST DMA Channel n Destination Register [0x0010] DMA_CHn_CNT DMA Channel n Count Register [0x0014] DMA_CHn_SRCRLD DMA Channel n Source Reload Register [0x0018] DMA_CHn_DSTRLD DMA Channel n Destination Reload Register [0x001C] DMA_CHn_CNTRLD DMA Channel n Count Reload Register <p>Table 10-11: DMA_CH n Control Register </p> DMA Channel n Control DMA_CHn_CTRL [0x0000] Bits Name Access Reset Description 31 ctz_ie R/W 0 CTZ Interrupt Enable                  0: Disabled                 1: Enabled. DMA_INTFL.ch&lt;n&gt; is set to 1 whenever a CTZ event occurs.              30 dis_ie R/W 0 Channel Disable Interrupt Enable                0: Disabled               1: Enabled. DMA_INTFL.ch&lt;n&gt; bit is set to 1 whenever                DMA_CHn_STATUS.status changes from 1 to 0.            29 - RO 0 Reserved 28:24 burst_size R/W 0 Burst SizeThe number of bytes transferred into and out of the DMA FIFO in a   single burst.        0b00000: 1 byte     0b00001: 2 bytes     0b00010: 3 bytes     ...     0b11111: 32 bytes 23 - RO 0 Reserved 22 dstinc R/W 0 Destination Increment Enable     This bit enables the automatic increment of the DMA_CHn_DST register upon every AHB transaction. This bit is ignored for a DMA transmit to peripherals.      0: Disabled     1: Enabled      21:20 dstwd R/W 0 Destination WidthIndicates the width of each AHB transaction to the destination peripheral or memory (the actual width might be less than this if there are insufficient bytes in the DMA FIFO for the full width).          0: Byte     1: Half word     2: Word     3: Reserved 19 - RO 0 Reserved 18 srcinc R/W 0 Source Increment on AHB Transaction EnableThis bit enables the automatic increment of the DMA_CHn_SRC register upon every AHB transaction. This bit is ignored for a DMA receive from peripherals.          0: Disabled     1: Enabled      17:16 srcwd R/W 0 Source WidthThis field indicates the width of each AHB transaction from the source peripheral or memory. The actual width might be less than this if the DMA_CHn_CNT register indicates a smaller value.          0: Byte     1: Half word     2: Word     3: Reserved      15:14 to_clkdiv R/W 0 Timeout Timer Clock Pre-Scale SelectThis field selects the pre-scale divider for the timer clock   input.    0: Timer disabled. 1:                $$               \\frac{f_{\\text{HCLK}}}{2^8}               $$               2:                $$             \\frac{f_{HCLK}}{2^{16}}             $$               3:                $$               \\frac{f_{HCLK}}{2^{24}}               $$               13:11 to_per R/W 0 Timeout Period Select  This field selects the number of pre-scaled clocks seen by the channel timer before a timeout condition is generated. The value is approximate because of synchronization delays between timers.      0: 3 to 4   1: 7 to 8   2: 15 to 16   3: 31 to 32   4: 63 to 64   5: 127 to 128   6: 255 to 256   7: 511 to 512    10 to_wait R/W 0 Request DMA Timeout Timer Wait Enable This field controls when the timeout timer starts, either immediately when the timeout timer is enabled or after the first DMA transaction occurs.          0: Start the timer immediately when enabled.     1: Delay the timer's start until after the first DMA transaction occurs.      9:4 request R/W 0 Request Select Selects the source and destination for the transfer as shown in Source and Destination Addressing. 3:2 pri R/W 0 Channel Priority This field sets the priority of the channel relative to other channels of the DMA peripheral. Channels of the same priority are serviced in a round-robin fashion.          0: High     1: Medium-high     2: Medium-low     3: Low       1 rlden R/W 0 Reload Enable Setting this bit to 1 allows reloading the DMA_CHn_SRC, DMA_CHn_DST, and DMA_CHn_CNT registers upon a CTZ.   When this bit is set to 0 and a CTZ occurs, the channel is disabled, and the DMA_CHn_STATUS.status bit is set to 0.      0: The channel is disabled when a CTZ occurs, and the DMA_CHn_STATUS.status is set to 0.   1: Automatically reload the DMA_CHn_SRC, DMA_CHn_DST, and DMA_CHn_CNT registers on a CTZ.    0 en R/W 0 Channel Enable This bit is automatically cleared when DMA_CHn_STATUS.status changes from 1 to 0.          0: Disabled     1: Enabled      <p>Table 10-12: DMA Status Register </p> DMA Channel n Status DMA_CHn_STATUS [0x0004] Bits Name Access Reset Description 31:7 - RO 0 Reserved 6 to_if R/W1C 0 Timeout Interrupt Flag             Timeout. Write 1 to clear.                                      0: No time out.                     1: A channel timeout has occurred.                  5 - RO 0 Reserved 4 bus_err R/W1C 0 Bus Error             If this bit reads 1, an AHB abort occurred, and the channel was disabled by hardware. Write 1 to clear.                                      0: No error found.                     1: An AHB bus error occurred.                  3 rld_if R/W1C 0 Reload Interrupt Flag             Reload. Write 1 to clear.                                      0: Reload has not occurred.                     1: Reload occurred.                  2 ctz_if R/W1C 0 CTZ Interrupt Flag             Write 1 to clear.                                      0: CTZ has not occurred.                     1: CTZ has occurred.                  1 ipend RO 0 Channel Interrupt Pending                      0: No interrupt.                     1: Interrupt pending.                  0 status RO 0 Channel Status             This bit indicates when it is safe to change the configuration, address, and count registers for the channel.                          Whenever this bit is cleared by hardware, the                     DMA_CHn_CTRL.en bit is also cleared.                     0: Disabled.                     1: Enabled.                  <p>Table 10-13: DMA Channel n Source Register </p> DMA Channel n Source Register DMA_CHn_SRC [0x0008] Bits Name Access Reset Description 31:0 addr R/W 0 Source Device Address For peripheral transfers, the actual address field is either ignored or forced to zero because peripherals only have one location to read/write data based on the request select chosen. <p>If DMA_CHn_CTRL.srcinc = 1, then this register is incremented on each AHB transfer cycle by one, two, or four bytes depending on the data width.</p> <p>If DMA_CHn_CTRL.srcinc = 0, this register remains constant.</p> <p>Suppose a CTZ condition occurs while DMA_CHn_CTRL.rlden = 1, then this register is reloaded with the contents of the DMA_CHn_SRCRLD register.</p> <p>Table 10-14: DMA Channel n Destination Register </p> DMA Channel n Destination DMA_CHn_DST [0x000C] Bits Name Access Reset Description 31:0 addr R/W 0 Destination Device Address For peripheral transfers, the actual address field is either ignored or forced to zero because peripherals only have one location to read/write data based on the request select chosen. <p>If DMA_CHn_CTRL.dstinc = 1, then this register is incremented on every AHB transfer cycle by one, two, or four bytes depending on the data width.</p> <p>Suppose a CTZ condition occurs while DMA_CHn_CTRL.rlden = 1, then this register is reloaded with the contents of the DMA_CHn_DSTRLD register.</p> <p>Table 10-15: DMA Channel n Count Register </p> DMA Channel n Count Register DMA_CHn_CNT [0x0010] Bits Name Access Reset Description 31:24 - RO 0 Reserved 23:0 cnt R/W 0 DMA Counter Load this register with the number of bytes to transfer. This field decreases on every AHB access to the DMA FIFO. The decrement is one, two, or four bytes depending on the data width. When the counter reaches 0, a CTZ condition is triggered. <p>Suppose a CTZ condition occurs while DMA_CHn_CTRL.rlden = 1, then this register is reloaded with the contents of the DMA_CHn_CNTRLD.cnt field.</p> <p>Table 10-16: DMA Channel n Source Reload Register </p> DMA Channel n Source Reload DMA_CHn_SRCRLD [0x0014] Bits Name Access Reset Description 31 - RO 0 Reserved 30:0 addr R/W 0 Source Address Reload Value If DMA_CHn_CTRL.rlden = 1, then the value of this register is loaded into DMA_CHn_SRC upon a CTZ condition. <p>Table 10-17: DMA Channel n Destination Reload Register </p> DMA Channel n Destination Reload DMA_CHn_DSTRLD [0x0018] Bits Name Access Reset Description 31 - RO 0 Reserved 30:0 addr R/W 0 Destination Address Reload ValueIf DMA_CHn_CTRL.rlden = 1, then the value of this register is loaded into DMA_CHn_DST upon a CTZ condition.  <p>Table 10-17: Table 10-18: DMA Channel n Count Reload Register </p> DMA Channel n Count Reload DMA_CHn_CNTRLD [0x001C] Bits Name Access Reset Description 31:24 - RO 0 Reserved 23:0 cnt R/W 0 Count Reload Value  If DMA_CHn_CTRL.rlden = 1, then the value of this register is loaded into DMA_CHn_CNT upon a CTZ condition."},{"location":"system-power-clocks-reset/","title":"System, Power, Clocks, Reset","text":"<p>Different peripherals and subsystems use several clocks. These clocks are highly configurable by software, allowing developers to select the combination of application performance and power savings required for the target systems. Support for selectable core operating voltage is provided, enabling optimal timing access to the internal memories.</p>"},{"location":"system-power-clocks-reset/#oscillator-sources","title":"Oscillator Sources","text":""},{"location":"system-power-clocks-reset/#100mhz-internal-primary-oscillator-ipo","title":"100MHz Internal Primary Oscillator (IPO)","text":"<p>The MAX78000 includes a 100MHz internal high-speed oscillator, referred to in this document as the internal primary oscillator (IPO). The IPO is the highest frequency oscillator and draws the most power.</p> <p>The IPO can optionally be powered down in LPM by setting the GCR_PM.ipo_pd field to 1.</p> <p>The IPO can be selected as the SYS_OSC. Use the IPO as the SYS_OSC by performing the following steps:</p> <ol> <li>Enable the IPO by setting GCR_CLKCTRL.ipo_en to 1.</li> <li>Wait until the GCR_CLKCTRL.ipo_rdy field reads 1, indicating the IPO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 4.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The IPO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#60mhz-internal-secondary-oscillator-iso","title":"60MHz Internal Secondary Oscillator (ISO)","text":"<p>The ISO is a low-power internal secondary oscillator that is the power-on reset default SYS_OSC. The ISO is automatically selected as SYS_OSC after a system reset or POR.</p> <p>The following steps show how to enable the ISO and select it as the SYS_OSC.</p> <ol> <li>Enable the ISO by setting GCR_CLKCTRL.iso_en to 1.</li> <li>Wait until the GCR_CLKCTRL.iso_rdy field reads 1, indicating the ISO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 0.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The ISO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#8khz-30khz-internal-nano-ring-oscillator-inro","title":"8kHz-30kHz Internal Nano-Ring Oscillator (INRO)","text":"<p>The INRO is an ultra-low-power internal oscillator that can be selected as the SYS_OSC. The INRO is always enabled and cannot be disabled by software.</p> <p>The frequency of this oscillator is configurable to 8kHz, 16kHz, or 30kHz. Use the TRIMSIR_INRO.lpclksel field to select the desired frequency. On a POR or system reset, the frequency defaults to 30kHz.</p> <p>The following steps show how to set the INRO as the SYS_OSC.</p> <ol> <li>Verify the GCR_CLKCTRL.inro_rdy field reads 1.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 3.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The INRO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#73728mhz-internal-baud-rate-oscillator-ibro","title":"7.3728MHz Internal Baud Rate Oscillator (IBRO)","text":"<p>The IBRO is a very low-power internal oscillator that can be selected as SYS_OSC. The INRO can optionally be used as a dedicated baud rate clock for the UARTs. The INRO is useful if the selected SYS_OSC does not accurately generate a desired UART baud rate.</p> <p>The following steps show how to enable the IBRO and select it as the SYS_OSC.</p> <ol> <li>Wait until the GCR_CLKCTRL.ibro_rdy field reads 1, indicating the IBRO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 5.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The IBRO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#32768khz-external-real-time-clock-oscillator-ertco","title":"32.768kHz External Real-Time Clock Oscillator (ERTCO)","text":"<p>The ERTCO is an extremely low-power internal oscillator that can be selected as the SYS_OSC. The ERTCO can optionally use a 32.768kHz input clock or an 8kHz independent nano-ring oscillator instead of an external crystal. The internal 32.768kHz clock is available as an output on GPIO P3.1 as alternate function 1 (SQWOUT).</p> <p>This oscillator is the default clock for the real-time clock (RTC). If the RTC is enabled, the ERTCO is enabled automatically, independent of the selection of the SYS_OSC. The ERTCO is disabled on a POR or system reset.</p> <p>The following steps show how to enable the ERTCO and select it as the SYS_OSC.</p> <ol> <li>Enable the ERTCO by setting GCR_CLKCTRL.ertco_en to 1.</li> <li>Wait until the GCR_CLKCTRL.ertco_rdy field reads 1, indicating the ERTCO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 6.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The ERTCO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#system-oscillator-sys_osc","title":"System Oscillator (SYS_OSC)","text":"<p>The MAX78000 supports multiple clock sources as the SYS_OSC. The selected SYS_OSC is the clock source for most internal blocks. Each oscillator, description, and nominal frequency are shown in Table 4-1. An external clock source, EXT_CLK, is supported on P0.3, alternate function 1. Each of the oscillators/clocks is described in detail in section Oscillator Sources.</p> <p>Table 4-1: Available System Oscillators </p> Oscillator/Clock Description Nominal Frequency IPO Internal Primary Oscillator 100MHz ISO Internal Secondary Oscillator 60MHz INRO Internal Nano-Ring Oscillator Configurable 8kHz, 16kHz, or 30kHz IBRO Internal Baud Rate Oscillator 7.3728MHz ERTCO External Real-Time Clock Oscillator 32.768kHz EXT_CLK External Clock Up to 80MHz"},{"location":"system-power-clocks-reset/#system-oscillator-selection","title":"System Oscillator Selection","text":"<p>Set the system oscillator using the GCR_CLKCTRL.sysclk_sel field. Before selecting an oscillator as the system oscillator, the oscillator source must first be enabled and ready. See each oscillator source\u2019s detailed description for the required steps to enable the oscillator and select it as the system oscillator.</p> <p>When the GCR_CLKCTRL.sysclk_sel is modified, hardware clears the GCR_CLKCTRL.sysclk_rdy field, and there is a delay until the switchover is complete. When the switchover to the selected SYS_OSC is complete, the GCR_CLKCTRL.sysclk_rdy field is set to 1 by hardware. The application software must verify that the switchover is complete before continuing operation.</p>"},{"location":"system-power-clocks-reset/#system-clock-sys_clk","title":"System Clock (SYS_CLK)","text":"<p>The selected SYS_OSC is the input to the system oscillator divider to generate the system clock (SYS_CLK). The system clock divider divides the selected SYS_OSC by the GCR_CLKCTRL.sysclk_div field, as shown in Equation 4-1.</p> <p>Equation 4-1: System Clock Scaling </p> <p>SYS_CLK = SYS_OSC / 2<sup>sysclk_div</sup></p> <p>GCR_CLKCTRL.sysclk_div is selectable from 0 to 7, resulting in divisors of 1, 2, 4, 8, 16, 32, 64 or 128.</p> <p>SYS_CLK drives the Arm core, the RV32 core, and all AHB masters in the system. SYS_CLK generates the following internal clocks as shown below:</p> <ul> <li>AHB Clock<ul> <li>HLCK = SYS_CLK</li> </ul> </li> <li>APB Clock<ul> <li>PCLK = SYS_CLK / 2</li> </ul> </li> </ul> <p>The RTC uses the ERTCO for its clock source. Optionally, the RTC can run using an internal dedicated 8kHz nano-ring oscillator. See the Real-Time Clock (RTC) chapter for details on using this 8kHz nano-ring oscillator for the RTC.</p> <p>All oscillators are reset to their POR reset default state during:</p> <ul> <li>Power-On Reset</li> <li>System Reset</li> </ul> <p>Oscillator settings are not reset during:</p> <ul> <li>Soft Reset</li> <li>Peripheral Reset</li> </ul> <p>Table 4-2 shows each oscillator\u2019s enabled state for each type of reset source in the MAX78000.</p> <p>Note: A Watchdog Timer Reset performs a System Reset.</p> <p>Table 4-2: Reset Sources and Effect on Oscillator and System Clock </p> Reset Source Oscillator POR System Soft Peripheral IPO Disabled Disabled Retains State Retains State ISO Enabled Enabled Retains State Retains State IBRO Enabled Enabled Enabled Enabled INRO Enabled Enabled Enabled Enabled ERTCO Disabled Disabled Retains State Retains State System Clock(SYS_OSC) Source ISO ISO Retains State Retains State <p>Figure 4-1: MAX78000 Clock Block Diagram shows a high-level diagram of the MAX78000 clock tree.</p> <p>Figure 4-1: MAX78000 Clock Block Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#operating-modes","title":"Operating Modes","text":"<p>The MAX78000 includes multiple operating modes and the ability to fine-tune power options to optimize performance and power. The system supports the following operating modes:</p> <ul> <li>ACTIVE</li> <li>SLEEP</li> <li>Low-Power Mode (LPM)</li> <li>Micro Power Mode (UPM)</li> <li>STANDBY</li> <li>BACKUP</li> <li>Power Down Mode (PDM)</li> </ul>"},{"location":"system-power-clocks-reset/#active-mode","title":"ACTIVE Mode","text":"<p>In this mode, both the CM4 and the RV32 cores can execute software, and all digital and analog peripherals are available on demand. Dynamic clocking disables peripheral not in use, providing the optimal mix of high performance and low power consumption. The CM4 has access to all System RAM by default. The RV32 has access to sysram2 and sysram3 and can be optionally configured to have exclusive access to these RAMs. Additionally, sysram3 can be configured as a unified internal cache controller for the RV32 allowing simultaneous data access and code execution for the CM4 and RV32 from the internal flash memory.</p> <p>Each of the peripherals can be individually enabled during active mode or powered down. The CNN and each of the four CNNx16_n Processor Arrays and their associated memories can be powered down or set to active mode.</p>"},{"location":"system-power-clocks-reset/#low-power-modes","title":"Low-Power Modes","text":""},{"location":"system-power-clocks-reset/#sleep","title":"SLEEP","text":"<p>This mode consumes less power but wakes faster because the clocks can optionally be enabled. The device status is as follows:</p> <ul> <li>The CM4 (CPU0) is sleeping</li> <li>The RV32 (CPU1) is sleeping</li> <li>The CNN is optionally available for use</li> <li>Each of the four CNNx16_n quadrants is individually configurable for power down</li> <li>Standard DMA is available for use</li> <li>All peripherals are on unless explicitly disabled before entering SLEEP</li> </ul>"},{"location":"system-power-clocks-reset/#entering-sleep","title":"Entering SLEEP","text":"<p>Entering SLEEP requires both the CM4 and RV32 to cooperate to enter SLEEP. Synchronization is necessary for deterministic entry into SLEEP. Two methods are described below, allowing either core to request entry into SLEEP. Both methods use the semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to SLEEP, the RV32 notifies the CM4 of a request to enter SLEEP using Multiprocessor Communications. The CM4 receives the notification and then sends confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting the SCR.sleepdeep field to 0 and performing a WFI or WFE instruction. The RV32 should then enter SLEEP by performing a WFI instruction or by setting GCR_PM.mode to 1, followed by two NOP instructions.</p> <p>Alternatively, the CM4 can initiate the request to enter SLEEP by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction followed by two NOP instructions. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction or by setting GCR_PM.mode to 1.</p> <p>Figure 4-2: SLEEP Mode Clock Control </p> <p></p>"},{"location":"system-power-clocks-reset/#lpm","title":"LPM","text":"<p>This mode is suitable for running the RV32 processor to collect and move data from enabled peripherals. The device status is a follows:</p> <ul> <li>The CM4, sysram0, and sysram1 are in state retention</li> <li>The CNN quadrants and memory are active and configurable.</li> <li>The RV32 can access the SPI, UARTS, Timers, I2C, 1-Wire, Timers, Pulse Train Engine, I2S, CRC, AES, TRNG, Comparators, as well as sysram2 and sysram3. Sysram3 can be configured to operate as the RV32 unified instruction cache</li> <li>The transition from LPM to ACTIVE is faster than the transition from BACKUP to ACTIVE because system initialization is not required</li> <li>The DMA is in state retention mode</li> <li>PWRSEQ_GP0 and PWRSEQ_GP1 registers retain state</li> <li>Choose the system PCLK or ISO as the clock source for the RV32 and all peripherals <ul> <li>PWRSEQ_LPCN.lpmclksel defaults to use ISO during LPM. Setting this field to 1 uses the PCLK</li> </ul> </li> <li>The following oscillators are powered down by default, but can be configured by software to remain active:<ul> <li>ISO</li> <li>IPO</li> <li>ERTCO</li> <li>INRO</li> </ul> </li> <li>The following oscillator is enabled:<ul> <li>IBRO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-lpm","title":"Entering LPM","text":"<p>Entry into LPM should be managed between the two cores using Multiprocessor Communications to ensure both cores are in a known state when entering LPM.</p> <p>When the CM4 puts itself into deep sleep, the device automatically enters LPM, and hardware sets the GCR_PM.mode to LPM. To place the CM4 in LPM mode in software, perform the following instructions.</p> <pre><code>SCR.sleepdeep = 1;  // deep sleep mode enabled\n\nWFI (or WFE);   // Enter deep sleep mode\n</code></pre> <p>If the RV32 requests the CM4 to enter LPM mode through Multiprocessor Communications and the CM4 enters SLEEP instead, by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction, the RV32 can put the device into LPM by directly setting the GCR_PM.mode field to LPM (8).</p> <p>Note: The device immediately enters LPM when the GCR_PM.mode field is set to LPM. If the CM4 is not in a known state, issues may occur when exiting LPM.</p> <p>Figure 4-3: LPM Clock and State Retention Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#upm","title":"UPM","text":"<p>This mode is used for extremely low power consumption while using a minimal set of peripherals to provide wake-up capability. The device status during UPM is:</p> <ul> <li>Both CM4 and RV32 are state retained.</li> <li>System state and all system RAM are retained</li> <li>CNN quadrants are optionally powered off</li> <li>CNN memory provides selectable retention</li> <li>The GPIO pins retain their state</li> <li>All non-UPM peripherals are state retained</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>IBRO</li> <li>ERTCO, firmware configurable</li> <li>INRO, firmware configurable</li> </ul> </li> <li>The following UPM peripherals are available for use to wake the device:<ul> <li>LPUART0</li> <li>LPTMR0</li> <li>LPTMR1</li> <li>LPWDT0</li> <li>LPCOMP0-LPCOMP3</li> <li>GPIO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-upm","title":"Entering UPM","text":"<p>Entering UPM mode requires both the CM4 and RV32 to cooperate to enter UPM mode. Synchronization is necessary for deterministic entry into UPM. Two methods are described below, allowing either core to request entry into UPM and ensuring deterministic entry. Both methods use the Semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to UPM, the RV32 notifies the CM4 of a request to enter UPM using Multiprocessor Communications. The CM4 receives the notification and then sends a confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction. The RV32 sets the GCR_PM.mode to UPM, followed by two NOP instructions, and the device immediately enters UPM.</p> <p>Alternatively, the CM4 can initiate the request to enter UPM by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction, followed by two NOP instructions. The CM4 then sets the GCR_PM.mode to UPM, and the device immediately enters UPM.</p> <p>Figure 4-4: UPM Clock and State Retention Block Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#standby","title":"STANDBY","text":"<p>This mode is used to maintain the system operation while keeping time with the RTC. The device status is as follows:</p> <ul> <li>Both CM4 and RV32 are state retained.</li> <li>System state and all system RAM is retained</li> <li>CNN quadrants are powered off</li> <li>CNN memory provides selectable retention (optional state retention)</li> <li>GPIO pins retain their state</li> <li>All peripherals retain state</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> <li>IBRO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>ERTCO, firmware configurable</li> <li>INRO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-standby","title":"Entering STANDBY","text":"<p>Entering STANDBY requires both the CM4 and RV32 to enter STANDBY mode. Synchronization is necessary for deterministic entry into STANDBY. Two methods are described below, allowing either core to request entry into STANDBY and ensuring deterministic entry. Both methods use the semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to STANDBY, the RV32 notifies the CM4 of a request to enter STANDBY using Multiprocessor Communications. The CM4 receives the notification and then sends a confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction. The RV32 sets the GCR_PM.mode to STANDBY, followed by two NOP instructions, and the device immediately enters into STANDBY.</p> <p>Alternatively, the CM4 can initiate the request to enter STANDBY by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction followed by two NOP instructions. The CM4 then sets the GCR_PM.mode to STANDBY, and the device immediately enters STANDBY.</p> <p>Figure 4-5: STANDBY Mode Clock and State Retention Block Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#backup","title":"BACKUP","text":"<p>This mode is used to maintain the System RAM. The device status is as follows:</p> <ul> <li>CM4 and RV32 are powered off.</li> <li>Sysram0, sysram1, sysram2, and sysram3 can be independently configured for state retention, as shown in Table 4-3.</li> <li>User-configurable CNN memory retention</li> <li>All peripherals are powered off</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> <li>IBRO</li> <li>INRO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>ERTCO (The RTC peripheral can be turned off, but not the oscillator)</li> </ul> </li> </ul> <p>Table 4-3 System RAM Retention in BACKUP Mode </p> RAM Block # Size State Retention Control sysram0 32KB + ECC if enabled PWRSEQ_LPCN.ramret0 sysram1 32KB PWRSEQ_LPCN.ramret1 sysram2 48KB PWRSEQ_LPCN.ramret2 sysram3 16KB PWRSEQ_LPCN.ramret3"},{"location":"system-power-clocks-reset/#entering-backup","title":"Entering BACKUP","text":"<p>Entering BACKUP mode does not require synchronization between the RV32 and CM4 cores. However, it is recommended that Multiprocessor Communications are used to ensure both cores are aware of entry into BACKUP and complete any memory transactions before entry.</p> <p>Either core can set GCR_PM.mode to BACKUP, and the device immediately enters BACKUP.</p> <p>Figure 4-6: BACKUP Mode Clock and State Retention Block Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#pdm","title":"PDM","text":"<p>This mode is used during product level distribution and storage. The device status is as follows:</p> <ul> <li>The CM4 and RV32 are powered off</li> <li>All peripherals and all RAMs are powered down</li> <li>All oscillators are powered down</li> <li>There is no data retention in this mode, but values in the flash are preserved</li> <li>V<sub>REGI</sub> POR voltage monitor is operational.</li> <li>Exit from PDM is possible through an external reset (RSTN) or a wake-up event using either P3.0 or P3.1 if configured.</li> </ul>"},{"location":"system-power-clocks-reset/#entering-pdm","title":"Entering PDM","text":"<p>Entering PDM does not require synchronization between the RV32 and CM4 cores. However, it is recommended that Multiprocessor Communications is used to ensure both cores are aware of entry into PDM and complete any flash memory transactions.</p> <p>Either core can set GCR_PM.mode to PDM, and the device immediately enters PDM.</p> <p>Figure 4-7: PDM Clock and State Retention Block Diagram </p> <p></p>"},{"location":"system-power-clocks-reset/#wake-up-sources-for-each-operating-mode","title":"Wake-Up Sources for Each Operating Mode","text":"<p>In all operating modes other than ACTIVE, wake-up sources are required to re-enter ACTIVE operation. Table 4-4 shows available wake-up sources for each operating mode of the MAX78000.</p> <p>Note: Each wake-up source must be enabled individually except for External Reset, which is hardware controlled.</p> <p>Table 4-4: Wake-Up Sources for Each Operating Mode in the MAX78000 </p> Operating Mode Any Peripheral Interrupts External Reset RV32 CNN CNN FIFO SPI1 SPI0 I2S I2C2 I2C1 I2C0 LPUART0 (UART3) UART2 UART1 UART0 LPTMR1 (TMR5) LPTMR0 (TMR4) TMR3 TMR2 TMR1 TMR0 LPWDT0 (WDT1) WDT0 LPCOMP3 LPCMOP2 LPCMOP1 COMP0 RTC WUT GPIO3 GPIO2 GPIO1 GPIO0 SLEEP \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc LPM \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc UPM \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc STANDBY \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc BACKUP \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc \uf0fc PDM \uf0fc \uf0fc Note: The CNN and CNN FIFO cannot wake the CM4 from LPM."},{"location":"system-power-clocks-reset/#device-resets","title":"Device Resets","text":"<p>Four device resets are available:</p> <ul> <li>Peripheral Reset</li> <li>Soft Reset</li> <li>System Reset</li> <li>Power-On Reset</li> </ul> <p>On completion of any of the four reset cycles, all peripherals are reset. On completion of any reset cycle, HCLK and PCLK are operational, the CPU core receives clocks and power, and the device is in ACTIVE. Program execution begins at the reset vector address.</p> <p>The contents of the always-on domain (AoD) are reset only on power-cycling V<sub>COREA</sub>, V<sub>COREB</sub>, V<sub>DDA</sub>, V<sub>DDIOH</sub>, or V<sub>REGI</sub>.</p> <p>The on-chip peripherals can also be reset to their POR default state using the two reset registers, GCR_RST0 and GCR_RST1.</p> <p>Table 4-5 shows the effects of each reset type on each of the operating modes.</p> <p>Table 4-5: Reset and Low-Power Mode Effects </p> Peripheral<sup>4</sup> Reset Soft<sup>4</sup> Reset System<sup>4</sup> Reset POR ACTIVE SLEEP LPM UPM BACKUP<sup>3</sup> PDM IPO - - Off Off R - FW Off Off Off ISO - - On Off R - FW Off Off Off ERTCO - - - Off FW FW FW FW FW Off IBRO - - Off Off R - FW FW Off Off ERFO - - Off Off R - Off Off Off Off INRO On On On On On On On On On Off SYS_CLK On On On<sup>2</sup> On<sup>2</sup> On On Off Off Off Off CPU Clock On On On On On Off Off Off Off Off RTC Reset FW FW FW FW FW Off Off WDT0, WDT1 - Reset Reset Reset FW Off Off Off Off Off GPIO0-GPIO2 - Reset Reset Reset R - - - - - GPIO3 - N/A Reset Reset FW FW FW FW FW FW All Other Peripherals Reset Reset Reset Reset R - R R Off Off Always-On Domain - - - Reset - - - - - - RAM Retention - - - Reset - - On On FW Off      Table key:      FW = Controlled by firmware      On = Enabled by hardware (Cannot be disabled)      Off = Disabled by hardware (Cannot be enabled)      - = No Effect      R = Restored to previous ACTIVE setting when exiting LPM and UPM, restored to system reset state when exiting BACKUP or STORAGE.      1: The always-on domain (AoD) is only reset on power-cycling V<sub>COREA</sub>, V<sub>COREB</sub>, V<sub>DDA</sub>, V<sub>DDIOH</sub>, or V<sub>REGI</sub>.     2: On a system reset or POR, the ISO is automatically set as the SYS_OSC.      3: A system reset occurs when returning from BACKUP or PDM low-power mode.      4: Peripheral, soft, and system resets are initiated by software through the GCR_RST0 register. System reset can also be triggered by the RSTN device pin or a Watchdog reset."},{"location":"system-power-clocks-reset/#peripheral-reset","title":"Peripheral Reset","text":"<p>Peripheral reset resets all peripherals. The CPU retains its state. The GPIO, watchdog timers, AoD, RAM retention, and general control registers (GCR), including the clock configuration, are unaffected.</p> <p>To start a peripheral reset, set GCR_RST0.periph to 1. The reset is completed immediately upon setting GCR_RST0.periph to 1.</p>"},{"location":"system-power-clocks-reset/#soft-reset","title":"Soft Reset","text":"<p>A soft reset is the same as a peripheral reset except that it also resets the GPIO to its POR state.</p> <p>To perform a soft reset, set GCR_RST0.soft to 1. The reset occurs immediately upon setting GCR_RST0.soft to 1.</p>"},{"location":"system-power-clocks-reset/#system-reset","title":"System Reset","text":"<p>A system reset is the same as a soft reset, except it also resets all GCR, resetting the clocks to their POR default state. The CPU state is reset, as well as the watchdog timers. The AoD and RAM are unaffected.</p> <p>A watchdog timer reset event initiates a system reset. To start a system reset, set GCR_RST0.sys to 1.</p>"},{"location":"system-power-clocks-reset/#power-on-reset","title":"Power-On Reset","text":"<p>A POR resets everything in the device to its default state. A POR results from V<sub>COREA</sub>, V<sub>COREB</sub>, V<sub>DDA</sub>, or V<sub>REGI</sub> falling below their reset voltage level. Refer to the MAX78000 data sheet for details of the reset voltage levels.</p>"},{"location":"system-power-clocks-reset/#unified-internal-cache-controllers","title":"Unified Internal Cache Controllers","text":"<p>The MAX78000 includes two unified internal cache controllers. ICC0 is the cache controller used for the CM4. ICC1, if enabled, is dedicated to the RV32 core. ICC1 uses sysram3 as the cache memory. If ICC1 is enabled, sysram3 is not accessible as SRAM (address range 0x2001 C000 to 0x2001 FFFF).</p> <p>Both caches, ICC0 and ICC1, include a line buffer, tag RAM, and a 16KB 2-way set associative RAM when enabled.</p>"},{"location":"system-power-clocks-reset/#enabling-the-internal-cache-controllers","title":"Enabling the Internal Cache Controllers","text":"<p>Enabling ICC1 for use as the cache controller for the RV32 requires using sysram3 as the cache memory. Note: The contents of sysram3 are lost when ICC1 is enabled, and sysram3 is not accessible for data reads or writes as part of the memory map.</p> <p>Note: Before enabling ICC1 as a cache controller, sysram3 should be zeroized.</p> <p>Perform the following steps to enable each ICC:</p> <ol> <li>Set the ICCn_CTRL.en to 0, ensuring the cache is invalidated when enabled.</li> <li>Set ICCn_CTRL.en to 1.</li> <li>Read ICCn_CTRL.rdy until it returns 1.</li> <li>Zeroize the ICC instance by setting GCR_MEMZ.icc0 or GCR_MEMZ.icc1 to 1.</li> </ol>"},{"location":"system-power-clocks-reset/#disabling-the-icc","title":"Disabling the ICC","text":"<p>Disable an ICC instance by setting ICCn_CTRL.en to 0.</p> <p>To use sysram3 as data RAM, first, disable the ICC1 instance as described above. When ICC1 is disabled, sysram3 is accessible as data RAM by both the CM4 and RV32 controllers unless sysram3 is configured for exclusive access by the RV32 core only.</p>"},{"location":"system-power-clocks-reset/#invalidating-the-icc-cache-and-tag-ram","title":"Invalidating the ICC Cache and Tag RAM","text":"<p>Invalidate the contents of a specific ICC instance by setting the ICCn_INVALIDATE register to 1. Once invalidated, the system flushes the cache. Read the ICCn_CTRL.rdy field until it returns 1 to determine when the flush is completed.</p>"},{"location":"system-power-clocks-reset/#flushing-the-icc","title":"Flushing the ICC","text":"<p>Flush ICC0 using the system configuration register (GCR_SYSCTRL). Set GCR_SYSCTRL.icc0_flush to 1 to immediately flush the contents of the 16KB cache and tag RAM.</p> <p>Flush ICC1 using the RV32 Control Register (FCR_URVCTRL). Set FCR_URVCTRL.icc1_flush to 1 to immediately flush the contents of the 16KB cache and tag RAM.</p>"},{"location":"system-power-clocks-reset/#internal-cache-control-registers-icc","title":"Internal Cache Control Registers (ICC)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-6: Instruction Cache Controller Register Summary </p> Offset Register Name [0x0000] ICCn_INFO Cache ID Register [0x0004] ICCn_SZ Cache Memory Size Register [0x0100] ICCn_CTRL Instruction Cache Control Register [0x0700] ICCn_INVALIDATE Instruction Cache Controller Invalidate Register"},{"location":"system-power-clocks-reset/#icc0-register-details","title":"ICC0 Register Details","text":"<p>Table 4-7: ICC0 Cache Information Register </p> ICC0 Cache Information ICCn_INFO [0x0000] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:10 id R - Cache ID        This field returns the ID for the cache instance.         9:6 partnum R - Cache Part Number        This field returns the part number indicator for the cache instance.         5:0 relnum R - Cache Release Number This field returns the release number for the cache instance.         <p>Table 4-8: ICC0 Memory Size Register </p> ICC0 Memory Size ICCn_SZ [0x0004] Bits Name Access Reset Description 31:16 mem R - Addressable Memory Size        This field indicates the size of addressable memory by the cache controller instance in 128KB units.         15:0 cch R - Cache SizeThis field returns the size of the cache RAM in 1KB units.         16: 16KB Cache RAM         <p>Table 4-9: ICC0 Cache Control Register </p> ICC0 Cache Control ICCn_CTRL [0x0100] Bits Name Access Reset Description 31:17 - R/W - Reserved 16 rdy R - ReadyThis field is cleared by hardware anytime the cache as a whole is invalidated (including a POR). Hardware automatically sets this field to 1 when the invalidate operation is complete, and the cache is ready.              0: Cache invalidation in process.             1: Cache is ready.          Note: While this field reads 0, the cache is bypassed, and reads come directly from the line fill buffer. 15:1 - R/W - Reserved 0 en R/W 0 Cache EnableSet this field to 1 to enable the cache. Setting this field to 0 invalidates the cache contents, and the line fill buffer handles all reads.               0: Disable             1: Enable          <p>Table 4-10: ICC0 Invalidate Register </p> ICC0 Invalidate ICCn_INVALIDATE [0x0700] Bits Name Access Reset Description 31:0 invalid W - Invalidate     Writing any value to this register invalidates the cache."},{"location":"system-power-clocks-reset/#ram-memory-management","title":"RAM Memory Management","text":"<p>This device has many features for managing the on-chip RAM. The on-chip RAM includes the data RAM, the unified cache controllers (ICC0 and ICC1), the CNN RAM, and the peripheral FIFOs.</p>"},{"location":"system-power-clocks-reset/#on-chip-cache-management","title":"On-Chip Cache Management","text":"<p>The MAX78000 includes two unified internal cache controllers for code and data fetches from the flash memory. The caches can be enabled, disabled, zeroized, and flushed. See section Unified Internal Cache Controller for details.</p>"},{"location":"system-power-clocks-reset/#ram-zeroization","title":"RAM Zeroization","text":"<p>The GCR memory zeroize register, GCR_MEMZ, allows clearing memory for software or security reasons. Zeroization writes all zeros to the specified memory.</p> <p>The following SRAM memories can be zeroized:</p> <ul> <li>Each of the System RAMs can be individually zeroized by setting the respective GCR_MEMZ bit:<ul> <li>GCR_MEMZ.ram0</li> <li>GCR_MEMZ.ram0ecc</li> <li>GCR_MEMZ.ram1</li> <li>GCR_MEMZ.ram2</li> <li>GCR_MEMZ.ram3</li> </ul> </li> <li>ICC0 16KB Cache</li> <li>GCR_MEMZ.icc0</li> <li>ICC1 16KB Cache, if enabled<ul> <li>GCR_MEMZ.icc1</li> <li>Each of the CNNx16n processor arrays supports zeroizing the tornado RAM, mask RAM, bias RAM, and data SRAM:</li> <li>CNNx16_n_TEST.tramz set to 1 to zero, read CNNx16_n_TEST.tallzdone until 1 for completion</li> <li>CNNx16_n_TEST.mramz set to 1 to zero, read CNNx16_n_TEST.mallzdone until 1 for completion</li> <li>CNNx16_n_TEST.bramz set to 1 to zero, read CNNx16_n_TEST.ballzdone until 1 for completion</li> <li>CNNx16_n_TEST.sramz set to 1 to zero, read CNNx16_n_TEST.sallzdone until 1 for completion</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#miscellaneous-control-registers-mcr","title":"Miscellaneous Control Registers (MCR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-11: Miscellaneous Control Register Summary </p> Offset Register Name Access Name [0x0000] MCR_ECCEN R/W Error Correction Coding Enable Register [0x0004] MCR_IPO_MTRIM R/W IPO Manual Trim Register [0x0008] MCR_OUTEN R/W Miscellaneous Output Enable Register [0x000C] MCR_CMP_CTRL R/W Comparator Control Register [0x0010] MCR_CTRL R/W Miscellaneous Control Register [0x0020] MCR_GPIO3_CTRL R/W GPIO3 Pin Control Register"},{"location":"system-power-clocks-reset/#miscellaneous-control-register-details","title":"Miscellaneous Control Register Details","text":"<p>Table 4-12: Error Correction Coding Enable Register </p> Error Correction Coding Enable MCR_ECCEN [0x0000] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 ram0 R/W 0 System RAM 0 ECC EnableSet this field to 1 to enable ECC for sysram0.              0: Disabled             1: Enabled          <p>Table 4-13: IPO Manual Register </p> IPO Manual Trim MCR_IPO_MTRIM [0x0004] Bits Name Access Reset Description 31:9 - R0 0 Reserved 8 trim_range R/W 0 Trim Range SelectIf this bit is set to 1, the value loaded into the MCR_IPO_MTRIM.mtrim field must be greater than the trim setting in the TRIMSIR_IPOLO.ipo_limitlo field. If this bit is set to 0, the value loaded into the MCR_IPO_MTRIM.mtrim field must be less than the trim setting in the TRIMSIR_CTRL.ipo_limithi field.                      0: MCR_IPO_MTRIM.mtrim &lt; TRIMSIR_IPOLO.ipo_limitlo             1: MCR_IPO_MTRIM.mtrim &gt; TRIMSIR_CTRL.ipo_limithi 7:0 mtrim R/W 0x04 Manual Trim Value     Set this value to the desired manual trim based on the value set in MCR_IPO_MTRIM.trim_range.     If MCR_IPO_MTRIM.trim_range is 0, the value in this field must be less than the value in &lt; TRIMSIR_IPOLO.ipo_limitlo.     If MCR_IPO_MTRIM.trim_range is 1, the value in this field must be greater than the value in TRIMSIR_CTRL.ipo_limithi.      <p>Table 4-14: Output Enable Register </p> Output Enable MCR_OUTEN [0x0008] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1 pdown_out_en R/W 0 Power Down Output Enable on P3.0Set this field to 1 to enable the power down output, P3.0 AF1 (PDOWN). PDOWN is active in BACKUP and STANDBY.      0: PDOWN output not enabled on P3.0     1: PDOWN output is enabled on P3.0      0 sqwout_en R/W 0 Square Wave Output Enable on P3.1 (SQWOUT)Set this field to 1 to enable the square wave output on P3.1 AF1 (SQWOUT).      0: Square wave output not enabled on P3.1.     1: Square wave output enabled on P3.1.      <p>Table 4-15: Comparator 0 Control Register </p> Comparator 0 Control MCR_CMP_CTRL [0x000C] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 if R/W1C 0 Comparator 0 Interrupt FlagThis field is set to 1 by hardware when the comparator output changes to the active state as set using the MCR_CMP_CTRL.pol field. Write 1 to clear this flag.      0: No interrupt     1: Interrupt occurred      14 out RO * Comparator 0 OutputThis field is the comparator output state.      0: Output low     1: Output high      13-7 - RO * Reserved 6 int_en R/W 0 Comparator 0 Interrupt EnableSet this field to 1 to enable the interrupt for comparator 0.      0: Interrupt disabled     1: Interrupt enabled      5 pol R/W 0 Comparator 0 Interrupt Polarity SelectSet this field to select the polarity of the output change that generates a comparator 3 interrupt.      0: Interrupt occurs from a transition from low to high     1: Interrupt occurs from a transition from high to low      4:1 - RO 0 Reserved 0 en R/W 0 Comparator 0 EnableSet this field to 1 to enable the comparator.      0: Comparator disabled     1: Comparator enable      <p>Table 4-16: Miscellaneous Control Register </p> Miscellaneous Control MCR_CTRL [0x0010] Bits Name Access Reset Description 31:10 - RO 0 Reserved 9 simo_rstd R/W 0 SIMO System Reset DisableIf this field is set, the SIMO is only reset by a POR. When this bit is set, the VSET* stays unchanged when exiting all low-power modes.      0: The SIMO is reset by all system resets.     1: The SIMO is only reset by a Power-On Reset.      9 simo_rstd R/W 0 SIMO System Reset DisableIf this field is set, the SIMO is only reset by a POR. When this bit is set, the VSET* stays unchanged when exiting all low-power modes.      0: The SIMO is reset by all system resets.     1: The SIMO is only reset by a Power-On Reset.      8 simo_clkscl_en R/W 0 SIMO Clock Scaling EnableSet this field to 1 to enable dynamic clock scaling to the SIMO based on load current. When enabled, the SIMO clock slows down in low-power modes, reducing current consumption.      0: SIMO clock scaling disabled     1: SIMO clock scaling enabled      7:4 - DNM 0x01 Reserved 3 ertco_en R/W 0 ERTCO Enable for LPM and UPM     Set this field to 1 to enable the ERTCO in LPM and UPM.      0: ERTCO disabled     1: ERTCO enabled      2 inro_en R/W 0 INRO EnableSet this field to 1 to enable the INRO in LPM and UPM.      0: INRO disabled     1: INRO enabled      1:0 - RO 0 Reserved"},{"location":"system-power-clocks-reset/#gpio-3-control","title":"GPIO 3 Control","text":"<p>Table 4-17: GPIO3 Pin Control Register </p> GPIO3 Pin Control MCR_GPIO3_CTRL [0x0020] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7 p31_in RO See Description GPIO3 Pin 1 Input Status     Read this field to determine the input status of P3.1.          0: Input Low         1: Input High        6 p31_pe R/W 0 GPIO3 Pin 1 Pull-up Enable     Set this bit to 1 to enable the pullup resistor for P3.1.          0: Pull-up Disabled         1: Pull-up Enabled        5 p31_oe R/W 0 GPIO3 Pin 1 Output Enable     Set this bit to 1 to enable P3.1 for output mode.          0: Input mode.         1: Output mode enabled.        4 p31_do R/W 0 GPIO3 Pin 1 Data Output     If p31_oe is set to 1, this field is used to control the output state of P3.1.          0: Output low if p31_oe is 1         1: Output high if p31_oe is 1.        3 p30_in RO See Description GPIO3 Pin 0 Input Status     Read this field to determine the input status of P3.0.          0: Input Low         1: Input High        2 p30_pe R/W 0 GPIO3 Pin 0 Pull-up Enable     Set this bit to 1 to enable the pullup resistor for P3.0.          0: Pull-up Disabled         1: Pull-up Enabled        1 p30_oe R/W 0 GPIO3 Pin 0 Output Enable     Set this bit to 1 to enable P3.0 for output mode.          0: Input mode         1: Output mode enabled.        0 p30_do R/W 0 GPIO3 Pin 0 Data Output     If p30_oe is set to 1, this field is used to control the output state of P3.0.          0: Output low if p30_oe is 1         1: Output high if p30_oe is 1."},{"location":"system-power-clocks-reset/#single-inductor-multiple-output-power-supply-simo","title":"Single Inductor Multiple Output Power Supply (SIMO)","text":"<p>The SIMO switch mode power supply allows the device to operate autonomously from a single lithium cell. The SIMO provides three buck switching regulators (V<sub>REGO_A</sub> thru V<sub>REGO_C</sub>). Each of the three regulator voltages can be controlled by either CPU individually. For the SIMO to operate properly, the three buck regulator outputs must drive the power supply pins of the device, as shown in Table 4-18.</p>"},{"location":"system-power-clocks-reset/#power-supply-monitor","title":"Power Supply Monitor","text":"<p>The system also provides a power monitor that monitors the external power supplies relative to the on-chip bandgap voltage. The following power supplies are monitored:</p> <ul> <li>VCOREA (V<sub>COREA</sub>) Digital Core Supply Voltage A for the AoD</li> <li>VCOREB (V<sub>COREB</sub>) Digital Core Supply Voltage B</li> <li>VDDIO (V<sub>DDIO</sub>) GPIO Supply Voltage</li> <li>VDDIOH (V<sub>DDIOH</sub>) GPIO High Supply Voltage</li> <li>VDDA (V<sub>DDA</sub>) AoD Analog Supply Voltage</li> <li>VREGI (V<sub>REGI</sub>) Input Supply Voltage, Battery</li> </ul> <p>If the voltage drops below the trigger threshold, all registers and peripherals in that power domain are reset. This improves reliability and safety by guarding against a low voltage condition corrupting the contents of the registers and the device state.</p> <p>Refer to the device data sheet electrical characteristics for the trigger threshold values and power fail reset voltages.</p> <p>Table 4-18: SIMO Power Supply Device Pin Connectivity </p> SIMO Supply Output Pin Connection Device Power Supply Input Pin Supply Monitor Reset Action V<sub>REGO_A</sub> --&gt; V<sub>DDA</sub> POR V<sub>REGO_B</sub> --&gt; V<sub>COREB</sub> POR V<sub>REGO_C</sub> --&gt; V<sub>COREA</sub> POR - - V<sub>REGI</sub> POR - - V<sub>DDIO</sub> Power On GPIO pad held in reset until the voltage rises above its threshold - - V<sub>DDIOH</sub> Power On GPIO pad held in reset until the voltage rises above its threshold - - V<sub>DDIO</sub> GPIO pad logic enters POR - - V<sub>DDIOH</sub> GPIO pad logic enters POR <p>See Table 3-3 for the SIMO Controller Peripheral Base Address.</p> <p>Table 4-19: SIMO Controller Register Summary </p> Offset Register Name Access Name [0x0004] SIMO_VREGO_A R/W Buck Voltage Regulator A Control Register [0x0008] SIMO_VREGO_B R/W Buck Voltage Regulator B Control Register [0x000C] SIMO_VREGO_C R/W Buck Voltage Regulator C Control Register [0x0014] SIMO_IPKA RO Reserved. Do not modify this register. [0x0018] SIMO_IPKB RO Reserved. Do not modify this register. [0x001C] SIMO_MAXTON RO Reserved. Do not modify this register. [0x0020] SIMO_ILOAD_A RO Reserved. Do not modify this register. [0x0024] SIMO_ILOAD_B RO Reserved. Do not modify this register. [0x0028] SIMO_ILOAD_C RO Reserved. Do not modify this register. [0x0030] SIMO_BUCK_ALERT_THR_A RO Reserved. Do not modify this register. [0x0034] SIMO_BUCK_ALERT_THR_B RO Reserved. Do not modify this register. [0x0038] SIMO_BUCK_ALERT_THR_C RO Reserved. Do not modify this register. [0x0040] SIMO_BUCK_OUT_READY RO Buck Regulator Output Ready Register [0x0044] SIMO_ZERO_CROSS_CAL_A RO Reserved. Do not modify this register. [0x0048] SIMO_ZERO_CROSS_CAL_B RO Reserved. Do not modify this register. [0x004C] SIMO_ZERO_CROSS_CAL_C RO Reserved. Do not modify this register."},{"location":"system-power-clocks-reset/#single-inductor-multiple-output-simo-registers-details","title":"Single Inductor Multiple Output (SIMO) Registers Details","text":"<p>Table 4-20: SIMO Buck Voltage Regulator A Control Register </p> SIMO Buck Voltage Regulator A Control SIMO_VREGO_A [0x0004] Bits Name Access Reset Description 31:8 - RO - Reserved 7 rangea R/W 1 Regulator Output A Range     This field selects the regulator output range for V<sub>REGO_A</sub>.      0: 0.5V to 1.77V     1: 0.6V to 1.87V      6:0 vseta R/W 0x78h Regulator Output A VoltageEach bit increment in this field represents 10mV allowing output voltage settings from the minimum to the maximum of the SIMO_VREGO_A.rangea selected. <p>SIMO_VREGO_A.rangea = 1: Output Voltage=0.6V + (10mV \u00d7 vseta)</p> <p>SIMO_VREGO_A.rangea = 0: Output Voltage=0.5V + (10mV \u00d7 vseta)</p>      Default: 0x78 = SIMO_VREGO_A.rangea = 0, Output Voltage = 1.7V; SIMO_VREGO_A.rangea = 1, Output Voltage = 1.8V     *Warning: When this regulator is connected as shown in Table 4-18: SIMO Power Supply Device Pin Connectivity, the following apply:*         1. The maximum setting for this regulator must be followed for V<sub>DDA</sub> as indicated in the device data sheet.     2. Setting the regulator to a voltage below the power-fail reset voltage for V<sub>DDA</sub> initiates the power monitor reset action.      <p>Table 4-21: SIMO Buck Voltage Regulator B Control Register </p> SIMO Buck Voltage Regulator B Control SIMO_VREGO_B [0x0008] Bits Name Access Reset Description 31:8 - RO - Reserved 7 rangeb R/W 1 Regulator Output B RangeThis field selects the regulator output range for V<sub>REGO_B</sub>.      0: 0.5V to 1.77V     1: 0.6V to 1.87V      6:0 vsetb R/W 0x32h Regulator Output Voltage     Each bit increment in this field represents 10mV allowing output voltage settings from the minimum to the maximum of the SIMO_VREGO_B.rangeb selected. <p>SIMO_VREGO_B.rangeb = 1: Output Voltage=0.6V + (10mV \u00d7 vsetb)</p> <p>SIMO_VREGO_B.rangeb&gt; = 0: Output Voltage=0.5V + (10mV \u00d7 vsetb)</p>      Setting this field to 0x7F results in the maximum output voltage per the SIMO_VREGO_B.rangeb selected (1.77V or 1.87V)     Default: 0x32 = SIMO_VREGO_B.rangeb, Output Voltage = 1.0V; SIMO_VREGO_B.rangeb = 1, Output Voltage = 1.1V     *Warning: When this regulator is connected as shown in Table 4-18: SIMO Power Supply Device Pin Connectivity, the following apply:*         1. The maximum setting for this regulator must be followed for V<sub>COREB</sub> as indicated in the device data sheet.     2. Setting the regulator to a voltage below the power-fail reset voltage for V<sub>COREB</sub> initiates the power monitor reset action.      <p>Table 4-22: SIMO Buck Voltage Regulator C Control Register </p> SIMO Buck Voltage Regulator C Control SIMO_VREGO_C [0x000C] Bits Name Access Reset Description 31:8 - RO - Reserved 7 rangec R/W 1 Regulator Output B RangeThis field selects the regulator output range for V<sub>REGO_C</sub>.      0: 0.5V to 1.77V     1: 0.6V to 1.87V      6:0 vsetc R/W 0x32h Regulator Output VoltageEach increment in the register represents 10mV. <p>SIMO_VREGO_C.rangec = 1: Output Voltage=0.6V + (10mV \u00d7 vsetb)</p> <p>SIMO_VREGO_C.rangec&gt; = 0: Output Voltage=0.5V + (10mV \u00d7 vsetb)</p>      Setting this field to 0x7F results in the maximum output voltage per the SIMO_VREGO_C.rangec selected (1.77V or 1.87V)     Default: 0x32 = SIMO_VREGO_C.rangec, Output Voltage = 1.0V; SIMO_VREGO_C.rangec = 1, Output Voltage = 1.1V     *Warning: When this regulator is connected as shown in Table 4-18: SIMO Power Supply Device Pin Connectivity, the following apply:*         1. The maximum setting for this regulator must be followed for V<sub>COREC</sub> as indicated in the device data sheet.     2. Setting the regulator to a voltage below the power-fail reset voltage for V<sub>COREC</sub> initiates the power monitor reset action.      <p>Table 4-23: SIMO High Side FET Peak Current V<sub>REGO_A</sub> V<sub>REGO_B</sub> Register </p> SIMO High Side FET Peak Current V<sub>REGO_A</sub> V<sub>REGO_B</sub> SIMO_IPKA [0x0014] Bits Name Access Reset Description 31:8 - RO - Reserved 7:4 ipksetb RO 8 Reserved 3:0 ipkseta RO 8 Reserved <p>Table 4-24: SIMO High Side FET Peak Current V<sub>REGO_C</sub> Register </p> SIMO High Side FET Peak Current V<sub>REGO_C</sub> V<sub>REGO_D</sub> SIMO_IPKB [0x0018] Bits Name Access Reset Description 31:4 - RO - Reserved 3:0 ipksetc RO 8 Reserved <p>Table 4-25: SIMO Maximum High Side FET Time On Register </p> SIMO Maximum High Side FET On Time SIMO_MAXTON [0x001C] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3:0 tonset RO 0x8h Reserved <p>Table 4-26: SIMO Buck Cycle Count VREGO_A Register </p> SIMO Buck Cycle Count VREGO_A SIMO_ILOAD_A [0x0020] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 iloada RO 0 Reserved <p>Table 4-26: SIMO Buck Cycle Count VREGO_B Register </p> SIMO Buck Cycle Count VREGO_B SIMO_ILOAD_B [0x0024] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 iloadb RO 0 Reserved <p>Table 4-28: SIMO Buck Cycle Count VREGO_C Register </p> SIMO Buck Cycle Count VREGO_C SIMO_ILOAD_C [0x0028] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 iloadc RO 0 Reserved <p>Table 4-29: SIMO Buck Cycle Count Alert VREGO_A Register </p> SIMO Buck Cycle Count Alert VREGO_A SIMO_BUCK_ALERT_THR_A [0x0030] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 buckthra RO 0 Reserved <p>Table 4-30: SIMO Buck Cycle Count Alert VREGO_B Register </p> SIMO Buck Cycle Count Alert VREGO_B SIMO_BUCK_ALERT_THR_B [0x0034] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 buckthrb RO 0 Reserved <p>Table 4-30: SIMO Buck Cycle Count Alert VREGO_C Register </p> SIMO Buck Cycle Count Alert VREGO_C SIMO_BUCK_ALERT_THR_C [0x0038] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 buckthrc RO 0 Reserved <p>Table 4-32: SIMO Buck Regulator Output Ready Register </p> SIMO Buck Regulator Output Ready SIMO_BUCK_OUT_READY [0x0040] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 buckoutrdya RO 0 V<sub>REGO_A</sub> Output ReadyWhen SIMO_VREGO_A.vseta changes, this bit is set when the output voltage has reached its regulated value. It is not cleared if the output voltage drops below its set value.      0: Not ready     1: Ready      2 buckoutrdyb RO 0 V<sub>REGO_B</sub> Output ReadyWhen SIMO_VREGO_B.vsetb changes, this bit is set when the output voltage has reached its regulated value. It is not cleared if the output voltage drops below its set value.      0: Not ready     1: Ready      1 buckoutrdyc R/W 0 V<sub>REGO_C</sub> Output ReadyWhen SIMO_VREGO_C.vsetb changes, this bit is set when the output voltage has reached its regulated value. It is not cleared if the output voltage drops below its set value.      0: Not ready     1: Ready      0 - RO 0 Reserved <p>Table 4-33: SIMO Zero Cross Calibration V<sub>REGO_A</sub> Register </p> SIMO Zero Cross Calibration V<sub>REGO_A</sub> SIMO_ZERO_CROSS_CAL_A [0x0044] Bits Name Access Reset Description 31:5 - RO 0 Reserved 4:0 zxcala RO 0 Reserved <p>Table 4-34: SIMO Zero Cross Calibration V<sub>REGO_B</sub> Register </p> SIMO Zero Cross Calibration V<sub>REGO_B</sub> SIMO_ZERO_CROSS_CAL_B [0x0048] Bits Name Access Reset Description 31:5 - RO 0 Reserved 4:0 zxcalb RO 0 Reserved <p>Table 4-35: SIMO Zero Cross Calibration V<sub>REGO_B</sub> Register </p> SIMO Zero Cross Calibration V<sub>REGO_C</sub> SIMO_ZERO_CROSS_CAL_C [0x004C] Bits Name Access Reset Description 31:5 - RO 0 Reserved 4:0 zxcalc RO 0 Reserved 4:0 zxcald RO 0 Reserved"},{"location":"system-power-clocks-reset/#low-power-general-control-registers-lpgcr","title":"Low-Power General Control Registers (LPGCR)","text":"<p>This set of general control registers provides reset and clock control for the low-power peripherals, including:</p> <ul> <li>LPUART0 (UART3)</li> <li>LPTMR0 (TMR4)</li> <li>LPTMR1 (TMR5)</li> <li>LPWDT0 (WDT1)</li> <li>LPCOMP1, LPCOMP2, and LPCOMP3</li> <li>GPIO2</li> </ul> <p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-36: Low-Power Control Register Summary </p> Offset Register Name [0x0004] LPGCR_RST Reset Control Register [0x0008] LPGCR_PCLKDIS Clock Control Register/td&gt;"},{"location":"system-power-clocks-reset/#low-power-general-control-registers-details","title":"Low-Power General Control Registers Details","text":"<p>Table 4-37: Low-Power General Control Registers Details </p> Low-Power Reset Control LPGCR_RST [0x0004] Bits Name Access Reset Description 31:7 - RO 0 Reserved 6 lpcomp W1O 0 Low Power Comparators Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information.  5 - RO 0 Reserved 4 uart3 W1O 0 UART3 (LPUART0) Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information. 3 tmr5 W1O 0 TMR5 (LPTMR1) Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information. 2 tmr4 W1O 0 TMR4 (LPTMR0) Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information. 1 wdt1 W1O 0 WDT1 (LPWDT0) Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information. 0 gpio2 W1O 0 GPIO2 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete. See Device Resets for additional information. <p>Table 4-38: Clock Disable Register </p> Clock Disable LPGCR_PCLKDIS [0x008] Bits Name Access Reset Description 31:7 - RO 0 Reserved 6 lpcomp R/W 0 Low Power Comparators Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained. <p>Note: This field disables clocks to LPCOMP1, LPCOMP2, and LPCOMP3.</p>      0: Enabled     1: Disabled      5 - RO 0 Reserved 4 uart3 R/W 0 UART3 (LPUART0) Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.      0: Enabled     1: Disabled      3 tmr5 R/W 0 TMR5 (LPTMR1) Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.      0: Enabled     1: Disabled      2 tmr4 R/W 0 TMR4 (LPTMR0) Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.      0: Enabled     1: Disabled      1 wdt1 R/W 0 WDT1 (LPWDT0) Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.      0: Enabled     1: Disabled      0 gpio2 R/W 0 GPIO2 Clock Disable     Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.      0: Enabled     1: Disabled"},{"location":"system-power-clocks-reset/#power-sequencer-registers-pwrseq","title":"Power Sequencer Registers (PWRSEQ)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-39: Power Sequencer Register Summary </p> Offset Register Name [0x0000] PWRSEQ_LPCN Low Power Control Register [0x0004] PWRSEQ_LPWKST0 Low Power GPIO0 Wakeup Status Flags [0x0008] PWRSEQ_LPWKEN0 Low Power GPIO0 Wakeup Enable Register [0x000C] PWRSEQ_LPWKST1 Low Power GPIO1 Wakeup Status Flags [0x0010] PWRSEQ_LPWKEN1 Low Power GPIO1 Wakeup Enable Register [0x0014] PWRSEQ_LPWKST2 Low Power GPIO2 Wakeup Status Flags [0x0018] PWRSEQ_LPWKEN2 Low Power GPIO2 Wakeup Enable Registers [0x001C] PWRSEQ_LPWKST3 Low Power GPIO3 Wakeup Status Flags [0x0020] PWRSEQ_LPWKEN3 Low Power GPIO3 Wakeup Enable Register [0x0030] PWRSEQ_LPPWST Low Power Peripheral Wakeup Status Register [0x0034] PWRSEQ_LPPWEN Low Power Peripheral Wakeup Enable Register [0x0048] PWRSEQ_GP0 General Purpose Register 0 [0x004C] PWRSEQ_GP1 General Purpose Register 1"},{"location":"system-power-clocks-reset/#power-sequencer-register-details","title":"Power Sequencer Register Details","text":"<p>Table 4-40: Low Power Control Register </p> Low Power Control PWRSEQ_LPCN [0x0000] Bits Name Access Reset Description 31 lpwkst_clr R/W1 0 Low Power Wakeup Status Register Clear     Write 1 to this field to clear the Low Power Wakeup Status registers: <ul> <li>PWRSEQ_LPWKST0</li> <li>PWRSEQ_LPWKST1</li> <li>PWRSEQ_LPWKST2</li> <li>PWRSEQ_LPWKST3</li> <li>PWRSEQ_LPPWST</li> </ul> <p>1: Write 1 to initiate a clear of all the Low Power Wakeup Status registers. Hardware automatically clears this field when the registers are cleared.</p> 30:12 - DNM 0 Reserved, Do Not Modify 11 bg_dis R/W 1 Band Gap Disable for LPM and BACKUP Mode     Setting this field to 1 (default) disables the Bandgap during LPM and BACKUP mode.      0: System Bandgap is on in LPM and BACKUP modes.     1: System Bandgap is off in LPM and BACKUP modes.      10 - RO 0 Reserved 9 lpmfast R/W 0 Low Power Mode Clock Select     If the ISO is selected (default), fast LPM entry is enabled. Setting the clock to INRO disables fast LPM entry.      0: ISO used for entering LPM (Fast Mode Enable).     1: INRO used for LPM entry (Fast Mode Disabled).      8 lpmclksel R/W 1 Low Power Mode APB Clock Select     This field selects the clock source for the RV32 (CPU1) and other APB peripherals during LPM.      0: PCLK is used as the RV32 (CPU1) and APB system clock during LPM.     1: ISO is used as the RV32 (CPU1) and APB system clock during LPM.      7:4 - DNM 0 Reserved, Do not modify Note: This field must be set to 0 to maintain future compatibility.. 3 ramret3 R/W 0 System RAM 3 Data Retention Enable for BACKUP     Set this field to 1 to enable data retention for sysram3. See SRAM Space for the system RAM configuration.      0: Disable data retention for sysram3 address space in BACKUP.     1: Enable data retention for sysram3 address space in BACKUP.      2 ramret2 R/W 0 System RAM 2 Data Retention Enable for BACKUP     Set this field to 1 to enable data retention for sysram2. See SRAM Space for the system RAM configuration.      0: Disable data retention for sysram2 address space in BACKUP.     1: Enable data retention for sysram2 address space in BACKUP.      1 ramret1 R/W 0 System RAM 1 Data Retention Enable for BACKUP     Set this field to 1 to enable data retention for sysram1. See SRAM Space for the system RAM configuration.      0: Disable data retention for sysram1 address space in BACKUP.     1: Enable data retention for sysram1 address space in BACKUP.      0 ramret0 R/W 0 System RAM 0 Data Retention Enable for BACKUP     Set this field to 1 to enable data retention for sysram0. See SRAM Space for the system RAM configuration.      0: Disable data retention for sysram0 address space in BACKUP.     1: Enable data retention for sysram0 address space in BACKUP.      <p>Table 4-41: GPIO0 Low Power Wakeup Status Flags </p> GPIO0 Low Power Wakeup Status Flags PWRSEQ_LPWKST0 [0x0004] Bits Name Access Reset Description 31:0 wakest R/W1C 0 GPIO0 Pin Wakeup Status Flag     Whenever a GPIO0 pin, in any power mode, transitions from low-to-high or high-to-low, the pin\u2019s corresponding bit in this register is set. The device transitions from a low-power mode to ACTIVE if the corresponding GPIO pin\u2019s interrupt enable bit is set in the PWRSEQ_LPWKEN0 register. <p>Note: Clear this register before entering any low-power mode.</p> <p>Table 4-42: GPIO0 Low Power Wakeup Enable Registers </p> GPIO0 Low Power Wakeup Enable PWRSEQ_LPWKEN0 [0x0008] Bits Name Access Reset Description 31:0 en R/W 0 GPIO0 Pin Wakeup Interrupt Enable     Setting a GPIO0 pin\u2019s bit in this register causes an interrupt to be generated to wake up the device from any low-power mode to ACTIVE. A wake-up event sets the corresponding GPIO0\u2019s bit in the PWRSEQ_LPWKST0 register, enabling the determination of which GPIO0 pin triggered the wake-up event. Bits corresponding to unimplemented GPIO are ignored. <p>Note: To enable the MAX78000 to wake up from a low-power mode on a GPIO pin transition, first set the GPIO wake-up enable register bit GCR_PM.gpio_we to 1.</p> <p>Table 4-43: GPIO1 Low Power Wakeup Status Flags </p> GPIO1 Low Power Wakeup Status Flags PWRSEQ_LPWKST1 [0x000C] Bits Name Access Reset Description 31:10 - RO 0 ReservedBits corresponding to unimplemented GPIO are ignored. 9:0 st R/W1C 0 GPIO1 Pin Wakeup Status Flag     Whenever a GPIO1 pin, in any power mode, transitions from low-to-high or high-to-low, the pin\u2019s corresponding bit in this register is set. The device wakes from a low-power mode to ACTIVE if the corresponding interrupt enable bit is set in PWRSEQ_LPWKEN1. <p>Note: Clear this register before entering any low-power mode.</p> <p>Table 4-44: GPIO1 Low Power Wakeup Enable Registers </p> GPIO1 Low Power Wakeup Enable PWRSEQ_LPWKEN1 [0x0010] Bits Name Access Reset Description 31:10 - RO 0 ReservedBits corresponding to unimplemented GPIO are ignored. 9:0 en R/W 0 GPIO1 Pin Wakeup Interrupt Enable     Setting a GPIO1 pin\u2019s bit in this register causes an interrupt to be generated that wakes up the device from any low-power mode to ACTIVE. A wake-up event sets the corresponding GPIO1\u2019s bit in the PWRSEQ_LPWKST1 register, enabling the determination of which GPIO1 pin triggered the wake-up event. Bits corresponding to unimplemented GPIO are ignored. <p>Note: To enable the MAX78000 to wake up from a low-power mode on a GPIO pin transition, first set the GPIO wake-up enable register bit GCR_PM.gpio_we to 1.</p> <p>Table 4-45: GPIO2 Low Power Wakeup Status Flags </p> GPIO2 Low Power Wakeup Status Flags PWRSEQ_LPWKST2 [0x0014] Bits Name Access Reset Description 31:8 - R/W1C 0 ReservedBits corresponding to unimplemented GPIO are ignored. 7:0 wakest R/W1C 0 GPIO2 Pin Wakeup Status Flag     Whenever a GPIO2 pin, in any power mode, transitions from low-to-high or high-to-low, the pin's corresponding bit in this register is set. The device wakes from a low-power mode to ACTIVE if the corresponding interrupt enable bit is set in PWRSEQ_LPWKEN2. <p>Note: Clear this register before entering any low-power mode.</p> <p>Table 4-46: GPIO2 Low Power Wakeup Enable Registers </p> GPIO2 Low Power Wakeup Enable PWRSEQ_LPWKEN2 [0x0018] Bits Name Access Reset Description 31:8 - RO 0 ReservedBits corresponding to unimplemented GPIO are ignored. 7:0 en R/W 0 GPIO2 Pin Wakeup Interrupt Enable     Setting a GPIO2 pin\u2019s bit in this register causes an interrupt to be generated that wakes up the device from any low-power mode to ACTIVE. A wake-up event sets the corresponding GPIO2\u2019s bit in the PWRSEQ_LPWKST2 register, enabling the determination of which GPIO2 pin triggered the wake-up event. <p>Note: To enable the MAX78000 to wake up from a low-power mode on a GPIO pin transition, first set the GPIO wake-up enable register bit GCR_PM.gpio_we to 1.</p> <p>Table 4-47: GPIO3 Low Power Wakeup Status Flags </p> GPIO3 Low Power Wakeup Status Flags PWRSEQ_LPWKST3 [0x001C] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1:0 wakest R/W1C 0 GPIO3 Pin Wakeup Status Flag     Whenever a GPIO3 pin, in any power mode, transitions from low-to-high or high-to-low, the corresponding bit in this register is set. Bits corresponding to unimplemented GPIO are ignored.     The device wakes from a low-power mode to ACTIVE if the corresponding interrupt enable bit is set in PWRSEQ_LPWKEN3. <p>Note: Clear this register before entering any low-power mode.</p> <p>Table 4-48: GPIO3 Low Power Wakeup Enable Registers </p> GPIO3 Low Power Wakeup Enable PWRSEQ_LPWKEN3 [0x0020] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1:0 en R/W1C 0 GPIO3 Pin Wakeup Interrupt Enable     Setting a GPIO3 pin\u2019s bit in this register causes an interrupt to be generated that wakes up the device from any low-power mode to ACTIVE. A wake-up event sets the corresponding GPIO3\u2019s bit in the PWRSEQ_LPWKST3 register, enabling the determination of which GPIO3 pin triggered the wake-up event. Bits corresponding to unimplemented GPIO are ignored. <p>Note: To enable the MAX78000 to wake up from a low-power mode on a GPIO pin transition, first set the GPIO wake-up enable register bit GCR_PM.gpio_we = 1.</p> <p>Table 4-49: Low Power Peripheral Wakeup Status Flags </p> Low Power Peripheral Wakeup Status Flags PWRSEQ_LPPWST [0x0030] Bits Name Access Reset Description 31:18 - RO 0 Reserved 17 reset R/W1C 0 Reset Detected Wakeup Flag       This field is set when an external reset caused the wake-up event.      16 backup R/W1C 0 BACKUP Mode Wakeup Flag       This field is set when the device wakes up from BACKUP.      15:5 - RO 0 Reserved 4 comp0 R/W1C 0 Comparator 0 Wakeup Flag       This field is set if the wake-up event was the result of a comparator 0 trigger event.      3:0 - RO 0 Reserved <p>Table 4-50: Low Power Peripheral Wakeup Enable Registers </p> Low Power Peripheral Wakeup Enable PWRSEQ_LPPWEN [0x0034] Bits Name Access Reset Description 31:27 - RO 0 Reserved 26 lpcomp R/W 0 Low Power Comparator Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the LPCOMPn interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      25 spi1 R/W 0 SPI1 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the SPI1 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      24 i2s R/W 0 I2S Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the I2S interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      23 i2c2 R/W 0 I2C2 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the I2C2 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      22 i2c1 R/W 0 I2C1 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the I2C1 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      21 i2c0 R/W 0 I2C0 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the I2C0 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      20 uart3 R/W 0 LPUART0 (UART3) Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from LPUART0 (UART3) interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      19 uart2 R/W 0 UART2 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the UART2 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      18 uart1 R/W 0 UART1 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the UART1 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      17 uart0 R/W 0 UART0 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the UART0 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      16 tmr5 R/W 0 LPTMR1 (TMR5) Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the LPTMR1 (TMR5) interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      15 tmr4 R/W 0 LPTMR1 (TMR4) Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the LPTMR1 (TMR4) interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      14 tmr3 R/W 0 TMR3 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the TMR3 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      13 tmr2 R/W 0 TMR2 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the TMR2 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      12 tmr1 R/W 0 TMR1 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the TMR1 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      11 tmr0 R/W 0 TMR0 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the TMR0 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      10 cpu1 R/W 0 CPU1 (RV32) Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the RV32 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      9 wdt1 R/W 0 WDT1 (LPWDT0) Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the WDT1 (LPWDT0) interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      8 wdt0 R/W 0 WDT0 Interrupt Wakeup Enable       Set this field to 1 to enable wake-up events from the WDT0 interrupt.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      7:5 - RO 0 Comparator 0 Wakeup Enable       Set this field to 1 to enable wake-up events from Comparator 0. Comparator 0 can wake the device up from SLEEP, LPM, UPM, STANDBY, and BACKUP.          0: Disable wake-up on interrupt     1: Enable wake-up on interrupt      3:0 - RO 0 Reserved <p>Table 4-51: Low Power General Purpose 0 Register </p> Low Power General Purpose 0 PWRSEQ_GP0 [0x0048] Bits Name Access Reset Description 31:0 - R/W 0x1000 0000 General Purpose Field        This register can be used as a general-purpose register by software and retains the contents during SLEEP, LPM, UPM, STANDBY, and BACKUP. <p>Table 4-52: Low Power General Purpose 1 Register </p> Low Power General Purpose 1 PWRSEQ_GP1 [0x004C] Bits Name Access Reset Description 31:0 - R/W 0x1000 0000 General Purpose Field        This register can be used as a general-purpose register by software and retains the contents during SLEEP, LPM, UPM, STANDBY, and BACKUP."},{"location":"system-power-clocks-reset/#trim-system-initialization-registers-trimsir","title":"Trim System Initialization Registers (TRIMSIR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Note: The TRIMSIR registers are reset only on a POR. System reset, soft reset, and peripheral reset do not affect the TRIMSIR register values.</p> <p>Table 4-53: Trim System Initialization Register Summary </p> Offset Register Name [0x0008] TRIMSIR_RTC RTC Trim System Initialization Register [0x0034] TRIMSIR_SIMO System Initialization Register [0x003C] TRIMSIR_IPOLO System Initialization Function Status Register [0x0040] TRIMSIR_CTRL Control Trim System Initialization Register [0x0044] TRIMSIR_INRO INRO Trim System Initialization Register"},{"location":"system-power-clocks-reset/#trim-system-initialization-register-details","title":"TRIM System Initialization Register Details","text":"<p>Table 4-54: RTC Trim System Initialization Register </p> RTC Trim System Initialization TRIMSIR_RTC [0x0008] Bits Name Access Reset Description 31:0 lock RO * LockThis register is read-only if this field is set to 1, and the RTC X1 and RTC X2 fields cannot be modified. 30:26 - RO 0 Reserved 25:21 x2trim R/W* 0 RTC X2 TrimThe X2 trim setting for the RTC. <p>Note: If TRIMSIR_RTC.lock is set to 1, this field is read-only.</p> 20:16 x1trim R/W* 0 RTC X1 TrimThe X1 trim setting for the RTC. <p>Note: If TRIMSIR_RTC.lock is set to 1, this field is read-only.</p> 15:0 - RO 0 Reserved <p>Table 4-55: SIMO Trim System Initialization Register </p> SIMO System Initialization TRIMSIR_SIMO [0x0034] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2:0 clkdiv R/W 1 SIMO Clock DivideThis field selects the SIMO clock divisor. The SIMO uses the INRO as its input clock.             0: INRO/1            1: INRO/16            2: Reserved for Future Use            3: INRO/32            4: Reserved for Future Use            5: INRO/64            6: Reserved for Future Use            7: INRO/128         <p>Table 4-56: IPO Low Trim System Initialization Register </p> IPO Trim Low System Initialization TRIMSIR_IPOLO [0x003C] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 ipo_limitlo RO See Description IPO Low Trim LimitThis field contains the low trim limit for the IPO.  <p>Table 4-57: Control Trim System Initialization Register </p> Control System Initialization TRIMSIR_CTRL [0x0040] Bits Name Access Reset Description 31:29 inro_trim R/W See Description INRO Clock TrimThis field contains the trim for the INRO when set to 8KHz. 28:26 - RO 0 Reserved 25:24 inro_sel R/W 2 INRO Clock SelectThis field selects the INRO frequency.         0: 8KHz        1: 16KHz        2: 30KHz (Power-On Reset default)        3: Reserved for Future Use         23:15 ipo_limithi R/W 0x1FF IPO High Trim LimitThis field contains the high limit for the IPO.  14:8 vdda_limithi R/W 0x78 V<sub>DDA</sub> High Trim Limit        This field is the high trim limit for V<sub>DDA</sub>. 7 - RO 0 Reserved 6:0 vdda_limitlo R/W 0x64 V<sub>DDA</sub> Low Trim Limit        This field is the low trim limit for V<sub>DDA</sub>. <p>Table 4-58: INRO Trim System Initialization Register </p> INRO System Initialization TRIMSIR_INRO [0x0044] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:6 lpclksel R/W 2 INRO Low Power Mode Clock Select        This field selects the INRO clock frequency for LPM operation.         0: 8KHz        1: 16KHz        2: 30KHz (POR default)        3: Reserved for Future Use         5:3 trim30k R/W 0 INRO 30KHz TrimThis field contains the trim for the INRO when set to 30KHz.  2:0 trim16k R/W 0 INRO 16KHz TrimThis field contains the trim for the INRO when set to 16KHz."},{"location":"system-power-clocks-reset/#global-control-registers-gcr","title":"Global Control Registers (GCR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Note: The GCR are only reset on a system reset or POR. A soft reset or peripheral reset does not affect these registers.</p> <p>Table 4-59: Global Control Register Summary </p> Offset Register Name [0x0000] GCR_SYSCTRL System Control Register [0x0004] GCR_RST0 Reset Register 0 [0x0008] GCR_CLKCTRL Clock Control Register [0x000C] GCR_PM Power Management Register [0x0018] GCR_PCLKDIV Peripheral Clocks Divisor [0x0024] GCR_PCLKDIS0 Peripheral Clocks Disable 0 [0x0028] GCR_MEMCTRL Memory Clock Control [0x002C] GCR_MEMZ Memory Zeroize Register [0x0040] GCR_SYSST System Status Flags [0x0044] GCR_RST1 Reset Register 1 [0x0048] GCR_PCLKDIS1 Peripheral Clocks Disable 1 [0x004C] GCR_EVENTEN Event Enable Register [0x0050] GCR_REVISION Revision Register [0x0054] GCR_SYSIE System Status Interrupt Enable [0x0064] GCR_ECCERR Error Correction Coding Error Register [0x0068] GCR_ECCCED Error Correction Coding Correctable Error Detected [0x006C] GCR_ECCIE Error Correction Coding Interrupt Enable Register [0x0070] GCR_ECCADDR Error Correction Coding Error Address Register [0x0080] GCR_GPR0 General Purpose Register 0"},{"location":"system-power-clocks-reset/#global-control-register-details-gcr","title":"Global Control Register Details (GCR)","text":"<p>Table 4-60: System Control Register </p> System Control GCR_SYSCTRL [0x0000] Bits Name Access Reset Description 31:18 - RO 0 Reserved 17:16 ovr R/W 0b10 Operating Voltage Range        Set this field to match the V<sub>COREA</sub> voltage to enable the on-chip RAM to operate at the optimal timing range.         0b00: 0.9V \u00b1 10%        0b01: 1.0V \u00b1 10%        0b10: 1.1V \u00b1 10%        0b11: Reserved for Future Use        15 chkres R 0 ROM Checksum Calculation Pass/Fail        This field is the result after setting the GCR_SYSCTRL.cchk bit.         This bit is only valid after the ROM checksum is complete and GCR_SYSCTRL.cchk is cleared.               0: Pass        1: Fail         14 swd_dis R/W 0 Serial Wire Debug Disable        This bit is used to disable the serial wire debug interface.                    0: Enabled           1: Disabled                Note: This bit is only writeable if the flash is not factory locked or if the GCR_SYSST.icelock bit is 0 and the GCR_SYSCTRL.romdone bit is 1.        13 cchk R/W 0 Calculate ROM Checksum       This bit is self-clearing when the ROM checksum calculation is complete, and the result is available at bit GCR_SYSCTRL.chkres. Writing a 0 has no effect.                    0: No operation           1: Start ROM checksum calculation          12 romdone DNM 1 ROM Start Code Status       Reserved, Do Not Modify        11:7 - RO 0 Reserved 6 icc0_flush R/W 0 ICC0 Cache Flush       Write 1 to flush the code cache and the instruction buffer for the CM4. This bit is automatically cleared to 0 when the flush is complete. Writing 0 has no effect and does not stop a cache flush in progress.                    0: Normal operation           1: Flush the contents of the ICC0 cache.          5:1 - RO 1 Reserved 0 bstapen DNM * Boundary Scan Tap Enable       This field's reset value matches GCR_SYSST.icelock. Do not modify.        <p>Table 4-61: Reset Register 0 </p> Reset 0 GCR_RST0 [0x0004] Bits Name Access Reset Description 31 sys R/W 0 System Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.      See System Reset for additional information.             0: Normal operation           1: Initiate reset        30 periph R/W 0 Peripheral Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset            Note: Watchdog timers, GPIO ports, the AoD, RAM retention, and the GCR are unaffected.      See Table 4-5 for additional information.      29 soft R/W 0 Soft Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.      See Soft Reset for additional information.            0: Normal operation           1: Initiate reset        28 uart2 R/W 0 UART2 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        27 - R/W 0 Reserved 28 uart2 R/W 0 UART2 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        28 uart2 R/W 0 UART2 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        27 - R/W 0 Reserved 26 adc R/W 0 ADC Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        25 cnn R/W 0 CNN Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        24 trng R/W 0 TRNG Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        17 rtc R/W 0 RTC Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        16 i2c0 R/W 0 I2C0 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        15:14 - RO 0 Reserved 13 spi1 R/W 0 SPI1 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        12 uart1 R/W 0 UART1 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        11 uart0 R/W 0 UART0 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        10:9 - RW 0 Reserved 8 tmr3 R/W 0 TMR3 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        7 tmr2 R/W 0 TMR2 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        6 tmr1 R/W 0 TMR1 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        5 tmr0 R/W 0 TMR0 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        4 - RO - Reserved 3 gpio1 R/W 0 GPIO1 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        2 gpio0 R/W 0 GPIO0 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        1 wdt0 R/W 0 Watchdog Timer 0 Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        0 dma R/W 0 DMA Access Block Reset     Write 1 to reset. This field is cleared by hardware when the reset is complete.            0: Normal operation           1: Initiate reset        <p>Table 4-62: Clock Control Register </p> Clock Control GCR_CLKCTRL [0x0008] Bits Name Access Reset Description 31:30 - DNM 0b10 Reserved, Do Not Modify 29 inro_rdy - 0 8kHz Internal Nano-Ring Oscillator (INRO) Ready Status            0: Not ready or not enabled.           1: Oscillator ready.        28 ibro_rdy R 0 7.3728MHz Internal Baud Rate Oscillator (IBRO) Ready Status            0: Not ready.           1: Oscillator ready.        27 ipo_rdy R 0 100MHz Internal Primary Oscillator (IPO) Ready Status            0: Not ready or not enabled.           1: Oscillator ready.        26 iso_rdy R 0 60MHz Internal Secondary Oscillator (ISO) Ready Status            0: Not ready or not enabled.           1: Oscillator ready.        25 ertco_rdy R 0 32.768kHz External RTC Oscillator (ERTCO) Ready Status            0: Not ready or not enabled.           1: Oscillator ready.        24:22 - RO 0 Reserved 21 ibro_vs R/W 0 7.3728MHz IBRO Power Supply Select            0: IBRO is powered from V<sub>COREA</sub>           1: IBRO is powered using a dedicated 1V regulated internal supply        20 ibro_en RO 1 7.3728MHz IBRO Enable     The IBRO is always enabled.            1: Enabled and ready when GCR_CLKCTRL.ibro_rdy = 1.        19 ipo_en R/W 0 100MHz IPO Enable            0: Disabled           1: Enabled and ready when GCR_CLKCTRL.ipo_rdy = 1.        18 iso_en R/W 1 60MHz ISO Enable     Set this field to 0 to disable the ISO. The ISO is the System Oscillator (SYS_OSC) after a POR or System Reset.            0: Disabled           1: Enabled and ready when GCR_CLKCTRL.iso_rdy = 1        17 ertco_en R/W 0 32.768kHz ERTCO Enable            0: Disabled if the RTC_CTRL.en field is also set to 0.           1: Enabled and ready when GCR_CLKCTRL.ertco_rdy = 1, regardless of the state of the RTC_CTRL.en field.        16:14 - RO 0 Reserved 13 sysclk_rdy R 0 SYS_OSC Select Ready     When SYS_OSC is changed by modifying GCR_CLKCTRL.sysclk_sel, there is a delay until the switchover is complete. This bit is cleared until the switchover completes.            0: Switch to new clock source not yet complete.           1: SYS_OSC is the clock source selected in GCR_CLKCTRL.sysclk_sel.        12 - RO 0 Reserved 11:9 sysclk_sel R/W 0 System Clock Source Select     Selects the system oscillator (SYS_OSC) used as the system clock (SYS_CLK) source.      Modifying this field clears GCR_CLKCTRL.sysclk_rdy immediately.            0: ISO (POR and system reset default)           1: Reserved           2: Reserved           3: INRO           4: IPO           5: IBRO           6: ERTCO           7: External Clock, EXT_CLK, P0.3, AF1        8:6 sysclk_div R/W 0 System Clock Prescaler     Sets the divider for generating SYS_CLK from the selected SYS_OSC as shown in the following equation:      $$     \\text{SYS_CLK} = \\frac{\\text{SYS_OSC}}{2^{\\text{sysclk_div}}}     $$      Note: Valid values are from 0 to 7 for sysclk_div.      5:0 - RO 8 Reserved <p>Table 4-63: Power Management Register </p> Power Management GCR_PM [0x000C] Bits Name Access Reset Description 31:18 - RO 0 Reserved 17 ibro_pd R/W 1 IBRO Power Down LPM       Set this field to 1 to power down the IBRO when entering LPM.            0: IBRO is powered on during LPM           1: IBRO is powered off during LPM 16 ipo_pd R/W 1 IPO Power Down LPM       Set this field to 1 to power down the IPO when entering LPM.            0: IPO is powered on during LPM           1: IPO is powered off during LPM 15 iso_pd R/W 1 ISO Power Down LPM       Set this field to 1 to power down the ISO when entering LPM.            0: ISO is powered on during LPM           1: ISO is powered off during LPM 14:10 - DNM 0b11100 Reserved 9 aincomp_we R/W 0 Analog Input Comparator Wakeup Enable     This bit enables the Analog Input Comparator interrupt to wake the device from SLEEP, LPM, or BACKUP.      8 - RO 0 Reserved 7 wut_we R/W 0 Wake-Up Timer Enable       Set this field to 1 to enable the wake-up timer as a wake-up source. The wake-up timer wakes the device from SLEEP, LPM, or BACKUP.            0: Wake-up source disabled           1: Wake-up source enabled        6 - RO 0 Reserved 5 rtc_we R/W 0 RTC Alarm Wakeup Enable       Set this field to 1 to enable an RTC alarm to wake the device. The RTC alarm wakes the device from SLEEP, LPM, or BACKUP.            0: Wakeup source disabled           1: Wakeup source enabled        4 gpio_we R/W 0 GPIO Wake-Up Enable       Set this field to 1 to enable all GPIO pins as potential wake-up sources. Any GPIO configured for wake-up wakes the device from SLEEP, LPM, or BACKUP.            0: Wake-up source disabled           1: Wake-up source enabled        3:0 mode R/W 0 Operating Mode     This field controls the operating mode of the device.            0: ACTIVE           1: SLEEP           2: STANDBY           3: Reserved           4: BACKUP           5-7: Reserved           8: LPM (CM4 deep sleep)           9: UPM           10: PDM           11-15: Reserved        <p>Table 4-64: Peripheral Clock Divisor Register </p> Peripheral Clocks Divisor GCR_PCLKDIV [0x0018] Bits Name Access Reset Description 31:18 - RO - Reserved 17 cnnclksel R/W 0 CNN Peripheral Clock Select     Set this field to select the clock source for the CNN peripheral clock:      $$     f_{\\text{CNN_Clock}}     $$                 0: PCLK           1: ISO        16:14 cnnclkdiv R/W 0 CNN Peripheral Clock Frequency Divider     This field is used as a divider of the CNN peripheral clock. The CNN peripheral clock,     $$     f_{\\text{CNN_Clock}}     $$     is selected using the field GCR_PCLKDIV.cnnclksel.            0: CNN_Clock / 2           1: CNN_Clock / 4           2: CNN_Clock / 8           3: CNN_Clock / 16           4-7: CNN_Clock / 1        13:10 adcfrq R/W 0 ADC Peripheral Clock Frequency Select     This field configures the frequency of the ADC peripheral clock from the PCLK.            0: Reserved            1: Reserved            2-15:            $$            f_{\\text{adc_clock}} = \\frac{f_{\\text{PCLK}}}{\\text{adcfrq}}            $$             9:0 - RO - Reserved <p>Table 4-65: Peripheral Clock Disable Register 0 </p> Peripheral Clocks Disable 0 GCR_PCLKDIS0 [0x0024] Bits Name Access Reset Description 31:30 - R/W 1 Reserved 29 pt R/W 1 Pulse Train Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled.           1: Clock disabled        28 i2c1 R/W 1 I2C1 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        27:26 - RO 1 Reserved 25 cnn R/W 1 CNN Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        24 - RO 1 Reserved 23 adc R/W 1 ADC Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        22:19 - RO 1 Reserved 18 tmr3 R/W 1 TMR3 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        17 tmr2 R/W 1 TMR2 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        16 tmr1 R/W 1 TMR1 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        15 tmr0 R/W 1 TMR0 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        14 - RO 1 Reserved 13 i2c0 R/W 1 I2C0 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        12:11 - RO 1 Reserved 10 uart1 R/W 1 UART1 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        9 uart0 R/W 1 UART0 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        8:7 - RO 0b11 Reserved 6 spi1 R/W 1 SPI1 Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        5 dma R/W 1 DMA Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        4:2 - RO 0b11 Reserved 1 gpio1 R/W 1 GPIO1 Port and Pad Logic Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        0 gpio0 R/W 1 GPIO0 Port and Pad Logic Clock Disable       Disabling a clock disables functionality while also saving power. Reads and writes to peripheral registers are disabled. Peripheral register states are retained.            0: Clock enabled           1: Clock disabled        <p>Table 4-66: Memory Clock Control Register </p> Memory Clock Control GCR_MEMCTRL [0x0028] Bits Name Access Reset Description 31:17 - RO 0 Reserved 16 sysram0ecc R/W 0 Sysram0 ECC Enable       Set this field to 1 to enable ECC for sysram0.            0: Sysram0 active, ECC disabled.           1: Sysram0 active, ECC enabled.        15:3 - RO 0 Reserved 2:0 fws R/W 5 Program Flash Wait States       This field sets the number of wait-state cycles per flash memory read access.            0 \u2013 7: Number of flash code access wait states Note: For the IPO and ISO clocks, the minimum wait state is 2. Note: For all other clock sources, the minimum wait state is 0.  <p>Table 4-67: Memory Zeroize Control Register </p> Memory Zeroize GCR_MEMZ [0x002C] Bits Name Access Reset Description 31:7 - RO - Reserved 6 icc1 R/W1O 0 ICC1 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Operation complete.           1: Operation in progress.        5 icc0 R/W1O 0 ICC0 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        4 sysram0ecc R/W1O 0 Sysram0 ECC Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        3 ram3 R/W1O 0 Sysram3 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        2 ram2 R/W1O 0 Sysram2 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        1 ram1 R/W1O 0 Sysram1 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        0 ram0 R/W1O 0 Sysram0 Zeroization       Write 1 to initiate the operation. This field is automatically cleared by hardware on completion.            0: Normal operation           1: Initiate zeroization        <p>Table 4-68: System Status Flag Register </p> System Status Flag GCR_SYSST [0x0040] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 icelock R 0 Arm ICE Lock Status Flag        0: Arm ICE is unlocked (enabled)       1: Arm ICE is locked (disabled)        <p>Table 4-69: Reset Register 1 </p> Reset 1 GCR_RST1 [0x0044] Bits Name Access Reset Description 31 cpu1 RO 0 CPU1 (RV32) Reset         Write 1 to initiate the reset operation.          0: Normal operation         1: Initiate reset          30:26 - RO 0 Reserved 25 simo R/W 0 Single Inductor Multiple Output Block Reset         Write 1 to initiate the reset operation.          0: Normal operation         1: Initiate reset          24 dvs R/W 0 Dynamic Voltage Scaling Controller Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          23:21 - RO 0 Reserved 20 i2c2 R/W 0 I2C2 Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          19 i2s R/W 0 Audio Interface Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          18:17 - R/W 0 Reserved 16 smphr R/W 0 Semaphore Block Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          15:12 - R/W - Reserved 11 spi0 R/W 0 SPI0 Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          10 aes R/W 0 AES Block Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          9 crc R/W 0 CRC Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          8 - R/W 0 Reserved 7 owm R/W 0 1-Wire Reset         Write 1 to initiate the operation.         0: Normal operation         1: Initiate reset      6:2 - RO 0 Reserved 1 pt R/W 0 Pulse Train Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          0 i2c1 R/W 0 I2C1 Reset         Write 1 to initiate the operation.          0: Normal operation         1: Initiate reset          <p>Table 4-70: Peripheral Clock Disable Register 1 </p> Peripheral Clock Disable 1 GCR_PCLKDIS1 [0x0048] Bits Name Access Reset Description 31 cpu1 R/W 1 CPU1 (RV32 Clock Disable)         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled         1: Disabled          30:28 - R/W 1 Reserved 27 wdt0 R/W 1 Watchdog Timer 0 Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled         1: Disabled          26:25 - R/W 1 Reserved 24 i2c2 R/W 1 I2C2 Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled         1: Disabled          23 i2s0 R/W 1 I2S Audio Interface Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled         1: Disabled          22:17 - R/W 1 Reserved 16 spi0 R/W 1 SPI0 Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          15 aes R/W 1 AES Block Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          14 crc R/W 1 CRC Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          13 owm R/W 1 1-Wire Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          12:10 - R/W1 1 Reserved 9 smphr R/W 1 Semaphore Block Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          8:3 - R/W1 1 Reserved 2 trng R/W 1 TRNG Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          1 uart2 R/W 1 UART2 Clock Disable         Disabling the clock disables functionality while also saving power. Associated register states are retained but read and write access is blocked.          0: Enabled.         1: Disabled.          0 - R/W1 1 Reserved <p>Table 4-71: Event Enable Register </p> Event Enable GCR_EVENTEN [0x004C] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2 tx R/W 0 CPU0 (CM4) TXEV Event Enable         A TXEV event wakes the CM4 from a low-power mode entered with a WFE instruction when this bit is set.          0: Disabled         1: Enabled          1 - RO 0 Reserved 0 dma R/W 0 CPU0 (CM4) DMA CTZ Wake-Up Enable     Enables a DMA CTZ event to generate an RXEV interrupt to wake the CM4 from a low-power mode entered with a WFE instruction.          0: Disabled.         1: Enabled.        <p>Table 4-72: Revision Register </p> Revision GCR_REVISION [0x0050] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:0 revision R * Device Revision     This field returns the chip revision ID as packed BCD. For example, 0x00A1 would indicate the device is revision A1.      <p>Table 4-73: System Status Interrupt Enable Register </p> System Status Interrupt Enable GCR_SYSIE [0x0054] Bits Name Access Reset Description 31:1 - RO - Reserved 0 iceunlock R/W 0 Arm ICE Unlocked Interrupt Enable     Set this field to generate an interrupt if the GCR_SYSST.icelock is set.          0: Interrupt disabled         1: Interrupt enabled        <p>Table 4-74: Error Correction Coding Error Register </p> Error Correction Coding Error GCR_ECCERR [0x0064] Bits Name Access Reset Description 31:1 - RO - Reserved 0 ram0 R/W1C 0 Sysram0 ECC Error     This flag is set if an ECC error occurs in sysram0. Write to 1 to clear the flag.          0: No error         1: Error        <p>Table 4-75: Error Correction Coding Correctable Error Detected Register </p> Error Correction Coding Correctable Error Detected GCR_ECCCED [0x0068] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 ram0 R/W1C 0 sysram0 Correctable ECC Error Detected     When this bit is set, it indicates that there is a single correctable error in the sysram0 block. Write to 1 to clear the flag.          0: No error or uncorrectable error if GCR_ECCERR.ram0 is set to 1.         1: Correctable error detected.          <p>Table 4-76: Error Correction Coding Interrupt Enable Register </p> Error Correction Coding Interrupt Enable GCR_ECCIE [0x006C] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 ram0 R/W 0 Sysram0 ECC Error Interrupt Enable         Set this field to 1 to generate an interrupt if an ECC error condition occurs for sysram0.          0: Interrupt disabled         1: Interrupt enabled          <p>Table 4-77: Error Correction Coding Error Address Register </p> Error Correction Coding Error Address GCR_ECCADDR [0x0070] Bits Name Access Reset Description 31 tagramerr R 0 ECC Error Address/TAG RAM Error       Data depends on which block has reported the error. If sysram0, this bit represents the bit of the AMBA address of the read that produced the error. If the error is in the cache, this bit is set as follows:          0: No error         1: Tag Error. The error is in the TAG RAM.          30 tagrambank R 0 ECC Error Address/TAG RAM Error Bank       Data depends on which block has reported the error. If sysram0, this bit represents the bit of the AMBA address of the read that produced the error. If the error is from the cache, this bit is set as follows:          0: Error is in TAG RAM bank 0         1: Error is in TAG RAM bank 1.          29:16 tagramaddr R 0 ECC Error Address/TAG RAM Error Address         Data depends on which block has reported the error. If sysram0, this field represents the bits of the AMBA address of the read that produced the error. If the error is from the cache, this field is set as follows:          [TAG ADDRESS]: Represents the TAG RAM address.          15 dataramerr R 0 ECC Error Address/Cache Data RAM Error Address       Data depends on which block has reported the error. If sysram0, this bit represents the bit of the AMBA address of the read that produced the error. If the error is from the cache, this bit is set as follows:          0: No error         1: Cache data RAM error.          14 datarambank R 0 ECC Error Address/Cache Data RAM Error Bank       Data depends on which block has reported the error. If sysram0, this bit represents the bits of the AMBA address of the read that produced the error. If the error is from the cache, this bit is set as follows:          0: Error is in the cache data RAM bank 0         1: Error is in the cache data RAM bank 1.          13:0 dataramaddr R 0 ECC Error Address/Cache Data RAM Error Address       Data depends on which block has reported the error. This field represents the bits of the AMBA address of the read that produced the error.          [Data Address]: Represents the error address.          <p>Table 4-78: General Purpose 0 Register </p> General Purpose 0 GCR_GPR0 [0x0080] Bits Name Access Reset Description 31:0 - R/W 0 General Purpose Register      This field is a general-purpose register usable by software."},{"location":"system-power-clocks-reset/#system-initialization-registers-sir","title":"System Initialization Registers (SIR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-79: System Initialization Register Summary </p> Offset Register Name [0x0000] SIR_SISTAT System Initialization Status Register [0x0004] SIR_ADDR System Initialization Address Error Register [0x0100] SIR_FSTAT System initialization Function Status Register [0x0104] SIR_SFSTAT System initialization Security Function Status Register"},{"location":"system-power-clocks-reset/#system-initialization-register-details","title":"System Initialization Register Details","text":"<p>Table 4-80: System Initialization Status Register </p> System Initialization Status SIR_SISTAT [0x0000] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1 crcerr RO See Description CRC Configuration Error Flag     This field is set by hardware during reset if an error in the device configuration is detected in the OTP memory.          0: Configuration valid.         1: Configuration invalid, the address of the configuration error is stored in the SIR_ADDR register. Note: If this field reads 1, a device error has occurred.          Please contact Analog Devices technical support for additional assistance, providing the address contained in the SIR_ADDR.erraddr. 0 magic RO See Description Configuration Valid Flag       This field is set to 1 by hardware during reset if the device configuration is valid.          0: OTP is not configured correctly.         1: OTP configuration valid.          Note: If this field reads 0, the device configuration is invalid, and a device error has occurred during system initialization.          Please contact Analog Devices technical support for additional assistance. <p>Table 4-81: System Initialization Address Error Register </p> System Initialization Status SIR_ADDR [0x0004] Bits Name Access Reset Description 31:0 erraddr RO 0 Configuration Error Address     If the SIR_SISTAT.crcerr field is set to 1, the value in this register is the address of the configuration failure.      <p>Table 4-82: System Initialization Function Status Register </p> System Initialization Function Status SIR_FSTAT [0x0100] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7 smphr RO See Description Semaphore Block       This field indicates if the device includes the semaphore block.          0: Block is not available.         1: Block is available.          6:3 - RO 0 Reserved 2 adc RO See Description ADC         This field indicates if the device includes the ADC.          0: Block is not available.         1: Block is available.          1 - RO 0 Reserved 0 fpu RO See Description FPU         This field indicates if the device includes the FPU.          0: Block is not available.         1: Block is available.          <p>Table 4-83: System Initialization Security Function Status Register </p> System Initialization Security Function Status SIR_SFSTAT [0x0104] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 aes RO See Description AES         This field indicates if the device includes the AES block.          0: Block is not available.         1: Block is available.          2 trng RO See Description TRNG         This field indicates if the device includes the TRNG block.          0: Block is not available.         1: Block is available.          1:0 - RO 0 Reserved"},{"location":"system-power-clocks-reset/#function-control-registers-fcr","title":"Function Control Registers (FCR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-84: Function Control Register Summary </p> Offset Register Name [0x0000] FCR_FCTRL0 Function Control 0 Register (I<sub>2</sub>C Glitch Filter Control) [0x0004] FCR_AUTOCAL0 IPO Automatic Calibration 0 Register [0x0008] FCR_AUTOCAL1 IPO Automatic Calibration 1 Register [0x000C] FCR_AUTOCAL2 IPO Automatic Calibration 2 Register [0x0010] FCR_URVBOOTADDR RV32 Boot Address Register [0x0014] FCR_URVCTRL RV32 Control Register"},{"location":"system-power-clocks-reset/#function-control-register-details","title":"Function Control Register Details","text":"<p>Table 4-85: Function Control 0 Register </p> Function Control 0 FCR_FCTRL0 [0x0000] Bits Name Access Reset Description 31:26 - RO 0 Reserved 25 i2c2_scl_filter_en R/W 0 I2C2 SCL Glitch Filter Enable          0: Disabled         1: Enabled          24 i2c2_sda_filter_en R/W 0 I2C2 SDA Glitch Filter Enable          0: Disabled         1: Enabled          23 i2c1_scl_filter_en R/W 0 I2C1 SCL Glitch Filter Enable          0: Disabled         1: Enabled          22 i2c1_sda_filter_en R/W 0 I2C1 SDA Glitch Filter Enable          0: Disabled         1: Enabled          21 i2c0_scl_filter_en R/W 0 I2C0 SCL Glitch Filter Enable          0: Disabled         1: Enabled          20 i2c0_sda_filter_en R/W 0 I2C0 SDA Glitch Filter Enable          0: Disabled         1: Enabled          19:0 - RO 0 Reserved <p>Table 4-86: IPO Automatic Calibration 0 Register </p> IPO Automatic Calibration 0 FCR_AUTOCAL0 [0x0004] Bits Name Access Reset Description 31:23 trim RO 0 IPO Trim Value     Initial factory trim value for the IPO.      22:20 - RO Reserved 19:8 gain R/W 0 IPO Trim Adaptation Gain 7:5 - RO 0 Reserved 4 atomic R/W1 0 IPO Trim Atomic Start       Set this bit to start an automatic atomic calibration of the IPO.        The calibration runs for FCR_AUTOCAL2.runtime milliseconds.        This bit is automatically cleared by hardware when the calibration is complete.      3 invert R/W 0 IPO Trim Step Invert          0: IPO trim step is not inverted         1: IPO trim step is inverted          2 load R/* 0 IPO Initial Trim Load         Set this bit to load the initial trim value for the IPO from FCR_AUTOCAL1.initial.          This bit is cleared by hardware once the load is complete.      1 en R/W 0 IPO Automatic Calibration Continuous Mode Enable          0: Disabled         1: Enabled          0 acen R/W 0 IPO Trim Select          0: Use default trim         1: Use automatic calibration trim values          <p>Table 4-87: IPO Automatic Calibration 1 Register </p> IPO Automatic Calibration 1 FCR_AUTOCAL1 [0x0008] Bits Name Access Reset Description 31:9 - R/W 0 Reserved, Do Not Modify 8:0 initial R/W 0 IPO Trim Automatic Calibration Initial Trim     This field contains the initial trim setting for the IPO.      <p>Table 4-87: IPO Automatic Calibration 2 Register </p> IPO Automatic Calibration 2 FCR_AUTOCAL2 [0x000C] Bits Name Access Reset Description 31:21 - RO 0 Reserved 20:8 div R/W 0 IPO Trim Automatic Calibration Divide Factor     Target trim frequency for the IPO:      $$     f_{\\text{IPO}} = \\text{div} \\cdot 32768     $$     Note: Setting div to 0 is equivalent to setting div to 1. 7:0 runtime R/W 0 IPO Trim Automatic Calibration Run Time Atomic Run Time = runtime milliseconds <p>Table 4-89: RV32 Boot Address Register </p> RV32 Boot Address FCR_URVBOOTADDR [0x0010] Bits Name Access Reset Description 31:0 - R/W 0x2000 C000 RV32 Boot Address     Set this field to the boot address for the RV32 core.      The reset value for this register is 0x2001 C000, sysram3.      <p>Table 4-90: RV32 Control Register </p> RV32 Control FCR_URVCTRL [0x0014] Bits Name Access Reset Description 31:2 - R/W 0 Reserved 1 iflushen R/W 0 ICC1 Cache Flush Enable      Write 1 to flush the cache and the instruction buffer for the RV32 core.      This bit is automatically cleared to 0 when the flush is complete.      Writing 0 has no effect and does not stop a cache flush in progress.          0: ICC1 flush complete      1: Flush the contents of the ICC1 cache      0 memsel R/W 0 This field determines if sysram2 and sysram3 are shared between the CM4 and RV32 cores.      Set this field to 1 to set the RV32 core as the exclusive master for sysram2 and sysram3.      0: Sysram2 and Sysram3 are shared and accessible by both the CM4 and RV32 cores.      1: Sysram2 and Sysram3 are accessible by the RV32 core only.       Note: The application software must ensure that no accesses are occurring in Sysram2 or Sysram3 before setting this field to 1.      See section Multiprocessor Communications for information on using the semaphore peripheral for communication between the RV32 and CM4 cores."},{"location":"system-power-clocks-reset/#general-control-function-registers-gcfr","title":"General Control Function Registers (GCFR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-91: General Control Function Register Summary </p> Offset Register Name [0x0000] GCFR_REG0 General Control Function Register 0 [0x0004] GCFR_REG1 General Control Function Register 1 [0x0008] GCFR_REG2 General Control Function Register 2 [0x000C] GCFR_REG3 General Control Function Register 3 <p>Table 4-92: General Control Function Register 0 </p> General Control Function 0 GCFR_REG0 [0x0000] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 cnnx16_3_pwr_en R/W 0 CNNx16_3 Power Domain Enable      0: Disabled      1: Enabled      2 cnnx16_2_pwr_en R/W 0 CNNx16_2 Power Domain Enable      0: Disabled      1: Enabled      1 cnnx16_1_pwr_en R/W 0 CNNx16_1 Power Domain Enable      0: Disabled      1: Enabled      0 cnnx16_0_pwr_en R/W 0 CNNx16_0 Power Domain Enable      0: Disabled      1: Enabled      <p>Table 4-93: General Control Function Register 1 </p> General Control Function 1 GCFR_REG1 [0x0004] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 cnnx16_3_ram_en R/W 0 CNNx16_3 RAM Power Enable      0: Disabled      1: Enabled      2 cnnx16_2_ram_en R/W 0 CNNx16_2 RAM Power Enable      0: Disabled      1: Enabled      1 cnnx16_1_ram_en R/W 0 CNNx16_1 RAM Power Enable      0: Disabled      1: Enabled      0 cnnx16_0_ram_en R/W 0 CNNx16_0 RAM Power Enable      0: Disabled      1: Enabled      <p>Table 4-94: General Control Function Register 2 </p> General Control Function 2 GCFR_REG2 [0x0008] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 cnnx16_3_iso R/W 0 CNNx16_3 Power Domain Isolation      0: Disabled      1: Enabled      2 cnnx16_2_iso R/W 0 CNNx16_2 Power Domain Isolation      0: Disabled      1: Enabled      1 cnnx16_1_iso R/W 0 CNNx16_1 Power Domain Isolation      0: Disabled      1: Enabled      0 cnnx16_0_iso R/W 0 CNNx16_0 Power Domain Isolation      0: Disabled      1: Enabled      <p>Table 4-95: General Control Function Register 3 </p> General Control Function 3 GCFR_REG3 [0x000C] Bits Name Access Reset Description 31:4 - RO 0 Reserved 3 cnnx16_3_rst R/W 0 CNNx16_3 Power Domain Reset     Write this field to 1 to initiate a power domain reset for the CNNx16_3.      0: Normal operation      1: Initiate reset      2 cnnx16_2_rst R/W 0 CNNx16_2 Power Domain Reset     Write this field to 1 to initiate a power domain reset for the CNNx16_2.       0: Normal operation      1: Initiate reset      1 cnnx16_1_rst R/W 0 CNNx16_1 Power Domain Reset     Write this field to 1 to initiate a power domain reset for the CNNx16_1.       0: Normal operation      1: Initiate reset      0 cnnx16_0_rst R/W 0 CNNx16_0 Power Domain Reset     Write this field to 1 to initiate a power domain reset for the CNNx16_0.       0: Normal operation      1: Initiate reset"},{"location":"universal-asynchronous-receiver-transmitter/","title":"Universal Asynchronous Receiver/Transmitter","text":"<p>The universal asynchronous receiver/transmitter (UART) and the low-power universal asynchronous receiver/transmitter (LPUART) interfaces communicate with external devices using industry-standard serial communications protocols. The UARTs are full-duplex serial ports. Each UART instance is independently configurable unless using a shared external clock source.</p> <p>The LPUART is a special version of the peripheral that can receive characters at up to 9600 baud while in low-power modes. Hardware loads valid received characters into the receive FIFO and wakes the device when an enabled interrupt condition occurs.</p> <p>The peripheral provides the following features:</p> <ul> <li>Flexible baud rate generation up to 12.5Mbps for UART</li> <li>Programmable character size of 5-bits to 8-bits</li> <li>Stop bit settings of 1, 1.5, or 2-bits</li> <li>Parity settings of even, odd, mark (always 1), space (always 0), and no parity</li> <li>Automatic parity error detection with selectable parity bias</li> <li>Automatic frame error detection.</li> <li>Separate 8-byte transmit and receive FIFOs.</li> <li>Flexible interrupt conditions.</li> <li>Hardware flow control (HFC) using ready-to-send (RTS) and clear-to-send (CTS) pins.</li> <li>Separate DMA channels for transmit and receive.<ul> <li>DMA support is available in ACTIVE and SLEEP.</li> </ul> </li> </ul> <p>The LPUART instance provides these additional features:</p> <ul> <li>Baud rate support for up to 1.85Mbps in ACTIVE</li> <li>Receive characters in SLEEP, LPM, and UPM at up to 9600 baud.</li> <li>Fractional baud rate divisor improves baud rate accuracy for 9600 and lower baud rates.</li> <li>Wake up from low-power modes to ACTIVE on multiple receive FIFO conditions.</li> </ul> <p>Figure 12-1 shows a high-level diagram of the UART peripheral.</p> <p>Figure 12-1: UART Block Diagram </p> <p></p> <p>Note: See Table 12-1 for the clock options supported by each UART instance.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#instances","title":"Instances","text":"<p>Instances of the peripheral are shown in Table 12-1. The standard UARTs and the LPUARTs are functionally similar; they are referred to as UART for common functionality. The LPUART instance supports fractional division mode (FDM) and is referenced as LPUART for feature-specific options.</p> <p>Table 12-1: MAX78000 UART/LPUART Instances </p> Instance Register Access Name LPUART Power Modes Clock Option Hardware Flow Control Transmit FIFO Depth Receive FIFO Depth 0 1 2 3 UART0 UART0 No ACTIVE SLEEP PCLK - IBRO - Yes 8 8 UART1 UART1 UART2 UART2 LPUART0 UART3 Yes ACTIVE SLEEP LPM UPM - - IBRO ERTCO No"},{"location":"universal-asynchronous-receiver-transmitter/#dma","title":"DMA","text":"<p>Each UART instance supports DMA for both transmit and receive; separate DMA channels can be connected to the receive and transmit FIFOs.</p> <p>The UART DMA channels are configured using the UART DMA configuration register, UARTn_DMA. Enable the receive FIFO DMA channel by setting UARTn_DMA.rx_en to 1 and enable the transmit FIFO DMA channel by setting UARTn_DMA.tx_en to 1. DMA transfers are automatically triggered by the hardware based on the number of bytes in the receive FIFO and transmit FIFO.</p> <p>When DMA is enabled, the following describes the behavior of the DMA requests:</p> <ul> <li>A receive DMA request is asserted when the number of bytes in the receive FIFO transitions to be greater than or equal to the receive FIFO threshold.</li> <li>A transmit DMA request is asserted when the number of bytes in the transmit FIFO transitions to be less than the transmit FIFO threshold.</li> </ul>"},{"location":"universal-asynchronous-receiver-transmitter/#uart-frame","title":"UART Frame","text":"<p>Figure 12-2 shows the UART frame structure. Character sizes of 5 to 8 bits are configurable through the UARTn_CTRL.char_size field. Stop bits are configurable as 1 or 1.5 bits for 5-character frames and 1 or 2 stop bits for 6, 7, or 8-character frames. Parity support includes even, odd, mark, space, and none.</p> <p>Figure 12-2: UART Frame Structure </p> <p></p>"},{"location":"universal-asynchronous-receiver-transmitter/#fifos","title":"FIFOs","text":"<p>Separate receive and transmit FIFOs are provided. The FIFOs are both accessed through the same UARTn_FIFO.data field. The current level of the transmit FIFO is read from the UARTn_STATUS.tx_lvl field. The current level of the receive FIFO is read from the UARTn_STATUS.rx_lvl field. Data for character sizes less than 7 bits are right justified.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#transmit-fifo-operation","title":"Transmit FIFO Operation","text":"<p>Writing data to the UARTn_FIFO.data field increments the transmit FIFO pointer, UARTn_STATUS.tx_lvl, and loads the data into the transmit FIFO. The UARTn_TXPEEK.data register provides a feature that allows the software to \"peek\" at the current value of the write-only transmit FIFO without changing the UARTn_STATUS.tx_lvl. Writes to the transmit FIFO are ignored while UARTn_STATUS.tx_lvl = C_TX_FIFO_DEPTH.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#receive-fifo-operation","title":"Receive FIFO Operation","text":"<p>Reads of the UARTn_FIFO.data field return the character values in the receive FIFO and decrement the UARTn_STATUS.rx_lvl. An overrun event occurs if a valid frame, including parity, is detected while UARTn_STATUS.rx_lvl = C_RX_FIFO_DEPTH. When an overrun event occurs, the data is discarded by hardware.</p> <p>A parity error event indicates that the value read from UARTn_FIFO.data contains a parity error.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#flushing","title":"Flushing","text":"<p>The FIFOs are flushed on the following conditions:</p> <ul> <li>Setting the UARTn_CTRL.rx_flush field to 1 flushes the receive FIFO by setting its pointer to 0.</li> <li>Setting the UARTn_CTRL.tx_flush field to 1 flushes the transmit FIFO by setting its pointer to 0.</li> <li>Flush the FIFOs by setting the GCR_RST0.uart0, GCR_RST0.uart1, or GCR_RST0.uart2 field to 1.</li> </ul>"},{"location":"universal-asynchronous-receiver-transmitter/#interrupt-events","title":"Interrupt Events","text":"<p>The peripheral generates interrupts for the events shown in Table 12-2. Unless noted otherwise, each instance has its own set of interrupts and higher-level flag and enable fields, as shown in Table 12-2.</p> <p>Figure 12-3: UART Interrupt Functional Diagram </p> <p></p> <p>Some activities may cause more than one event, setting one or more event flags. An event interrupt occurs if the corresponding interrupt enable is set. The interrupt flags, when set, must be cleared by the software by writing 1 to the corresponding interrupt flag field.</p> <p>Table 12-2: MAX78000 Interrupt Events </p> Event Interrupt Flag Interrupt Enable Frame Error UARTn_INT_FL.rx_ferr UARTn_INT_EN.rx_ferr Parity Error UARTn_INT_FL.rx_par UARTn_INT_EN.rx_par CTS Signal Change UARTn_INT_FL.cts_ev UARTn_INT_EN.cts_ev Receive FIFO Overrun UARTn_INT_FL.rx_ov UARTn_INT_EN.rx_ov Receive FIFO Threshold UARTn_INT_FL.rx_thd UARTn_INT_EN.rx_thd Transmit FIFO Half-Empty UARTn_INT_FL.tx_he UARTn_INT_EN.tx_he"},{"location":"universal-asynchronous-receiver-transmitter/#frame-error","title":"Frame Error","text":"<p>A frame error is generated when the UART sampling circuitry detects an invalid bit. As shown in Figure 12-4, each bit is sampled three times and can generate a frame error on the start bit, stop bit, data bits, and optionally the parity bit. When a frame error occurs, the data is discarded.</p> <p>The frame error criteria are different based on the following:</p> <ul> <li> <p>Standard UART and LPUART with FDM disabled:</p> <ul> <li>The start bit is sampled 3 times, and all samples must be 0, or a frame error is generated.</li> <li>Each data bit is sampled, and 2 of the 3 samples must match, or a frame error is generated.</li> <li>If parity is enabled, the parity bit is sampled 3 times, and all samples must match, or a frame error is generated.</li> <li>The stop bit is sampled 3 times, and all samples must be 1, or a frame error is generated.</li> <li>See Table 12-3 for details.</li> </ul> </li> <li> <p>LPUART with FDM enabled (UARTn_CTRL.fdm = 1) and data/parity edge detect enabled (UARTn_CTRL.dpfe_en = 1):</p> <ul> <li>The start bit is sampled 3 times, and all samples must be 0, or a frame error is generated.</li> <li>Each data bit is sampled 3 times, and all samples must match, or a frame error is generated.</li> <li>If parity is enabled, the parity bit is sampled 3 times, and all samples must match, or a frame error is generated.</li> <li>The stop bit is sampled 3 times, and all samples must be 1, or a frame error is generated.</li> <li>See Table 12-4 for details.</li> </ul> </li> </ul> <p>Table 12-3: Frame Error Detection for Standard UARTs and LPUART </p> UARTn_CTRL.par_en UARTn_CTRL.par_md UARTn_CTRL.par_eo Start Samples Data Samples Parity Samples Stop Samples 0 N/A N/A 3 of 3 must be 0 2/3 must match Not Present 3 of 3 must be 1 1 0 0              3/3 = 1 if even number \"1\"             3/3 = 0 if odd number \"0\"          0 1              3/3 = 1 if odd number \"1\"             3/3 = 0 if even number \"0\" 1 0              3/3 = 1 if even number \"0\"             3/3 = 0 if odd number \"1\"          1 1              3/3 = 1 if odd number \"0\"             3/3 = 0 if even number \"1\"          <p>Table 12-4: Frame Error Detection for LPUARTs with UARTn_CTRL.fdm = 1 and UARTn_CTRL.dpfe_en = 1 </p> UARTn_CTRL.par_en UARTn_CTRL.par_md UARTn_CTRL.par_eo Start Samples Data Samples Parity Samples Stop Samples 0 N/A N/A 3 of 3 must be 0 3 of 3 must match Not Present 3 of 3 must be 1 1 0 0              3 of 3 = 1 if even number of 1s             3 of 3 = 0 if odd number 0s          0 1              3 of 3 = 1 if odd number 1s             3 of 3 = 0 if even number 0s          1 0              3 of 3 = 1 if even number 0s             3 of 3 = 0 if odd number 1s          1 1              3 of 3 = 1 if odd number 0s             3 of 3 = 0 if even number 1s"},{"location":"universal-asynchronous-receiver-transmitter/#parity-error","title":"Parity Error","text":"<p>Set UARTn_CTRL.par_en = 0 to enable parity checking of the received frame. If the calculated parity does not match the parity bit, then the corresponding interrupt flag is set. The data received is saved to the receive FIFO when a parity error occurs.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#cts-signal-change","title":"CTS Signal Change","text":"<p>A CTS signal change condition occurs if HFC is enabled, the UART baud clock is enabled, and the CTS pin changes state.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#overrun","title":"Overrun","text":"<p>An overrun condition occurs if a valid frame is received when the receive FIFO is full. The interrupt flag is set at the end of the stop bit, and the frame is discarded.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#receive-fifo-threshold","title":"Receive FIFO Threshold","text":"<p>A receive FIFO threshold event occurs when a valid frame is received that causes the number of bytes to exceed the configured receive FIFO threshold UARTn_CTRL.rx_thd_val.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#transmit-fifo-half-empty","title":"Transmit FIFO Half-Empty","text":"<p>The transmit FIFO half-empty event occurs when UARTn_STATUS.tx_lvl transitions from more than half-full to half-empty, as shown in Equation 12-1.</p> <p>Note: When this condition occurs, verify the number of bytes in the transmit FIFO (UARTn_STATUS.tx_lvl) before re-filling.</p> <p>Equation 12-1: UART Transmit FIFO Half-Empty Condition </p> \\[ \\left(\\frac{C{\\_}TX{\\_}FIFO{\\_}DEPTH}{2} + 1 \\right)\\ \\overset{Transistions\\ from}{\\rightarrow}\\ \\left(\\frac{C{\\_}TX{\\_}FIFO{\\_}DEPTH}{2} \\right) \\]"},{"location":"universal-asynchronous-receiver-transmitter/#lpuart-wakeup-events","title":"LPUART Wakeup Events","text":"<p>LPUART instances can receive characters while in the low-power modes listed in Table 12-1. If enabled, each of the receive FIFO conditions shown in Table 12-5 wakes the device, exits the low-power mode, and returns the device to ACTIVE.</p> <p>Unlike interrupts, wake-up activity is based on a condition, not an event. As long as the condition is true and the wake-up enable field is set to 1, the wake-up flag remains set.</p> <p>Table 12-5: MAX78000 Wakeup Events </p> Receive FIFO Condition          Wake-Up Flag UARTn_WKFL             Wake-Up Enable UARTn_WKEN Low-Power Peripheral  Wake-Up Flag Low-Power Peripheral  Wake-Up Enable Low-Power  Clock Disable Threshold rx_thd rx_thd PWRSEQ_LPPWST.uart3 PWRSEQ_LPPWEN.uart3 LPGCR_PCLKDIS.uart3 Full rx_full rx_full Not Empty rx_ne rx_ne"},{"location":"universal-asynchronous-receiver-transmitter/#receive-fifo-threshold_1","title":"Receive FIFO Threshold","text":"<p>This condition persists while UARTn_STATUS.rx_lvl \u2265 UARTn_CTRL.rx_thd_val.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#receive-fifo-full","title":"Receive FIFO Full","text":"<p>This condition persists while UARTn_STATUS.rx_lvl \u2265 C_RX_FIFO_DEPTH.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#receive-not-empty","title":"Receive Not Empty","text":"<p>This condition persists while UARTn_STATUS.rx_lvl &gt; 0.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#inactive-state","title":"Inactive State","text":"<p>The following conditions result in the UART being inactive:</p> <ul> <li>When UARTn_CTRL.bclken = 0</li> <li>After setting UARTn_CTRL.bclken to 1 until UARTn_CTRL.bclkrdy = 1</li> <li>Any write to the UARTn_CLKDIV.clkdiv field while UARTn_CTRL.bclken = 1</li> <li>Any write to the UARTn_OSR.osr field when UARTn_CTRL.bclken = 1</li> </ul>"},{"location":"universal-asynchronous-receiver-transmitter/#receive-sampling","title":"Receive Sampling","text":"<p>Each bit of a frame is oversampled to improve noise immunity. The oversampling rate (OSR) is configurable with the UARTn_OSR.osr field. In most cases, the bit is evaluated based on three samples at the midpoint of each bit time, as shown in Figure 12-4.</p> <p>Figure 12-4: Oversampling Example </p> <p></p> <p>Whenever UARTn_CLKDIV.clkdiv &lt; 0x10 (i.e., division rate less than 8.0), OSR is not used, and the oversampling rate is adjusted to full sampling by the hardware. In full sampling, the receive input is sampled on every clock cycle regardless of the OSR setting.</p> <p>Note: For 9600 baud low-power operation, the dual-edge sampling mode must be enabled (UARTn_CTRL.desm = 1).</p>"},{"location":"universal-asynchronous-receiver-transmitter/#baud-rate-generation","title":"Baud Rate Generation","text":"<p>The baud rate is determined by the selected UART clock source and the value of the clock divisor. Multiple clock sources are available for each UART instance. See Table 12-1 for available clock sources.</p> <p>Note: Changing the clock source should only be done between data transfers to avoid corrupting an ongoing data transfer.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#uart-clock-sources","title":"UART Clock Sources","text":"<p>Standard UART instances operate only in ACTIVE and SLEEP. Standard UART instances can only wake the device from SLEEP. Figure 12-5 shows the baud rate generation path for standard UARTs.</p> <p>Figure 12-5: UART Baud Rate Generation </p> <p></p>"},{"location":"universal-asynchronous-receiver-transmitter/#lpuart-clock-sources","title":"LPUART Clock Sources","text":"<p>LPUART instances support FDM and are configurable for operation at 9600 and lower baud rates for operation in SLEEP, LPM, and UPM. Operation in LPM and UPM requires the use of the ERTCO as the baud rate clock source. The ERTCO can be configured to remain active in LPM and UPM, allowing the LPUART to receive data and serve as a wake-up source while power consumption is at a minimum.</p> <p>Figure 12-6: LPUART Timing Generation </p> <p></p>"},{"location":"universal-asynchronous-receiver-transmitter/#baud-rate-calculation","title":"Baud Rate Calculation","text":"<p>The transmit and receive circuits share a common baud rate clock, the selected UART clock source divided by the clock divisor. Instances that support FDM offer a 0.5 fractional clock division when enabled by setting UARTn_CTRL.fdm = 1. This allows for greater accuracy when operating at low baud rates and finer granularity for the oversampling rate.</p> <p>Use the following formula to calculate the UARTn_CLKDIV.clkdiv value based on the clock source, desired baud rate, and integer or fractional divisor.</p> <p>Equation 12-2: UART Clock Divisor Formula </p> \\[ {UARTn{\\_}CTRL.fdm = 0:} \\] \\[ {UARTn{\\_}CLKDIV.clkdiv = INT\\left\\lbrack \\frac{UART\\ Clock}{Baud\\ Rate} \\right\\rbrack} \\] <p>Equation 12-3: LPUART Clock Divisor Formula for UARTn_CTRL.fdm = 1 </p> \\[ {UARTn{\\_}CTRL.fdm = 1:} \\] \\[ {UARTn{\\_}CLKDIV.clkdiv = INT\\left\\lbrack \\frac{UART\\ Clock}{Baud\\ Rate} \\times 2 \\right\\rbrack} \\] <p>For example, in a case where the UART clock is 50MHz, and the target baud rate is 115,200 bps:</p> <ul> <li> <p>UARTn_CTRL.fdm = 0,      \\(UARTn{\\_}CLKDIV.clkdiv = \\left(\\frac{50,000000}{115,200} \\right) = 434\\)</p> </li> <li> <p>UARTn_CTRL.fdm = 1,      \\(UARTn{\\_}CLKDIV.clkdiv = \\left(\\frac{50,000000}{115,200} \\right) = 434.03 \u00d7 2 = 868\\)</p> </li> </ul>"},{"location":"universal-asynchronous-receiver-transmitter/#low-power-mode-operation-of-lpuarts-for-9600-baud-and-below","title":"Low-Power Mode Operation of LPUARTs for 9600 Baud and Below","text":"<p>LPUART instances can configure the receiver for 9600 and lower baud rates and enable the LPUART in the low-power modes SLEEP, LPM, and UPM. Receipt of a valid frame loads the receive FIFO and increments UARTn_STATUS.rx_lvl. If a wake-up event, shown in Table 12-5, is enabled, the device exits the current low-power mode and returns to ACTIVE if the wake-up event occurs. See section Baud Rate Calculation and Equation 12-3 for details on setting the baud rate for LPUART instances with UARTn_CTRL.fdm set to 1.</p> <p>Table 12-6: LPUART Low Baud Rate Generation Examples (UARTn_CTRL.fdm = 1) </p> Clock Source BAUD (bits/s) Ratio (Clock/BAUD)              Calculated UARTn_CLKDIV.clkdiv Error UARTn_OSR.osr ERTCO 9,600 3.413 7 -2.5% N/A (1\u00d7) 7,200 4.551 9 +1.1% N/A (1\u00d7) 4,800 6.827 14 -2.5% N/A (1\u00d7) 2,400 13.653 27 +1.1%              0: 8\u00d7             1: 12\u00d7          1,800 18.204 36 +1.1%              0: 8\u00d7             1: 12\u00d7             2: 16\u00d7          1,200 27.307 54 +1.1%              0: 8\u00d7             1: 12\u00d7             2: 16\u00d7             3: 20\u00d7             4: 24\u00d7"},{"location":"universal-asynchronous-receiver-transmitter/#configuring-an-lpuart-for-low-power-modes-of-operation","title":"Configuring an LPUART for Low-Power Modes of Operation","text":"<p>Use the following procedure to receive characters at 9600 or lower baud rates while in low-power modes:</p> <ol> <li>Clear UARTn_CTRL.bclken = 0 to disable the baud clock. The hardware immediately clears UARTn_CTRL.bclkrdy to 0.</li> <li>Set PWRSEQ_LPCN.x32ken= 1 to ensure the 32kHz clock source remains active in LPM and UPM modes.</li> <li>Ensure UARTn_CTRL.ucagm = 1.</li> <li>Configure UARTn_CTRL.bclksrc to select the ERTCO.</li> <li>Set UARTn_CTRL.fdm to 1 to enable FDM.</li> <li>Set UARTn_CLKDIV.clkdiv to the calculated clock divisor shown in Table 12-6 for the required baud rate.</li> <li>Set UARTn_CTRL.desm to 1 to enable receive dual-edge sampling mode.</li> <li>Choose the desired wake-up conditions from Table 12-5. a. Clear any of the wake-up conditions chosen if currently active in the UARTn_WKFL register. b. Enable the wake-up condition; set the wake-up field to 1 in the UARTn_WKEN register.</li> <li>Set the UARTn_CTRL.bclken field to 1 to enable the baud clock.</li> <li>Poll the UARTn_CTRL.bclkrdy field until it reads 1.</li> <li>Enter the desired low-power mode.</li> </ol>"},{"location":"universal-asynchronous-receiver-transmitter/#hardware-flow-control","title":"Hardware Flow Control","text":"<p>The optional HFC uses two additional pins, CTS and RTS, as a handshaking protocol to manage UART communications. For full-duplex operation, the RTS output pin on the peripheral is connected to the CTS input pin on the external UART, and the CTS input pin on the peripheral is connected to the RTS output pin on the external UART, as shown in Figure 12-7.</p> <p>Figure 12-7: Hardware Flow Control Physical Connection </p> <p></p> <p>In HFC operation, a UART transmitter waits for the external device to assert its CTS pin. When CTS is asserted, the UART transmitter sends data to the external device. The external device keeps CTS asserted until it cannot receive additional data, typically because the external device's receive FIFO is full. The external device then deasserts CTS until the device can receive more data. The external device then asserts CTS again, allowing additional data to be sent.</p> <p>Hardware flow control can be fully automated by the peripheral hardware or by software through direct monitoring of the CTS input signal and control of the RTS output signal.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#automated-hfc","title":"Automated HFC","text":"<p>Setting UARTn_CTRL.hfc_en = 1 enables automated HFC. When automated HFC is enabled, the hardware manages the CTS and RTS signals. The deassertion of the RTS signal is configurable using the UARTn_CTRL.rtsdc field:</p> <ul> <li>UARTn_CTRL.rtsdc = 0: Deassert RTS when UARTn_STATUS.rx_lvl = C_RX_FIFO_DEPTH</li> <li>UARTn_CTRL.rtsdc = 1: Deassert RTS while UARTn_STATUS.rx_lvl \u2265= UARTn_CTRL.rx_thd_val</li> </ul> <p>The transmitter continues to send data as long as the CTS signal is asserted and there is data in the transmit FIFO. If the receiver de-asserts the CTS pin, the transmitter finishes the transmission of the current character and then waits until the CTS pin state is asserted before continuing transmission. Figure 12-8 shows the state of the CTS pin during a transmission under automated HFC.</p> <p>Automated HFC does not generate interrupt events related to the state of the transmit FIFO or the receive FIFO. The software must handle FIFO management. See Interrupt Events for additional information.</p> <p>Figure 12-8: Hardware Flow Control Signaling for Transmitting to an External Receiver </p> <p></p>"},{"location":"universal-asynchronous-receiver-transmitter/#application-controlled-hfc","title":"Application Controlled HFC","text":"<p>Application controlled HFC requires the software to manually control the RTS output pin and monitor the CTS input pin. Using application controlled HFC requires the automated HFC to be disabled by setting the UARTn_CTRL.hfc_en field to 1. Additionally, the software should enable CTS sampling (UARTn_CTRL.cts_dis = 0) if performing application controlled HFC.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#rtccts-handling-for-application-controlled-hfc","title":"RTC/CTS Handling for Application Controlled HFC","text":"<p>The software can manually monitor the CTS pin state by reading the field UARTn_PNR.cts. The software can manually set the state of the RTS output pin and read the current state of the RTS output pin using the field UARTn_PNR.rts. The software must manage the state of the RTS pin when performing application controlled HFC.</p> <p>Interrupt support for CTS input signal change events is supported even when automated HFC is disabled. The software can enable the CTS interrupt event by setting the UARTn_INT_EN.cts_ev field to 1. The CTS signal change interrupt flag is set by the hardware any time the CTS pin state changes. The software must clear this interrupt flag manually by writing 1 to the UARTn_INT_FL.cts_ev field.</p> <p>Note: CTS pin state monitoring is disabled any time the UART baud clock is disabled (UARTn_CTRL.bclken = 0). The software must enable CTS pin monitoring by setting the field UARTn_CTRL.cts_dis to 0 after enabling the baud clock if CTS pin state monitoring is required.</p>"},{"location":"universal-asynchronous-receiver-transmitter/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. If multiple instances of the peripheral are provided, each instance has its own independent set of the registers shown in Table 12-7. Register names for a specific instance are defined by replacing \"n\" with the instance number. As an example, a register PERIPHERALn_CTRL resolves to PERIPHERAL0_CTRL and PERIPHERAL1_CTRL for instances 0 and 1, respectively.</p> <p>See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>All registers and fields apply to both UART and LPUART instances unless specified otherwise.</p> <p>Table 12-7: UART/LPUART Register Summary </p> Offset Register Name [0x0000] UARTn_CTRL UART Control Register [0x0004] UARTn_STATUS UART Status Register [0x0008] UARTn_INT_EN UART Interrupt Enable Register [0x000C] UARTn_INT_FL UART Interrupt Flag Register [0x0010] UARTn_CLKDIV UART Clock Divisor Register [0x0014] UARTn_OSR UART Oversampling Control Register [0x0018] UARTn_TXPEEK UART Transmit FIFO [0x001C] UARTn_PNR UART Pin Control Register [0x0020] UARTn_FIFO UART FIFO Data Register [0x0030] UARTn_DMA UART DMA Control Register [0x0034] UARTn_WKEN UART Wakeup Interrupt Enable Register [0x0038] UARTn_WKFL UART Wakeup Interrupt Flag Register"},{"location":"universal-asynchronous-receiver-transmitter/#register-details","title":"Register Details","text":"<p>Table 12-8: UART Control Register </p> UART Control UARTn_CTRL [0x0000] Bits Name Access Reset Description 31:23 - DNM 0 Reserved 22 desm R/W 0 Receive Dual Edge Sampling Mode     LPUART instances only. This field is reserved in standard UART instances.          0: Sample receive input signal on clock rising edge only      1: Sample receive input signal on both rising and falling edges      21 fdm R/W 0 Fractional Division Mode     LPUART instances only. This field is reserved in standard UART instances.          0: Baud rate divisor is an integer      1: Baud rate divisor supports 0.5 division resolution      20 ucagm R/W 0 UART Clock Auto Gating Mode Note: Software must set this field to 1 for proper operation.      0: No gating      1: UART clock is paused during transmit and receive idle states      19 bclkrdy R 0 Baud Clock Ready Note: Software must set this field to 1 for proper operation.      0: No gating      1: UART clock is paused during transmit and receive idle states      18 dpfe_en R/W 0 Data/Parity Bit Frame Error Detection Enable     LPUART instances only. This field is reserved in standard UART instances.          0: Disable. Do not detect frame errors on receive between the start bit and stop bit.      1: Enable. Detect frame errors when receive changes at the center of a bit time.      17:16 bclksrc R/W 0 Baud Clock Source     This field selects the baud clock source. See Table 12-1 for available clock options for each UART instance.          0: Clock option 0      1: Clock option 1      2: Clock option 2      3: Clock option 3      15 bclken R/W 0 Baud Clock Enable      0: Disabled      1: Enabled      14 rtsdc R 0 Hardware Flow Control RTS Deassert Condition      0: Deassert RTS when receive FIFO Level = C_RX_FIFO_DEPTH (FIFO full)      1: Deassert RTS while receive FIFO Level &gt;= UARTn_CTRL.rx_thd_val.      13 hfc_en R/W 0 Hardware Flow Control Enable      0: Disabled      1: Enabled      12 stopbits R/W 0 Number of Stop Bits      0: Disabled      1: Enabled      11:10 char_size R/W 0 Character Length      0: 5 bits      1: 6 bits      2: 7 bits      3: 8 bits      9 rx_flush W1 0 Receive FIFO Flush     Write 1 to flush the receive FIFO. This bit always reads 0.          0: N/A      1: Flush FIFO      8 tx_flush W1 0 Transmit FIFO Flush     Write 1 to flush the transmit FIFO. This bit always reads 0.          0: N/A      1: Flush FIFO      7 cts_dis R/W 1 CTS Sampling Disable          0: Enabled          1: Disabled          6 par_md R/W 1 Parity Value Select          0: Parity calculation is based on 1 bits. (Mark)          1: Parity calculation is based on 0 bits. (Space)          5 par_eo R/W 0 Parity Odd/Even Select          0: Even parity          1: Odd parity          4 par_en R/W 0 Transmit Parity Generation Enable          0: Parity transmission disabled.          1: Parity bit is calculated and transmitted after the last character bit.          3:0 rx_thd_val R/W 0 Receive FIFO Threshold     Valid settings are from 1 to C_RX_FIFO_DEPTH.                  0: Reserved.          1: 1.          2: 2.          3: 3.          4: 4.          5: 5.          6: 6.          7: 7.          8: 8.          9 - 15: Reserved.          <p>Table 12-9: UART Status Register </p> UART Status UARTn_STATUS [0x0004] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:12 tx_lvl RO 0 Transmit FIFO Level         This field returns the number of characters in the transmit FIFO.                  0 - 8: Number of bytes in the transmit FIFO         9 - 15: Reserved for Future Use          11:8 rx_lvl RO 0 Receive FIFO Level         This field returns the number of characters in the Receive FIFO.                  0 - 8: Number of bytes in the receive FIFO         9 - 15: Reserved for Future Use          7 tx_full RO 0 Transmit FIFO Full          0: Not full         1: Full          6 tx_em RO 1 Transmit FIFO Empty          0: Not empty         1: Empty          5 rx_full RO 0 Receive FIFO Full          0: Not full         1: Full          4 rx_em RO 1 Receive FIFO Empty          0: Not empty         1: Empty          3:2 - RO 0 Reserved 1 rx_busy RO 0 Receive Busy          0: UART is not receiving a character         1: UART is receiving a character          0 tx_busy RO 0 Transmit Busy          0: UART is not transmitting data         1: UART is transmitting data          <p>Table 12\u201110: UART Interrupt Enable Register </p> UART Interrupt Enable Register UARTn_INT_EN [0x0008] Bits Name Access Reset Description 31:7 - RO 0 Reserved 6 tx_he R/W 0 Transmit FIFO Half-Empty Event Interrupt Enable          0: Disabled         1: Enabled          5 - RO 0 Reserved 4 rx_thd R/W 0 Receive FIFO Threshold Event Interrupt Enable          0: Disabled         1: Enabled          3 rx_ov R/W 0 Receive FIFO Overrun Event Interrupt Enable          0: Disabled         1: Enabled          2 cts_ev R/W 0 CTS Signal Change Event Interrupt Enable          0: Disabled         1: Enabled          1 rx_par R/W 0 Receive Parity Event Interrupt Enable          0: Disabled         1: Enabled          0 rx_ferr R/W 0 Receive Frame Error Event Interrupt Enable          0: Disabled         1: Enabled          <p>Table 12-11: UART Interrupt Flag Register </p> UART Interrupt Flag UARTn_INT_FL [0x000C] Bits Name Access Reset Description 31:7 - RO 0 Reserved 6 tx_he R/W1C 0 Transmit FIFO Half-Empty Interrupt Flag          0: Disabled         1: Enabled 5 - RO 0 Reserved 4 rx_thd R/W1C 0 Receive FIFO Threshold Interrupt Flag          0: Disabled         1: Enabled 3 rx_ov R/W1C 0 Receive FIFO Overrun Interrupt Flag          0: Disabled         1: Enabled 2 cts_ev R/W1C 0 CTS Signal Change Interrupt Flag          0: Disabled         1: Enabled 1 rx_par R/W1C 0 Receive Parity Error Interrupt Flag          0: Disabled         1: Enabled 0 rx_ferr R/W1C 0 Receive Frame Error Interrupt Flag          0: Disabled         1: Enabled <p>Table 12-12: UART Clock Divisor Register </p> UART Clock Divisor UARTn_CLKDIV [0x0010] Bits Name Access Reset Description 31:20 - RO 0 Reserved 19:0 clkdiv R/W 0 Baud Rate Divisor         This field sets the divisor used to generate the baud tick from the baud clock. For LPUART instances, if UARTn_CTRL.fdm = 1, the fractional divisors are in increments of 0.5. The over-sampling rate must be no greater than this divisor. See section Baud Rate Generation for information on how to use this field.                  <p>Table 12-13: UART Oversampling Control Register </p> UART Oversampling Control UARTn_OSR [0x0014] Bits Name Access Reset Description 31:20 - RO 0 Reserved 31:20 osr R/W 0 LPUART Over Sampling Rate          For LPUART instances with FDM enabled (UARTn_CTRL.fdm = 1):                      0: 8 \u00d7              1: 12 \u00d7              2: 16 \u00d7              3: 20 \u00d7              4: 24 \u00d7              5: 28 \u00d7              6: 32 \u00d7              7: 36 \u00d7                  For LPUART instances with FDM disabled (UARTn_CTRL.fdm = 0):               0: 128 \u00d7              1: 64 \u00d7              2: 32 \u00d7              3: 16 \u00d7              4: 8 \u00d7              5: 4 \u00d7              6 - 7: Reserved for Future Use          <p>Table 12-14: UART Transmit FIFO Register </p> UART Transmit FIFO UARTn_TXPEEK [0x0018] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7:0 data RO 0 Transmit FIFO Data         Read the transmit FIFO next data without affecting the contents of the transmit FIFO. If there are no entries in the transmit FIFO, this field reads 0.  Note: The parity bit is available from this field. <p>Table 12-15: UART Pin Control Register </p> UART Pin Control UARTn_PNR [0x001C] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1 rts R/W 1 RTS Pin Output State          0: RTS signal is driven to 0          1: RTS signal is driven to 1          0 cts RO 1 CTS Pin State         This field returns the current sampled state of the GPIO associated with the CTS signal.                  0: CTS state is 0          1: CTS state is 1          <p>Table 12-16: UART Data Register </p> UART Data UARTn_FIFO [0x0020] Bits Name Access Reset Description 31:9 - RO 0 Reserved 8 rx_par R 0 Receive FIFO Byte Parity         If a parity error occurred during the reception of the character at the output end of the receive FIFO (this is returned by reading the UARTn_FIFO.data field), this bit reads 1, otherwise it reads 0.  Note: If parity is disabled, this bit always reads 0. 7:0 data R/W 0 Transmit/Receive FIFO Data         Writing to this field loads the next character into the transmit FIFO if the transmit FIFO is not full.          Reading from this field returns the next character from the receive FIFO if the receive FIFO is not empty. If the receive FIFO is empty, 0 is returned by the hardware.          For character widths less than 8, the unused bit(s) are ignored when the transmit FIFO is loaded, and the unused high bit(s) read 0 on characters read from the receive FIFO.          <p>Table 12-17: UART DMA Register </p> UART DMA UARTn_DMA [0x0030] Bits Name Access Reset Description 31:10 - RO 0 Reserved 9 rx_en 0 0 Receive DMA Channel Enable          0: Disabled         1: Enabled          8:5 rx_thd_val 0 0 Receive FIFO Level DMA Threshold          If UARTn_STATUS.rx_lvl &lt; UARTn_DMA.rx_thd_val, then the receive\u00a0FIFO\u00a0DMA interface sends a signal to the DMA indicating characters are available in the UART receive FIFO to transfer to memory.          4 tx_en R/W 0 Transmit DMA Channel Enable          0: Disabled         1: Enabled          3:0 tx_thd_val R/W 0 Transmit FIFO Level DMA Threshold          If UARTn_STATUS.tx_lvl &lt; UARTn_DMA.tx_thd_val, the transmit DMA channel sends a signal to the DMA indicating that the UART transmit FIFO is ready to receive data from memory.          <p>Table 12-18: UART Wakeup Enable </p> UART Wakeup Enable UARTn_WKEN [0x0034] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2 rx_thd R/W 0 Receive FIFO Threshold Wake-up Event Enable          0: Disabled         1: Enabled          1 rx_full R/W 0 Receive FIFO Full Wake-Up Event Enable          0: Disabled         1: Enabled          0 rx_ne R/W 0 Receive FIFO Not Empty Wake-Up Event Enable          0: Disabled         1: Enabled          <p>Table 12-19: UART Wakeup Flag Register </p> UART Wakeup Flag UARTn_WKFL [0x0038] Bits Name Access Reset Description 31:3 - RO 0 Reserved 2 rx_thd R/W 0 Receive FIFO Threshold Wake-up Event          0: Disabled         1: Enabled          1 rx_full R/W 0 Receive FIFO Full Wake-Up Event          0: Disabled         1: Enabled          0 rx_ne R/W 0 Receive FIFO Not Empty Wake-Up Event          0: Disabled         1: Enabled"}]}